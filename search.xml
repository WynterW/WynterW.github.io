<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac 制作一个可执行脚本]]></title>
    <url>%2F2018%2F07%2F25%2FMac%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[在工作中我们经常会用到一些命令来完成指定工作，最常用的还是Git和SVN一些更新、提交操作，虽然命令不是很复杂，但是肯定会有三个步骤： 1、打开终端；2、cd到指定目录下；3、执行一系列相关操作命令。 一些常用的操作我们就可以制作一个脚本来简化步骤。 制作一个可执行脚本，分为以下步骤： 创建脚本文件，在终端中执行（文件想要保存在哪里在那个目录下执行命令） 1touch fileName.sh 给脚本添加可执行权限，具体可以参考Mac 修改文件读写权限 1chmod 755 fileName.sh 使用终端cd到脚本所在目录执行 1./fileName.sh 简单应用以下是我正在使用一个简易脚本，可以用它来实现： 1、将写好的博客生成静态文件并部署2、备份博客所有文件到git，防止本地文件丢失 1234567891011121314151617181920212223242526272829#！ /bin/bash# dirname $0，取得当前执行的脚本文件的父目录basepath=$(cd `dirname $0`; pwd)#进入到hexo所在的目录cd $&#123;basepath&#125;/Wynter.github.io# 打印当前路径currentPath=$(pwd)echo "当前文件夹路径: $currentPath"# 生成静态文件并部署echo "start update hexo"hexo d -gecho "end hexo"# 返回到上级目录cd ..# 拉去git上最新数据git pull# 备份博客所有文件到gitecho "start update git"git add .git commit -m "update blog"git push origin masterdate=$(date +%Y%m%d%H%M) 在iOS应用开发完成后，经常要使用Xcode打包给测试人员，不仅编译时间长，期间还不能敲代码，编译完成后还需要手动导入，发给测试人员等一系列操作，这完全可以使用脚本来实现来提升工作效率。 附上一个iOS自动打包脚本传送门。 答疑解惑既然都是脚本，为什么还要在终端里./fileName.sh才能执行，这so不智能了吧！为什么不能双击执行呢？ 它的确是可执行脚本，因为脚本的后缀是.sh，而我们的mac中刚好有应用能识别并打开.sh结尾的文件，如果删除电脑上所有能识别.sh的应用，再次双击脚本就直接执行脚本了。显然删除这么多应用是不现实的，我们可以在创建的时候不给文件添加后缀来实现双击执行脚本的目的。 总结可以说没有什么操作是一个脚本解决不了的，如果解决不了那就再来一个。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 模型数组深拷贝]]></title>
    <url>%2F2018%2F05%2F11%2FiOS%20%E6%A8%A1%E5%9E%8B%E6%95%B0%E7%BB%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[通常需要实现对模型的拷贝都需要先实现NSCopying、 NSMutableCopying协议，在这里我一直有个误区，以为实现了copy协议，数组使用拷贝操作都会对数组内实现copy协议的对象进行拷贝。 创建两个model并实现copying协议1234567891011121314151617181920212223// Dog.h@interface Dog : NSObject &lt;NSCopying, NSMutableCopying&gt;@property (nonatomic, copy) NSString *name;@end// Dog.m@implementation Dog- (nonnull id)copyWithZone:(nullable NSZone *)zone &#123; Dog *copy = [[Dog allocWithZone:zone]init]; copy.name = self.name; return copy;&#125;- (id)mutableCopyWithZone:(NSZone *)zone &#123; Dog *copy = [[Dog allocWithZone:zone]init]; copy.name = self.name; return copy;&#125;@end 12345678910111213141516171819202122232425262728293031// Person.h#import "Dog.h"@interface Person : NSObject &lt;NSCopying, NSMutableCopying&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@property (nonatomic, copy) Dog *dog;@end// Person.m@implementation Person- (nonnull id)copyWithZone:(nullable NSZone *)zone &#123; Person *copy = [[Person allocWithZone:zone]init]; copy.name = self.name; copy.age = self.age; copy.dog = [self.dog copy]; return copy;&#125;- (id)mutableCopyWithZone:(NSZone *)zone &#123; Person *copy = [[Person allocWithZone:zone]init]; copy.name = self.name; copy.age = self.age; copy.dog = [self.dog copy]; return copy;&#125;@end 对模型数组使用mutablCopy操作并不是深拷贝12345678910111213141516171819202122232425262728293031NSMutableArray &lt;Person *&gt;*dataSourceAry = [NSMutableArray new];for (int i = 0; i &lt; 2; i++) &#123; Dog *dog = [[Dog alloc]init]; dog.name = @"拉不拉多不多就拉倒"; Person *item = [[Person alloc]init]; item.name = @"杰克"; item.age = 18; item.dog = [dog copy]; [dataSourceAry addObject:item];&#125;NSArray &lt;Person *&gt;*array = [dataSourceAry mutableCopy];NSLog(@"&lt;dataSourceAry: %@&gt;", dataSourceAry);NSLog(@"&lt;array: %@&gt;", array);[array enumerateObjectsUsingBlock:^(Person *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; obj.name = @"肉丝";&#125;];NSLog(@"dataSourceAry[0].name = %@", dataSourceAry[0].name);NSLog(@"array[0].name = %@", array[0].name);/** 打印结果 &lt;dataSourceAry: ("&lt;Person: 0x60000043ec00&gt;", "&lt;Person: 0x60000043e9c0&gt;")&gt; &lt;array: ("&lt;Person: 0x60000043ec00&gt;","&lt;Person: 0x60000043e9c0&gt;")&gt; dataSourceAry[0].name = 肉丝 array[0].name = 肉丝 */ 可以从打印的结果看出，数组内元素的内存地址是相同的，所以出现了修改拷贝后数组的第一个元素，导致原数组的第一个元素也发生了同样的改变。虽然两个数组的内存地址不一样，但是内部元素内存地址还是同一地址，不是我们想要的结果。 实现模型数组深拷贝的方法1、最笨的方法就是通过遍历逐个拷贝元素1234NSMutableArray *array = [NSMutableArray array];for (Person *person in dataSourceAry) &#123; [array addObject:[person copy]];&#125; 2、也有人使用归档解档实现数组内部元素拷贝 3、这么好用的一个方法现在才发现（推荐） flag=YES当模型数组内元素对象遵守了copy协议，数组元素对象才能进行深拷贝。数组元素对象没有遵守copy协议或者flag=NO，则会进行浅拷贝1- (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array copyItems:(BOOL)flag 12345678910111213141516171819202122232425NSArray &lt;Person *&gt;*deepCopyAry = [[NSArray alloc]initWithArray:dataSourceAry copyItems:YES];NSLog(@"&lt;dataSourceAry: %@&gt;", dataSourceAry);NSLog(@"&lt;deepCopyAry: %@&gt;", deepCopyAry); [deepCopyAry enumerateObjectsUsingBlock:^(Person *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; obj.name = @"弗兰克"; obj.dog.name = @"弗兰克的dog";&#125;];NSLog(@"dataSourceAry[0].name = %@", dataSourceAry[0].name);NSLog(@"deepCopyAry[0].name = %@", deepCopyAry[0].name); NSLog(@"dataSourceAry[0].dog.name = %@", dataSourceAry[0].dog.name);NSLog(@"deepCopyAry[0].dog.name = %@", deepCopyAry[0].dog.name); /** 打印结果&lt;dataSourceAry: ("&lt;Person: 0x604000427680&gt;", "&lt;Person: 0x604000425220&gt;")&gt;&lt;deepCopyAry: ("&lt;Person: 0x60000042cb80&gt;", "&lt;Person: 0x60000042cae0&gt;")&gt; dataSourceAry[0].name = 肉丝deepCopyAry[0].name = 弗兰克 dataSourceAry[0].dog.name = 拉不拉多不多就拉倒deepCopyAry[0].dog.name = 弗兰克的dog */ 总结1、模型数组内元素中模型必须要实现copy协议，模型内如果有嵌套模型，也需要实现copy协议，否则执行对对象拷贝操作会出现崩溃；2、使用- (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array copyItems:(BOOL)flag实现模型数组拷贝；]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN命令使用汇总]]></title>
    <url>%2F2018%2F05%2F11%2FSVN%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[总结一下SVN使用中一些常用命令及示例。 初始化项目1svn import 本地文件路径 http://server/项目路径 --username=用户名 --password=密码 -m "批注" 例如：svn import /Users/Wynter/Desktop/项目目录 http://server/项目路径 –username=Wynter –password=Wynter -m “import” 下载项目到本地12svn checkout 服务器项目路径 -username=用户名 --password=密码 本地项目路径svn co 例如：svn checkout http://server/项目路径 –username=Wynter –password=Wynter /Users/Wynter/Desktop/本地项目路径 添加文件12svn add file svn add . 例如：svn add test.txt(添加test.txt)svn add *.php(添加当前目录下所有的php文件)svn add . （添加当前目录下所有文件) 提交添加的文件，或者本地做的修改提交到版本库12svn commit -m "批注" [-N] [--no-unlock] path(如果选择了保持锁，就使用–no-unlock开关) svn ci -m "批注" 例如：svn ci -m “add test.txt by test” 删除文件12svn delete path -m "批注" svn (del, remove, rm) path -m "批注" 例如：svn delete https://server/项目目录/test.text -m “删除test.text 文件”svn delete /Users/Wynter/本地项目目录 -m “删除目录” 更新最新版本或指定版本123svn updatesvn update -r 回滚到的版本号svn up 例如：svn update （如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本）svn update -r 200 test.txt (更新指定的版本) 注意：如果在提交的时候提示过期的话，是因为冲突，需要先 svn update，修改文件，然后清除svn resolved，最后再提交 svn ci -m “” 查看本地修改的文件状态12svn statussvn st 例如：svn status path（目录下的文件和子目录的状态，正常状态不显示）【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 svn status -v path(显示文件和子目录状态)第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。 下载不带版本控制的项目到本地（没有svn隐藏记录信息）1svn export 服务器项目路径 -username=用户名 --password=密码 本地项目路径 例如：svn export http://server/项目路径 –username=Wynter –password=Wynter /Users/Wynter/Desktop/本地项目目录 加锁/解锁12svn lock path svn unlock path 例如：svn lock /Users/Wynter/Desktop/本地项目目录（或文件名）－m “批注”svn unlock /Users/Wynter/Desktop/本地项目目录（或文件名） 查看日志1svn log path 例如：svn log /Users/Wynter/Desktop/本地项目目录/test.txt 比较差异123svn diff path(将修改的文件与基础版本比较) svn diff -r m:n path (对版本m和版本n比较差异)svn di 例如：svn diff text.txtsvn diff -r 200:201 text.txt 合并两个版本1svn merge -r m:n path 例如：svn merge -r 12:14 text.txt (把版本12和14之间的差异合并到当前的文件中) 冲突合并1svn resolved path （移除工作副本的目录或文件的"冲突"状态） 例如：svn resolve test.txt 恢复本地修改12svn revert file pathsvn revert -R path 例如：svn revert test.textsvn revert -r /Users/Wynter/Desktop/本地项目目录 复制一个项目（打标签/打分支）123svn copy 原地址URL 目标地址URL -m "批注"svn copy . 目标地址 -m "批注" (必须要原地址目录下)svn cp 例如：svn copy http://server/项目路径/branch/IPM http://server/项目路径/tag/IPM_V1 -m “在分支中打个tag”svn copy . http://server/项目路径/tag/tag目录目录 -m “在分支中打个tag” 合并代码1svn merge -r m:n path 例如：合并文件：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件） 主干合并到分支cd branchsvn merge http://server/trunk 分支合并到主干cd trunksvn merge –reintegrate http://server/branchs/IPM_V1_1 合并版本并将合并后的结果应用到现有的分支上svn merge -r 200:205 http://server/trunk 代码库URL变更123svn switch &lt;branch_full_url&gt; (切换分支)svn switch --relocate &lt;from_url&gt; &lt;to_url&gt; [path] (切换资源库)svn sw 例如：svn switch http://server/branchs/IPM_V1_1svn sw –relocate http://old_server/项目目录 http://new_server/项目目录 svn帮助12svn helpsvn help commit]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 自定义-苹方字体的使用]]></title>
    <url>%2F2018%2F05%2F11%2FiOS%20%E8%87%AA%E5%AE%9A%E4%B9%89-%E8%8B%B9%E6%96%B9%E5%AD%97%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[不是系统已经自带苹方字体了为什么还要自定义呢？因为苹方字体是在iOS 9引入的，所以如果要支持iOS 9以下都要手动引入苹方字体。 添加苹方字体到项目中 获取苹方字体，Command+G输入/System/Library/Fonts/PingFang.ttc 直接拖到将PingFang.ttc文件拖到项目中 在 info.plist文件中添加Fonts provided by application，并设置字体包名称 我在iOS 8系统的模拟器中没有在Info.plist中添加Fonts provided by application，也已经可以正常使用苹方字体了 获取当前系统支持的字体1234567891011121314151617181920212223242526272829303132333435for (NSString *fontFamilyName in UIFont.familyNames) &#123; NSLog(@"familyName:%@", fontFamilyName); for (NSString *fontName in [UIFont fontNamesForFamilyName:fontFamilyName]) &#123; NSLog(@"fontName:%@", fontName); &#125;&#125;打印结果省略了苹方字体以外的字体/** …… 2018-04-28 11:07:52.217401+0800 QYLY[5900:238352] familyName:PingFang TC 2018-04-28 11:07:52.218150+0800 QYLY[5900:238352] fontName:PingFangTC-Regular 2018-04-28 11:07:52.218609+0800 QYLY[5900:238352] fontName:PingFangTC-Thin 2018-04-28 11:07:52.219340+0800 QYLY[5900:238352] fontName:PingFangTC-Medium 2018-04-28 11:07:52.220841+0800 QYLY[5900:238352] fontName:PingFangTC-Semibold 2018-04-28 11:07:52.222403+0800 QYLY[5900:238352] fontName:PingFangTC-Light 2018-04-28 11:07:52.223328+0800 QYLY[5900:238352] fontName:PingFangTC-Ultralight …… 2018-04-28 11:07:52.299506+0800 QYLY[5900:238352] familyName:PingFang HK 2018-04-28 11:07:52.300103+0800 QYLY[5900:238352] fontName:PingFangHK-Medium 2018-04-28 11:07:52.300944+0800 QYLY[5900:238352] fontName:PingFangHK-Thin 2018-04-28 11:07:52.301597+0800 QYLY[5900:238352] fontName:PingFangHK-Regular 2018-04-28 11:07:52.302162+0800 QYLY[5900:238352] fontName:PingFangHK-Ultralight 2018-04-28 11:07:52.302652+0800 QYLY[5900:238352] fontName:PingFangHK-Semibold 2018-04-28 11:07:52.303029+0800 QYLY[5900:238352] fontName:PingFangHK-Light …… 2018-04-28 11:07:52.423305+0800 QYLY[5900:238352] familyName:PingFang SC 2018-04-28 11:07:52.423714+0800 QYLY[5900:238352] fontName:PingFangSC-Medium 2018-04-28 11:07:52.424151+0800 QYLY[5900:238352] fontName:PingFangSC-Semibold 2018-04-28 11:07:52.424397+0800 QYLY[5900:238352] fontName:PingFangSC-Light 2018-04-28 11:07:52.424621+0800 QYLY[5900:238352] fontName:PingFangSC-Ultralight 2018-04-28 11:07:52.424934+0800 QYLY[5900:238352] fontName:PingFangSC-Regular 2018-04-28 11:07:52.425314+0800 QYLY[5900:238352] fontName:PingFangSC-Thin …… */ 苹方字体怎么会有PingFang SC、PingFang TC、PingFang HK三种呢？对应的是苹方-简、苹方-繁、苹方-港，而且都有六种字重，具体可以在字体册中查看。 苹方-简 中黑体 PingFangSC-Medium苹方-简 中粗体 PingFangSC-Semibold苹方-简 细体 PingFangSC-Light苹方-简 极细体 PingFangSC-Ultralight苹方-简 常规体 PingFangSC-Regular苹方-简 纤细体 PingFangSC-Thin 设置苹方字体123456789// 苹方字体，默认为PingFangSC-RegularUIFont *font = [UIFont fontWithName:@"PingFangSC-Regular" size:14];NSString *familyName = font.familyName;NSString *fontName = font.fontName;NSLog(@"familyName:%@\nfontName:%@", familyName, fontName);/** familyName:PingFang SC fontName:PingFangSC-Regular */ 扩展每次都要输入字体名称比较麻烦，并且还要支持iOS 9以下，使用分类方法比较好。 1234567891011121314151617181920212223#import &lt;UIKit/UIKit.h&gt;typedef NS_ENUM(NSInteger, FontWeightStyle) &#123; FontWeightStyleMedium, // 中黑体 FontWeightStyleSemibold, // 中粗体 FontWeightStyleLight, // 细体 FontWeightStyleUltralight, // 极细体 FontWeightStyleRegular, // 常规体 FontWeightStyleThin, // 纤细体&#125;;@interface UIFont (Ex)/** 苹方字体 @param fontWeight 字体粗细（字重) @param fontSize 字体大小 @return 返回指定字重大小的苹方字体 */+ (UIFont *)pingFangSCWithWeight:(FontWeightStyle)fontWeight size:(CGFloat)fontSize;@end 12345678910111213141516171819202122232425262728293031323334353637#import "UIFont+Ex.h"@implementation UIFont (Ex)+ (UIFont *)pingFangSCWithWeight:(FontWeightStyle)fontWeight size:(CGFloat)fontSize &#123; if (fontWeight &lt; FontWeightStyleMedium || fontWeight &gt; FontWeightStyleThin) &#123; fontWeight = FontWeightStyleRegular; &#125; NSString *fontName = @"PingFangSC-Regular"; switch (fontWeight) &#123; case FontWeightStyleMedium: fontName = @"PingFangSC-Medium"; break; case FontWeightStyleSemibold: fontName = @"PingFangSC-Semibold"; break; case FontWeightStyleLight: fontName = @"PingFangSC-Light"; break; case FontWeightStyleUltralight: fontName = @"PingFangSC-Ultralight"; break; case FontWeightStyleRegular: fontName = @"PingFangSC-Regular"; break; case FontWeightStyleThin: fontName = @"PingFangSC-Thin"; break; &#125; UIFont *font = [UIFont fontWithName:fontName size:fontSize]; return font ?: [UIFont systemFontOfSize:fontSize];&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 使用AFNetworking传输字符串]]></title>
    <url>%2F2018%2F05%2F11%2FiOS%20%E4%BD%BF%E7%94%A8AFNetworking%E4%BC%A0%E8%BE%93%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[通常网络请求使用AFNetworking我们都会将字典作为参数传给服务端，如果应用对数据的安全级别要求较高，这时肯定会将参数加密后再传输，那么上传的参数就变成一串看不懂的字符串，我们只需要设置AFHTTPSessionManager中几个类型即可直接上传字符。 配置参数请求和接收类型12345678910+ (AFHTTPSessionManager *)getRequstManager &#123; AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.requestSerializer.timeoutInterval = 30; manager.requestSerializer.stringEncoding = NSUTF8StringEncoding; manager.requestSerializer = [AFHTTPRequestSerializer serializer]; manager.responseSerializer = [AFHTTPResponseSerializer serializer]; [manager.requestSerializer setValue:@&quot;text/html&quot; forHTTPHeaderField:@&quot;Accept&quot;]; [manager.requestSerializer setValue:@&quot;text/html&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; return manager;&#125; 配置完成后发送请求，可能会发现服务端接收的字符串前面莫名的多出’=’符号，查看源码发现AFURLRequestSerialization文件中下面的方法引起的1234567- (NSString *)URLEncodedStringValue &#123; if (!self.value || [self.value isEqual:[NSNull null]]) &#123; return AFPercentEscapedStringFromString([self.field description]); &#125; else &#123; return [NSString stringWithFormat:@&quot;%@=%@&quot;, AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])]; &#125;&#125; 顺藤摸瓜发现AFQueryStringFromParameters函数中使用到了- URLEncodedStringValue方法。发现如下代码使用到了AFQueryStringFromParameters函数，如果实现self.queryStringSerialization属性就可以解决’=’问题。123456789101112131415161718if (self.queryStringSerialization) &#123; NSError *serializationError; query = self.queryStringSerialization(request, parameters, &amp;serializationError); if (serializationError) &#123; if (error) &#123; *error = serializationError; &#125; return nil; &#125;&#125; else &#123; switch (self.queryStringSerializationStyle) &#123; case AFHTTPRequestQueryStringDefaultStyle: query = AFQueryStringFromParameters(parameters); break; &#125;&#125; 解决’=’方法1234567891011AFHTTPSessionManager *manager = [self sessionManager];[manager.requestSerializer setQueryStringSerializationWithBlock:^NSString *(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error) &#123; return paramsStr;&#125;];[manager POST:urlStr parameters:paramsStr progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; &#125;]; 总结 不建议修改直接源码达到去掉’=’目的，通常可能因为源码版本更新而遗忘。 如果使用原生网络请求可以直接通过[request setHTTPBody:data]来实现字符串或其他数据传输。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-GCD系列之dispatch_group_t]]></title>
    <url>%2F2017%2F12%2F15%2FiOS-GCD%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BB%BB%E5%8A%A1%E7%BB%84dispatch_group_t%2F</url>
    <content type="text"><![CDATA[这篇主要将对dispatch_group_t进行梳理应用，其主要用于监听管理任务组中任务完成情况，在任务完成后做一些操作处理。 最常见的几个方法123456789101112131415161718// 创建一个任务组dispatch_group_create();// 将任务异步提交到任务组里dispatch_group_async(group, queue, block);// 不使用dispatch_group_async来提交任务// 任务组中任务数+1dispatch_group_enter(group);// 任务组中任务数-1与dispatch_group_enter必须成对出现dispatch_group_leave(group);// 等待之前任务执行完成后才继续执行dispatch_group_wait(group1, DISPATCH_TIME_FOREVER);// 当任务组中任务完成，会出发出发此方法的blockdispatch_group_notify(group1, queue1,block); 实战12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 创建任务组dispatch_group_t group = dispatch_group_create();// 创建串行队列dispatch_queue_t serialQueue = dispatch_queue_create("com.wynter.serial", DISPATCH_QUEUE_SERIAL);// 创建并发队列dispatch_queue_t concurrentQueue = dispatch_queue_create("com.wynter.concurrentQueue", DISPATCH_QUEUE_CONCURRENT);dispatch_group_async(group, concurrentQueue, ^&#123; sleep(3); NSLog(@"并发队列任务1，当前线程：%@", [NSThread currentThread]);&#125;);dispatch_group_async(group, serialQueue, ^&#123; sleep(2); NSLog(@"串行队列任务1，当前线程：%@", [NSThread currentThread]);&#125;);dispatch_group_async(group, serialQueue, ^&#123; sleep(2); NSLog(@"串行队列任务2，当前线程：%@", [NSThread currentThread]);&#125;);// 在任务组中并发执行，等同与dispatch_group_async(group, concurrentQueue, block)dispatch_group_enter(group);dispatch_async(concurrentQueue, ^&#123; sleep(2); NSLog(@"并发队列任务2（enter/leave），当前线程：%@", [NSThread currentThread]); dispatch_group_leave(group);&#125;);// 开始等待阻塞全部线程，直到任务中之前任务执行完成dispatch_group_wait(group, DISPATCH_TIME_FOREVER);NSLog(@"结束任务组中已执行任务的等待，继续向下执行任务"); dispatch_group_async(group, concurrentQueue, ^&#123; sleep(1); NSLog(@"并发队列任务3，当前线程：%@", [NSThread currentThread]);&#125;); // 同一线程中通知任务组中队列中任务已经完成，故顺序打印通知结果dispatch_group_notify(group, concurrentQueue, ^&#123; NSLog(@"并发队列任务执行完毕，当前线程：%@", [NSThread currentThread]);&#125;); dispatch_group_notify(group, serialQueue, ^&#123; NSLog(@"串行队列任务执行完毕，当前线程：%@", [NSThread currentThread]);&#125;); /* 2017-12-15 11:11:46.761678+0800 GCD[32253:17053663] 并发队列任务2（enter/leave），当前线程&lt;NSThread: 0x60400026d0c0&gt;&#123;number = 4, name = (null)&#125; 2017-12-15 11:11:46.761678+0800 GCD[32253:17053661] 串行队列任务1，当前线程：&lt;NSThread: 0x60000026c280&gt;&#123;number = 3, name = (null)&#125; 2017-12-15 11:11:47.761193+0800 GCD[32253:17053660] 并发队列任务1，当前线程：&lt;NSThread: 0x60000026c540&gt;&#123;number = 5, name = (null)&#125; 2017-12-15 11:11:48.762938+0800 GCD[32253:17053661] 串行队列任务2，当前线程：&lt;NSThread: 0x60000026c280&gt;&#123;number = 3, name = (null)&#125; 2017-12-15 11:11:48.762940+0800 GCD[32356:17074006] 结束任务组中已执行任务的等待，继续向下执行任务 2017-12-15 11:11:49.767551+0800 GCD[32253:17053661] 并发队列任务3，当前线程：&lt;NSThread: 0x60000026c280&gt;&#123;number = 3, name = (null)&#125; 2017-12-15 11:11:49.768026+0800 GCD[33057:17230402] 并发队列任务执行完毕，当前线程：&lt;NSThread: 0x60000026c480&gt;&#123;number = 3, name = (null)&#125; 2017-12-15 11:11:49.768248+0800 GCD[33057:17230226] 串行队列任务执行完毕，当前线程：&lt;NSThread: 0x60400027e300&gt;&#123;number = 5, name = (null)&#125; */ 1、创建串行、并发队列各一个2、向任务组的并发队列中添加了 3秒后执行并发队列任务1、2秒后并发队列任务2（enter/leave）、1秒后执行任务33、向任务组的串行队列中添加了 2秒后执行串行队列任务1、2秒后执行串行队列任务24、在并发队列任务2（enter/leave）后添加了任务等待5、通知任务完成 2个并发队列任务开辟两条新线程，并发执行耗时3秒，同时串行队列中的2个任务在同一线程中执行耗时4秒。因为在并发任务后添加任务组等待方法，所以并发队列任务3要等前面4个任务执行完毕才能执行，任务组总共耗时5秒，如果去掉任务等待耗时为4秒。 总结 使用dispatch_sync/dispatch_async来处理同步或异步，其实完没有必要，串行并发队列完全可以满足需求，并且使用dispatch_async会导致任务组提前通知完成； 任务组通知不区分串还是并行队列，任务组中所有任务执行完成才会收到通知。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-GCD系列之dispatch_queue_t]]></title>
    <url>%2F2017%2F12%2F11%2FiOS-GCD%E7%B3%BB%E5%88%97%E4%B9%8Bdispatch_queue_t%2F</url>
    <content type="text"><![CDATA[在一个即时聊天项目中创建一个同步任务来执行数据库操作，在获取数据时忽略了这一点，获取数据时又将同步任务添加到队列中，导致应用启动后事件无响应，甚至导致了死锁，使用应用crash。找了半天发现原来是对GCD的使用不当，引起的死锁。主要还是没有对GCD深入了解，对有些方法也是现学现用，才会引起这样的问题，因此准备用此系列文章记录GCD的学习使用过程。 名词解释GCD：全称是Grand Central Dispatch，中文名字大脑中枢派发，基于C语言的是苹果公司为解决多核并行问题研发，线程及生命周期都有系统自动管理。 任务：执行什么操作队列：用来存放任务，将需要执行的任务添加到队列中，队列会遵循FIFO原则（先进先出、后进后出），将队列中的任务取出，放到对应的线程中执行 同步：不创建新的线程，只在当前线程中执行任务异步：创建多条线程执行任务 串行：同一时间每次只能执行一个任务，当前任务未完成下一个任务只能在队列中等候并发：同一时间可以执行多个任务 死锁：两个或多个任务互相等待形成死循环阻塞了线程，甚至导致应用无响应 关系 串行 并行 主队列 同步 没有开启新线程串行执行任务 没有开启新线程串行执行任务 发生死锁 异步 开启新线程串行执行任务 开启新线程并发执行任务 没有开启新线程串行执行任务 队列创建队列使用dispatch_queue_create，有两个参数，第一个参数是队列的名称，第二个参数是队列类型，通常创建串行队列都传NULL，我们也可以使用dispatch_queue_attr_t定义好的常量创建同步/并发队列 123456/**dispatch_queue_attr_tDISPATCH_QUEUE_SERIAL: 同步队列DISPATCH_QUEUE_CONCURRENT：并发队列*/dispatch_queue_t dispatch_queue_create ( const char *label, dispatch_queue_attr_t attr ); 串行队列 手动创建串行队列，当任务需要按特定的顺序执行时，就需要使用串行调度队列，串行调度队列每次只能执行一个任务 1dispatch_queue_t queue = dispatch_queue_create("com.wynter.customQueue", NULL); 获取串行主队列，应用程序创建时系统自带串行队列，主队列中的任务都会在主线程中执行，一般会用于更新UI 1dispatch_queue_t queue = dispatch_get_main_queue(); 并发队列全局并发队列由系统提供，供整个应用使用，不需要我们手动创建可以同时并行执行多个任务，同样也遵循FIFO原则 123456789/**队列优先级DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台*/dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // dispatch_queue_t queue = dispatch_queue_create("com.wynter.customQueue", DISPATCH_QUEUE_CONCURRENT); 实战同步/异步串行队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 创建串行队列dispatch_queue_t queue = dispatch_queue_create("com.wynter.customQueue", DISPATCH_QUEUE_SERIAL);NSLog(@"Begin");// 异步串行队列dispatch_async(queue, ^&#123; sleep(3); NSLog(@"异步任务1，当前线程：%@", [NSThread currentThread]);&#125;);NSLog(@"队列外1，当前线程：%@", [NSThread currentThread]);dispatch_async(queue, ^&#123; sleep(2); NSLog(@"异步任务2，当前线程：%@", [NSThread currentThread]);&#125;);NSLog(@"队列外2，当前线程：%@", [NSThread currentThread]);// 同步串行队列dispatch_sync(queue, ^&#123; NSLog(@"同步任务1，当前线程：%@", [NSThread currentThread]);&#125;);NSLog(@"队列外3，当前线程：%@", [NSThread currentThread]);// 异步串行队列dispatch_async(queue, ^&#123; sleep(1); NSLog(@"异步任务3，当前线程：%@", [NSThread currentThread]);&#125;);NSLog(@"End");/** 2017-12-11 10:25:44.915490+0800 GCD[24560:5161766] Begin 2017-12-11 10:25:44.915783+0800 GCD[24560:5161766] 队列外1，当前线程：&lt;NSThread: 0x604000067800&gt;&#123;number = 1, name = main&#125; 2017-12-11 10:25:44.915957+0800 GCD[24560:5161766] 队列外2，当前线程：&lt;NSThread: 0x604000067800&gt;&#123;number = 1, name = main&#125; 2017-12-11 10:25:47.920174+0800 GCD[24560:5162003] 异步任务1，当前线程：&lt;NSThread: 0x60000027d6c0&gt;&#123;number = 3, name = (null)&#125; 2017-12-11 10:25:49.920629+0800 GCD[24560:5162003] 异步任务2，当前线程：&lt;NSThread: 0x60000027d6c0&gt;&#123;number = 3, name = (null)&#125; 2017-12-11 10:25:49.920987+0800 GCD[24560:5161766] 同步任务1，当前线程：&lt;NSThread: 0x604000067800&gt;&#123;number = 1, name = main&#125; 2017-12-11 10:25:49.921231+0800 GCD[24560:5161766] 队列外3，当前线程：&lt;NSThread: 0x604000067800&gt;&#123;number = 1, name = main&#125; 2017-12-11 10:25:49.921389+0800 GCD[24560:5161766] End 2017-12-11 10:25:50.926144+0800 GCD[24560:5162003] 异步任务3，当前线程：&lt;NSThread: 0x60000027d6c0&gt;&#123;number = 3, name = (null)&#125; */ 小结： 同步串行队列使用主线程顺序执行任务，如果当前任务没有完成，不会继续执行同步块以外的其它代码 异步串行队列会创建一条新的线程，在当前线程中顺序执行任务，队列外的代码会在主线程中顺序执行，不受队列中任务的干扰 同步/异步并发队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 获取全局并发队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 手动创建并发队列//dispatch_queue_t queue = dispatch_queue_create("com.wynter.customQueue", DISPATCH_QUEUE_CONCURRENT);NSLog(@"Begin");// 异步并发队列dispatch_async(queue, ^&#123; sleep(3); NSLog(@"异步任务1，当前线程：%@", [NSThread currentThread]);&#125;);NSLog(@"队列外1，当前线程：%@", [NSThread currentThread]);dispatch_async(queue, ^&#123; sleep(2); NSLog(@"异步任务2，当前线程：%@", [NSThread currentThread]);&#125;);NSLog(@"队列外2，当前线程：%@", [NSThread currentThread]);// 同步并发队列dispatch_sync(queue, ^&#123; NSLog(@"同步任务1，当前线程：%@", [NSThread currentThread]);&#125;);NSLog(@"队列外3，当前线程：%@", [NSThread currentThread]);// 异步串行队列dispatch_async(queue, ^&#123; sleep(1); NSLog(@"异步任务3，当前线程：%@", [NSThread currentThread]);&#125;);NSLog(@"End");/** 2017-12-11 10:23:58.493818+0800 GCD[24510:5157656] Begin 2017-12-11 10:23:58.494137+0800 GCD[24510:5157656] 队列外1，当前线程：&lt;NSThread: 0x604000263000&gt;&#123;number = 1, name = main&#125; 2017-12-11 10:23:58.494333+0800 GCD[24510:5157656] 队列外2，当前线程：&lt;NSThread: 0x604000263000&gt;&#123;number = 1, name = main&#125; 2017-12-11 10:23:58.494488+0800 GCD[24510:5157656] 同步任务1，当前线程：&lt;NSThread: 0x604000263000&gt;&#123;number = 1, name = main&#125; 2017-12-11 10:23:58.494919+0800 GCD[24510:5157656] 队列外3，当前线程：&lt;NSThread: 0x604000263000&gt;&#123;number = 1, name = main&#125; 2017-12-11 10:23:58.495081+0800 GCD[24510:5157656] End 2017-12-11 10:23:59.498625+0800 GCD[24510:5158018] 异步任务3，当前线程：&lt;NSThread: 0x600000669080&gt;&#123;number = 3, name = (null)&#125; 2017-12-11 10:24:00.495907+0800 GCD[24510:5158020] 异步任务2，当前线程：&lt;NSThread: 0x600000662980&gt;&#123;number = 4, name = (null)&#125; 2017-12-11 10:24:01.499261+0800 GCD[24510:5158016] 异步任务1，当前线程：&lt;NSThread: 0x6000006692c0&gt;&#123;number = 5, name = (null)&#125; */ 小结： 同步并发队列任务不会创新线程，依然在主线程中执行，与同步串行队列效果相同 异步并发队列会依据并发任务量，创建对应的线程数量，实际开发中异步并发任务顺序是不确定的。 扩展合理并发在开发中并不是并发线程越多越好，线程多往往对也会以牺牲性能为代价，并发线程过多，并且不能很好的控制线程也有可能因为一个线程的阻塞或者死锁导致整个应用崩溃。 那么开多少个线程较为合理呢，这个没有确切的答案。最早了解到的是CPU核数*2，现在CPU性能已经提升了N个档位，所以具体要根据业务而定了，非必要情况还是控制在6个线程以内为好。我们可以使用dispatch_semaphore(信号量)来控制并发线程数量，之后会有详细介绍dispatch_semaphore的使用。 设置队列优先级在使用dispatch_queue_create创建队列的时候会发现，并没有设置队列优先级的选项，而全局队列则有高、中、低、后台四个等级可供选择，但是我们可以使用、dispatch_queue_attr_make_with_qos_class或者dispatch_set_target_queue方法来设置队列的优先级，dispatch_queue_create创建队列的优先级跟全局队列的默认优先级一样。 通过dispatch_queue_attr_make_with_qos_class方法设置队列的优先级 123456789/* * QOS和全局并发队列优先级的映射关系 * - DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED * - DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT * - DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY * - DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND*/dispatch_queue_attr_t queue_attr = dispatch_queue_attr_make_with_qos_class (DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY,-1);dispatch_queue_t queue = dispatch_queue_create("com.wynter.customQueue", queue_attr); 通过dispatch_set_target_queue方法设置队列的优先级 12345dispatch_queue_t serialQueue = dispatch_queue_create("com.wynter.customQueue",NULL); dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW,0); // serialQueue队列参照globalQueue队列的优先级（DISPATCH_QUEUE_PRIORITY_LOW）dispatch_set_target_queue(serialQueue, globalQueue); 使用栅栏控制并发队列中个别任务执行dispatch_barrier_async异步栅栏用于等待控制队列中前面的任务执行完毕后自己才执行，而它后面的任务需等待它完成之后才执行。异步栅栏不影响主线程中的任务执行顺序，但队列中的任务必须上面的规则。dispatch_barrier_sync同步栅栏则会阻塞主线程等待当前任务完成后才能按照原队列的规则执行。 12345678910111213dispatch_queue_t queue = dispatch_queue_create("com.wynter.customQueue", DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^&#123; NSLog(@"async_1");&#125;);dispatch_barrier_async(queue, ^&#123; sleep(2); NSLog(@"hi,barrier");&#125;);dispatch_async(queue, ^&#123; NSLog(@"async_2");&#125;); 异步并发迭代任务当我们需要执行循环异步处理任务时，可以考虑使用dispatch_apply来替换掉for循环，来并发地循环迭代任务。需要注意的是dispatch_apply的block内部异步并发，从下面代码打印End可以看出，dispatch_apply是等待其所有的循环运行完毕才往下执行。1234567891011121314151617181920dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);size_t count = 10;dispatch_apply(count, queue, ^(size_t i) &#123; NSLog(@"%zu", i);&#125;);NSLog(@"End");/** 2017-12-11 10:30:07.152514+0800 GCD[25447:5470863] 0 2017-12-11 10:30:07.152514+0800 GCD[25447:5471097] 1 2017-12-11 10:30:07.152527+0800 GCD[25447:5471095] 2 2017-12-11 10:30:07.152558+0800 GCD[25447:5471099] 3 2017-12-11 10:30:07.152731+0800 GCD[25447:5471097] 4 2017-12-11 10:30:07.152731+0800 GCD[25447:5470863] 5 2017-12-11 10:30:07.152849+0800 GCD[25447:5471095] 6 2017-12-11 10:30:07.152988+0800 GCD[25447:5471099] 7 2017-12-11 10:30:07.153095+0800 GCD[25447:5471097] 8 2017-12-11 10:30:07.153108+0800 GCD[25447:5470863] 9 2017-12-11 10:30:07.154095+0800 GCD[25447:5470863] End */ 暂停/恢复队列dispatch_suspend不能保证可以立即停止队列上正在运行的block任务，而是在当前block任务执行完成后，暂停后续队列中的任务执行。 12345dispatch_queue_t queue = dispatch_queue_create("com.wynter.customQueue", NULL);// 暂停指定队列dispatch_suspend(queue);// 恢复指定队列dispatchp_resume(queue); 总结 为避免发生死锁，少用dispatch_sync，建议尽量不要是使用同步串行队列处理任务 不建议创建多个串行队列来执行任务，应该在全局并发队列中完成任务 避免多级嵌套使用GCD]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 修改文件读写权限]]></title>
    <url>%2F2017%2F11%2F17%2FMac%20%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[使用到系统中Framework，已经正确添加了，无论如何都报错，尝试了各种方法，还是报错。 猜想可能是在Xcode中查看系统的Framework时，不小心删除了部分API，但是当时有没又没有发现。 讲道理啊，一般系统API文件右上角都会有个黑色的小锁，这种情况是不可以编辑文件，即使不小心编辑后也会弹出提示框询问。 于是我随便进到一个API头文件中，居然可以编辑。那么可能就找到原因了，重新下载了个Xcode替换当前的，问题解决了。 为了防止这样的事再次发生，在Xcode中随意找个系统Framework，右键Show in Finder，然后将Frameworks目录下文件修改为只读权限：1sudo chmod -R a-w * 再打开文件时，发现右上的小黑锁又回来。如何又后悔了，添加上读写权限即可： 1sudo chmod -R 775 * 扩展具体权限： r(read):表示可读取权限,用数字4表示w(write):表示可写入权限,用数字2表示x(excute):表示可执行权限,用数字1表示 权限范围： u(user):文件所有者g(group):文件所有者所在群组o(other):文件所有者及群组以外的用户a(all):即全部的用户，包含拥有者，所属群组以及其他用户 操作符号： + 添加某个权限。- 取消某个权限。= 赋予给定权限并取消其他所有权限 修改权限的命令格式: chmod [&lt;权限范围&gt;&lt;权限操作&gt;&lt;具体权限&gt;] [文件或目录…] 例子： 12chmod 775 filechmod u=rwx,g=rwx,o=rx file 总结合理的使用文件读写操作权限，可以降低我们在工作中因为误操作引起的问题。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS CGGeometry]]></title>
    <url>%2F2017%2F10%2F11%2FiOS--CGGeometry%2F</url>
    <content type="text"><![CDATA[CGGeometry是用C语言实现的一个封装了许多常用几何方法的文件 结构体1234567891011121314151617181920212223242526#pragma mark - 结构体/* 定义一个点，设置x坐标和y坐标 */structCGPoint &#123; CGFloat x; CGFloat y;&#125;;/* 定义一个尺寸，设置宽度和高度 */struct CGSize &#123; CGFloat width; CGFloat height;&#125;;/* 定义一个二维矢量 */struct CGVector &#123; CGFloat dx; CGFloat dy;&#125;;/* 定义一个矩形*/struct CGRect &#123; CGPoint origin; CGSize size;&#125;; 全局常量12345678910111213141516171819202122232425262728293031#pragma mark - 全局常量/*零点，与CGPointMake(0, 0)等效 */ const CGPoint CGPointZero/*零尺寸，与CGSizeMake(0, 0)等效*/ const CGSize CGSizeZero/*零矩形，与CGRectMake(0, 0, 0, 0)等效*/ const CGRect CGRectZero/*空矩形，这个和零矩形并不相同，当我们返回两个不相交矩形的交集时，会返回空矩形 */ const CGRect CGRectNull/* 无限的矩形 */const CGRect CGRectInfinite#pragma mark - 创建几何/* 根据`(x, y)`创建一个点 */ CGPoint CGPointMake(CGFloat x, CGFloat y);/* 根据 `(width, height)'创建一个尺寸*/CGSize CGSizeMake(CGFloat width, CGFloat height);/* 根据 `(dx, dy)'创建一个矢量 */CGVector CGVectorMake(CGFloat dx, CGFloat dy);/* 根据 `(x, y; width, height)'创建一个矩形*/ CGRect CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height); 获取几何参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#pragma mark - 获取几何参数/* 根据 `rect'参数，获得矩形最左边的x值 */CGFloat CGRectGetMinX(CGRect rect)/* 根据 `rect'参数，获得矩形x轴中心点的值*/CGFloat CGRectGetMidX(CGRect rect)/*根据 `rect'参数， 获取矩形最右端的x值*/CGFloat CGRectGetMaxX(CGRect rect)/*根据 `rect'参数， 获取矩形最顶端的y值*/CGFloat CGRectGetMinY(CGRect rect)/* 根据 `rect'参数，获得矩形y轴中心点的值*/CGFloat CGRectGetMidY(CGRect rect)/*根据 `rect'参数， 获取矩形最底端的y值*/CGFloat CGRectGetMaxY(CGRect rect)/*根据 `rect'参数， 获取矩形宽度*/CGFloat CGRectGetWidth(CGRect rect)/*根据 `rect'参数， 获取矩形高度*/CGFloat CGRectGetHeight(CGRect rect)/*根据一个矩形创建一个标准的矩形*/ CGRect CGRectStandardize(CGRect rect)/* 创建一个内嵌的矩形，中心和rect参数的中心一样，将 rect 的坐标（origin）按照(dx,dy) 进行平移，然后将 rect 的大小（size） 宽度缩小2倍的 dx，高度缩小2倍的 dy. */CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)/* 根据`rect' 参数，返回四个参数都是整数的矩形 */CGRect CGRectIntegral(CGRect rect)/* 返回 `r1' 和 `r2'并集*/CGRect CGRectUnion(CGRect r1, CGRect r2)/* 返回 `r1' 和 `r2'交集，如果没有交集返回CGRectNull */CGRect CGRectIntersection(CGRect r1, CGRect r2)/* 返回一个矩形，偏移量相对于rect，根据进行平移 */CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)/** 将一个 CGRect 切割成两个 CGRect @param rect 原矩形 @param slice 切割的 CGRect 的指针 @param remainder 切割后剩下的 CGRect 的指针 @param amount 切割的大小，是edge开始计算的方向 @param edge CGRectMinXEdge(从x的最小处进行垂直分割)、 CGRectMinYEdge(从y的最小处进行水平分割)、CGRectMaxXEdge(从x最大处进行垂直分割)、 CGRectMaxYEdge(从y最大处进行水平分割) */void CGRectDivide(CGRect rect, CGRect * slice, CGRect * remainder, CGFloat amount, CGRectEdge edge) 判断几何123456789101112131415161718192021222324252627#pragma mark - 判断几何/* 如果 `point1' 和`point2' 相等返回YES, 否则返回NO*/bool CGPointEqualToPoint(CGPoint point1, CGPoint point2)/* 如果`size1' 和 `size2' 相等返回YES, 否则返回NO */bool CGSizeEqualToSize(CGSize size1, CGSize size2)/* 如果`rect1' 和 `rect2' 相等返回YES, 否则返回NO */bool CGRectEqualToRect(CGRect rect1, CGRect rect2)/* 如果`rect'为空返回YES, 否则返回NO */ bool CGRectIsEmpty(CGRect rect);/* 如果 `rect' 为null返回YES, 否则返回NO */bool CGRectIsNull(CGRect rect)/* 如果 `rect' 是无限矩形返回YES, 否则返回NO */bool CGRectIsInfinite(CGRect rect);/* 判断点是否在矩形内*/bool CGRectContainsPoint(CGRect rect, CGPoint point)/* 判断矩形1是否包含矩形2*/bool CGRectContainsRect(CGRect rect1, CGRect rect2)/* 判断矩形1和矩形2是否相交*/bool CGRectIntersectsRect(CGRect rect1, CGRect rect2) CGRectInset 与 CGRectOffset的区别概念：CGRectInset：对矩形进行平移和缩放两个操作 CGRectOffset：只对矩形进行平移，不会改变其大小 计算过程(伪代码)123456789CGRectInset：CGRect rect = CGRectMake(x, y, width, height);CGRect rectInset = CGRectInset(rect, dx, dy);rectInset = CGRectMake(dx, dy, (width - ( dx * 2)), (height - ( dy * 2)) );CGRectOffset: CGRect rect = CGRectMake(x, y, width, height);CGRect rectOffset = CGRectOffset(rect, dx, dy);rectOffset = CGRectMake((x + dx), (y + dy), width, height ); 示例CGRectInset：1234567CGRect rect = CGRectMake(0, 0, 30, 30);CGRect rectInset = CGRectInset(rect, 10, 10);CGRect bigRectInset = CGRectInset(rect, -10, -10);NSLog(@"rectInset:%@ \n bigRectInset:%@", NSStringFromCGRect(rectInset), NSStringFromCGRect(bigRectInset));// rectInset:&#123;&#123;10, 10&#125;, &#123;10, 10&#125;&#125;// bigRectInset:&#123;&#123;-10, -10&#125;, &#123;50, 50&#125;&#125; CGRectOffset: 1234567CGRect rect = CGRectMake(10, 10, 30, 30);CGRect rectOffset = CGRectOffset(rect, 10, 10);CGRect leftRectOffset = CGRectOffset(rect, -10, -10);NSLog(@"rectOffset:%@ \n leftRectOffset:%@", NSStringFromCGRect(rectOffset), NSStringFromCGRect(leftRectOffset));// rectOffset:&#123;&#123;20, 20&#125;, &#123;30, 30&#125;&#125;// leftRectOffset:&#123;&#123;0, 0&#125;, &#123;30, 30&#125;&#125; CGRectDivide用来分割矩形，参数rect是源矩形，slice和remainder是分割后的两部分矩形，amount是分割线，edge是分割选项。 edge分割方式12345678910typedef CF_ENUM(uint32_t, CGRectEdge) &#123; //从x的最小处进行垂直分割 CGRectMinXEdge, //从y的最小处进行水平分割 CGRectMinYEdge, //从x最大处进行垂直分割 CGRectMaxXEdge, //从y最大处进行水平分割 CGRectMaxYEdge&#125;; 计算过程(伪代码)12345678910111213141516171819202122232425CGRect rect = CGRectMake(x, y, width, height);CGRectDivide(rect, &amp;slice, &amp;remainder, amount, edge);switch (edge) &#123; case CGRectMinXEdge: &#123; *slice = CGRectMake(x, y, amount, height); *remainder = CGRectMake(x + amount, y, width - amount, height); &#125; break; case CGRectMaxXEdge: &#123; *slice = CGRectMake(width - amount, y, amount, height); *remainder = CGRectMake(x, y, width - amount, height); &#125; break; case CGRectMinYEdge: &#123; *slice = CGRectMake(x, y, width, amount); *remainder = CGRectMake(x, y + amount, width, height - amount); &#125; break; case CGRectMaxYEdge: &#123; *slice = CGRectMake(width, y - amount, width, amount); *remainder = CGRectMake(x, y, width, height - amount); &#125; break;&#125; 示例123456789101112131415161718192021CGRect slice;CGRect remainder;CGRect rect = CGRectMake(0, 0, 200, 200);CGRectDivide(rect, &amp;slice, &amp;remainder, 50, CGRectMinXEdge);NSLog(@"slice:%@ \n remainder:%@", NSStringFromCGRect(slice), NSStringFromCGRect(remainder));// CGRectMinXEdge// slice:&#123;&#123;0, 0&#125;, &#123;50, 200&#125;&#125;// remainder:&#123;&#123;50, 0&#125;, &#123;150, 200&#125;&#125;// CGRectMaxXEdge// slice:&#123;&#123;150, 0&#125;, &#123;50, 200&#125;&#125;// remainder:&#123;&#123;0, 0&#125;, &#123;150, 200&#125;&#125;// CGRectMinYEdge// slice:&#123;&#123;0, 0&#125;, &#123;200, 50&#125;&#125;// remainder:&#123;&#123;0, 50&#125;, &#123;200, 150&#125;&#125;// CGRectMaxYEdge// slice:&#123;&#123;0, 150&#125;, &#123;200, 50&#125;&#125;// remainder:&#123;&#123;0, 0&#125;, &#123;200, 150&#125;&#125; 总结在没有对CGGeometry进行深入的了解时，只会用到平时常用的几个方法，可是深入了解后还是会发现有很多实用而自己却一直不知道的方法。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 拉伸图片]]></title>
    <url>%2F2017%2F09%2F20%2FiOS%20%E6%8B%89%E4%BC%B8%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[在开发过程中总会遇到背景图片和控件大小一致的困扰，通常就是两种方法：1、找美工切大小合适的图片2、通过使用代码处理或可视化设置图片拉伸 如何使用SlicingSlicing功能要在.xcassets结尾的图片资源管理器中才可以使用 1、通过以下Show Slicing按钮和右边栏Slicing属性打开效果相同，点击后可以看到有三种图片拉伸方式：水平、垂直、水平垂直方向； Slicing 中有个Center属性用来指定图片的拉伸方式(Stretches、Tile)和可拉伸矩形范围 2、根据需要选择图片拉伸方式，这里选择十字图标或右侧选择 Horizontal And Vertical来演示效果，如下图蓝色区域为可拉伸区域 CGSizeMake(5, 5)，绿色区域为不可拉伸区域 UIEdgeInsetsMake(8, 8, 8, 8)，可以通过过拖拉虚线来改变它们的作用区域或右侧属性来修改 水平拉伸方式更直观： 3、拉伸前图片大小52*52，通过设置后的效果 在可视化编程中设置UIImageView的Stretching为(0.5, 0.5, 0, 0)来处理拉伸 通过使用UIImage方法处理图片拉伸12- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets;- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode; 参数capInsets：用来设置图片的顶、左、底、右的端盖高度resizingMode：指定图片的拉伸方式 UIImageResizingModeStretch：延伸模式，通过拉伸UIEdgeInsets指定的矩形区域来填充图片图片UIImageResizingModeTile：平铺模式，通过复制显示UIEdgeInsets指定的矩形区域来填充图片 总结Stretching属性设置拉伸只对UIImageView有效，按钮图片拉伸需要使用其他两种方式处理；UIImage中方法处理图片拉伸，适用于代码设置；Slicing功能最为方便有效，推荐使用；]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由UITableView缓存机制引起的崩溃问题]]></title>
    <url>%2F2017%2F09%2F17%2F%E7%94%B1UITableView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%BC%95%E8%B5%B7%E7%9A%84%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近一直没有更新文章，没有别的理由就是自己懒，回头想想这几天忙着撕逼几天下来扣字过万，怎么会没有写一篇总结文章的功夫呢？ 这里说说我在开发中遇到的2个由于缓存机制引起的崩溃问题：一、在二级页面发送通知更新一级页面数据列表并执行返回一级页面时引起崩溃；二、使用UISearchController搜索，全部数据和搜索结果公用一个UITableView，在开始搜索的时候引起崩溃。 问题一：12[[NSNotificationCenter defaultCenter]postNotificationName:FINISHARRIVALEQUIP object:nil];[self.navigationController popViewControllerAnimated:YES]; 起初猜测是发送通知又多个页面刷新，数据导致主线程堵塞引起崩溃呢，运行代码后，直接发现是数组越界引起崩溃，因为在发送通知后，直接请求数据会先清空数据源，网络请求还没有返回数据，此时刚好执行pop返回到当前页面，UITableView会直接从缓存中拿去数据，但是数据源为空。 解决方法：1、在返回会网络请求返回数据的时候再清空数据源重新赋值2、清空数据源后，先执行 [self.tableView reloadData]刷新列表，再执行网络请求 问题二1234567891011- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; DataSourceItem *item; if (!_searchController.active) &#123; item = _dataArray[indexPath.row]; &#125; else &#123; item = _searchArray[indexPath.row]; &#125; static NSString *cellIdentifier = @"cell"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier]; return cell; &#125; 点击搜索的时候数据源切换为_searchArray，但是tableView依然按照_dataArray缓存拿去数据，从而导致崩溃。 解决方法：123- (void)updateSearchResultsForSearchController:(UISearchController *)searchController &#123; [self.tableView reloadData];&#125; 数组越界问题上面两种问题最终都是由于数组越界引起的崩溃，可以使用一下方法判断是否越界：123if (indexPath.row &lt; _dataArray.count) &#123; item = [_dataArray objectAtIndex:indexPath.row]; &#125; 不是每次都能记得加数组越界判断，我们可以使用数组的分类，在其中内部判断：12345678910111213141516171819202122232425262728@interface NSArray (Util) /*! @method objectAtIndexCheck: @abstract 检查是否越界和NSNull如果是返回nil @result 返回对象 */- (id)objectAtIndexCheck:(NSUInteger)index; @end #import "NSArray+Util.h" @implementation NSArray (Util) - (id)objectAtIndexCheck:(NSUInteger)index&#123; if (index &gt;= [self count]) &#123; return nil; &#125; id value = [self objectAtIndex:index]; if (value == [NSNull null]) &#123; return nil; &#125; return value;&#125;@end 总结引起的崩溃两种情况都是数据源改变，UITableView并不知道数据源改变，还在缓存中通过IndexPath.row拿取对应数组中数据， 但此时数据源已改变，就可能会因为数组越界Carsh，以上两种情况都可以通过在改变数据源后及时刷新UITableView来解决。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UISaerchBar偏移问题]]></title>
    <url>%2F2017%2F07%2F12%2FUISaerchBar%E5%81%8F%E7%A7%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[相信很多朋友都在使用UISearchController总会遇到一些莫名其妙的问题，当然我也遇到了，下面就记录下使用UISearchController中遇到问题部分问题。 初始代码：123456789101112131415161718192021UITableViewController *searchResultsController = [[UITableViewController alloc]init];searchResultsController.tableView.delegate = self;searchResultsController.tableView.dataSource = self;searchResultsController.tableView.estimatedRowHeight = 80;searchResultsController.tableView.rowHeight = UITableViewAutomaticDimension;self.searchController = [[UISearchController alloc] initWithSearchResultsController:searchResultsController];self.searchController.view.backgroundColor = [[UIColor whiteColor] colorWithAlphaComponent:0.95];self.searchController.searchResultsUpdater = self;UISearchBar *bar = self.searchController.searchBar;bar.barTintColor = [UIColor colorWithRed:239.0/255.0 green:239.0/255.0 blue:244.0/255.0 alpha:1.0];bar.tintColor = [UIColor blackColor];bar.showsBookmarkButton = YES;bar.translucent = YES;UIImageView *view = [[[bar.subviews objectAtIndex:0] subviews] firstObject];view.layer.borderColor = [UIColor colorWithRed:239.0/255.0 green:239.0/255.0 blue:244.0/255.0 alpha:1.0].CGColor;view.layer.borderWidth = 1;self.tableView.tableHeaderView = bar; 问题1：点击搜索框时searchResultsController和searchBar间隔44pt，并且点击跳转无响应，如下图： 解决办法，添加代码：1self.definesPresentationContext = YES; 效果如下： 问题2：在设置导航栏为不透明时，点击搜索时searchBar偏移出屏幕解决办法同上 问题3：在设置导航栏为不透明时，点击搜索框出现如下情况： 解决办法，添加代码：1self.extendedLayoutIncludesOpaqueBars = YES; 效果如下： 属性介绍：12345678// 导航栏是否为半透明self.navigationController.navigationBar.translucent = YES;// 如果在当前控制器中该属性为YES时，则将设置新的视图控制器。如果当前控制器中该属性为NO，则控制器为跟视图控制self.definesPresentationContext = NO;// 是否隐藏navigationBarself.searchController.hidesNavigationBarDuringPresentation = YES;// 延伸视图包是否含不透明的barself.extendedLayoutIncludesOpaqueBars = NO; 引起问题的原因： 出现searchResultsController和searchBar间隔44pt的原因就在于，UISearchController有个hidesNavigationBarDuringPresentation属性，其默认值为YES，就是在点击searchBar时进行搜索时会将导航栏隐藏，并将searchBar移动到navigationBar的位置处，而tableView并不知道searchBar已经移动到navigationBar的位置所以就多出了44pt； 在searchResultsController中点击cell无法跳转是因为searchResultsController并不是主视图，而在设置self.definesPresentationContext = YES后，系统会将searchResultsController设置为新的主视图； 在设置导航栏为不透明时（self.navigationController.navigationBar.translucent = NO），点击搜索时searchBar偏移出屏幕，导航栏不透明时，self.view的原点是从导航栏的底部，那么相对self.view而言navigationBar的x=-64，所以搜searchBar弹出时获取self.navigationController.navigationBar.x = searchBar.x;,此navigationBar已经隐藏，searchBar.x = -64这个时候就会偏移出屏幕。 那么到searchBar向下偏移64pt原理同上。 总结：可能有些地方解释的不到位，欢迎大家指正。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StoryBoard使用之页面传值]]></title>
    <url>%2F2017%2F05%2F21%2FStoryBoard%E4%BD%BF%E7%94%A8%E4%B9%8B%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[最近接手一个半成品的项目，由于前期另一位iOS开发的同事使用的StoryBoard(简称SB)搭建的框架，接手后就继续使用SB开发。之前项目一直使用纯代码和xib来做UI，对于SB用起来还觉得挺麻烦，虽然可视化界使层次结构更加清晰，但是对于一个UI简单和大量页面复用的项目，使用SB反而降低了效率。刚好这个项目就是UI简单和大量页面复用，SB对这个项目来说只是展示结构的作用，由于很多复用界面导致SB看起来像蜘蛛网一样混乱，完全掩盖了SB的设计初衷吧，并且SB上大部分ViewController只是展示作用并没有发挥提高界面绘制的优势，反而在创建页面、跳转页面的时候降低开发效率。既然项目利用到了，下面就说说使用segue跳转界面传值的几种方法。 方法一： 设置一个局部变量保存要传数据12345678910111213- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; [tableView deselectRowAtIndexPath:indexPath animated:YES]; ProjectItem *item = dataAry[indexPath.row]; projectId = item.projectId; [self performSegueWithIdentifier:@&quot;detailSegue&quot; sender:self];&#125;- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; if ([segue.destinationViewController isKindOfClass:[ViewController class]]) &#123; ViewController *controller = segue.destinationViewController; controller.projectId = projectId; &#125;&#125; 方法二： 在prepareForSegue:sender:使用indexPathForSelectedRow获取目标控页面所需参数12345678910111213- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; [self performSegueWithIdentifier:@&quot;detailSegue&quot; sender:self]; [tableView deselectRowAtIndexPath:indexPath animated:YES];&#125;- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; if ([segue.destinationViewController isKindOfClass:[ViewController class]]) &#123; NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow]; ProjectItem *item = dataAry[indexPath.row]; ViewController *controller = segue.destinationViewController; controller.projectId = item.projectId; &#125;&#125; 方法三： 使用performSegueWithIdentifier:sender:方法的sender传递目标页面所需数据推荐使用此方法，其他UI控件事件也同样适用 12345678910111213- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; [self performSegueWithIdentifier:@&quot;detailSegue&quot; sender:indexPath]; [tableView deselectRowAtIndexPath:indexPath animated:YES];&#125;- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; if ([segue.destinationViewController isKindOfClass:[ViewController class]]) &#123; NSIndexPath *indexPath = (NSIndexPath *)sender; ProjectItem *item = dataAry[indexPath.row]; ViewController *controller = segue.destinationViewController; controller.projectId = item.projectId; &#125;&#125; 不推荐使用此方法 123456789101112- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; [tableView deselectRowAtIndexPath:indexPath animated:YES]; ProjectItem *item = dataAry[indexPath.row]; [self performSegueWithIdentifier:@&quot;detailSegue&quot; sender:item.projectId];&#125;- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; if ([segue.destinationViewController isKindOfClass:[ViewController class]]) &#123; ViewController *controller = segue.destinationViewController; controller.projectId = sender; &#125;&#125; 总结 方法一使用起来比较麻烦，需要额外的创建一个成员变量来存值，但是可以应用到任何具有点击事件的方法中； 方法二局限于UITableView，若同时使用deselectRowAtIndexPath:indexPath animated:也将会使使用此方法后indexPathForSelectedRow方法无法获取indexPath； 方法三中sender就是发送器的意思，也就是用于接收存储发送器。id类型是不确定类型，虽然可以用于传各种参数，但是根据sender的意思最好设置为发送器。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UITextView]]></title>
    <url>%2F2017%2F05%2F12%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UITextView%2F</url>
    <content type="text"><![CDATA[UITextView的类实现一个滚动的，多行文本区域的行为。类支持使用自定义字体，颜色，和对齐的文本的显示，同时还支持文本编辑。通常可以使用一个文本视图，显示多行文本。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@protocol UITextViewDelegate &lt;NSObject, UIScrollViewDelegate&gt;@optional// 是否开始编辑- (BOOL)textViewShouldBeginEditing:(UITextView *)textView;// 是否完成编辑- (BOOL)textViewShouldEndEditing:(UITextView *)textView;// 开始编辑- (void)textViewDidBeginEditing:(UITextView *)textView;// 完成编辑- (void)textViewDidEndEditing:(UITextView *)textView;// 文本发生改变，是否替换成指定的文本- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text;// 文本内容发生改变- (void)textViewDidChange:(UITextView *)textView;// 更改选中的文本- (void)textViewDidChangeSelection:(UITextView *)textView;// 是否允许指定的用户使用指定范围的URL进行交互- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange interaction:(UITextItemInteraction)interaction NS_AVAILABLE_IOS(10_0);// 是否允许指定文本附件与文本进行交互- (BOOL)textView:(UITextView *)textView shouldInteractWithTextAttachment:(NSTextAttachment *)textAttachment inRange:(NSRange)characterRange interaction:(UITextItemInteraction)interaction NS_AVAILABLE_IOS(10_0);- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange NS_DEPRECATED_IOS(7_0, 10_0, &quot;Use textView:shouldInteractWithURL:inRange:forInteractionType: instead&quot;);- (BOOL)textView:(UITextView *)textView shouldInteractWithTextAttachment:(NSTextAttachment *)textAttachment inRange:(NSRange)characterRange NS_DEPRECATED_IOS(7_0, 10_0, &quot;Use textView:shouldInteractWithTextAttachment:inRange:forInteractionType: instead&quot;);@endNS_CLASS_AVAILABLE_IOS(2_0) @interface UITextView : UIScrollView &lt;UITextInput, UIContentSizeCategoryAdjusting&gt;// 代理@property(nullable,nonatomic,weak) id&lt;UITextViewDelegate&gt; delegate;// 文本内容@property(null_resettable,nonatomic,copy) NSString *text;// 字体@property(nullable,nonatomic,strong) UIFont *font;// 字体颜色@property(nullable,nonatomic,strong) UIColor *textColor;// 对齐方式@property(nonatomic) NSTextAlignment textAlignment;// 选择的范围@property(nonatomic) NSRange selectedRange;// 是否可编辑@property(nonatomic,getter=isEditable) BOOL editable __TVOS_PROHIBITED;// 是否可选@property(nonatomic,getter=isSelectable) BOOL selectable NS_AVAILABLE_IOS(7_0);// 自动检测文本类型，如电话号码、邮箱、网址等@property(nonatomic) UIDataDetectorTypes dataDetectorTypes NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED;// 是否允许设置文本属性 默认为NO@property(nonatomic) BOOL allowsEditingTextAttributes NS_AVAILABLE_IOS(6_0);// 文本属性@property(null_resettable,copy) NSAttributedString *attributedText NS_AVAILABLE_IOS(6_0);// 属性字典@property(nonatomic,copy) NSDictionary&lt;NSString *, id&gt; *typingAttributes NS_AVAILABLE_IOS(6_0);// 设置指定可见的的滚动范围- (void)scrollRangeToVisible:(NSRange)range;// 自定义输入框@property (nullable, readwrite, strong) UIView *inputView;// 输入框的辅助视图@property (nullable, readwrite, strong) UIView *inputAccessoryView;// 再次编辑是否清楚文本 默认为NO@property(nonatomic) BOOL clearsOnInsertion NS_AVAILABLE_IOS(6_0);// 创建文本视图- (instancetype)initWithFrame:(CGRect)frame textContainer:(nullable NSTextContainer *)textContainer NS_AVAILABLE_IOS(7_0) NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;// 获取文本视图的文本容器@property(nonatomic,readonly) NSTextContainer *textContainer NS_AVAILABLE_IOS(7_0);// 设置文本容器内间距@property(nonatomic, assign) UIEdgeInsets textContainerInset NS_AVAILABLE_IOS(7_0);// 获取布局管理器@property(nonatomic,readonly) NSLayoutManager *layoutManager NS_AVAILABLE_IOS(7_0);// 获取文本存储对象中的文本@property(nonatomic,readonly,strong) NSTextStorage *textStorage NS_AVAILABLE_IOS(7_0);// link的样式属性@property(null_resettable, nonatomic, copy) NSDictionary&lt;NSString *, id&gt; *linkTextAttributes NS_AVAILABLE_IOS(7_0);@end 123456/ 开始编辑时发送通知UIKIT_EXTERN NSNotificationName const UITextViewTextDidBeginEditingNotification;// 文本发生变化发送通知UIKIT_EXTERN NSNotificationName const UITextViewTextDidChangeNotification;// 编辑完成发送通知UIKIT_EXTERN NSNotificationName const UITextViewTextDidEndEditingNotification; e.g.12345678910UITextView *textView = [[UITextView alloc]initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, 100)];textView.font = [UIFont systemFontOfSize:12.f];textView.text = @&quot;iOS-UIKit框架学习—UITextView&quot;;textView.textColor = UIColorFromRGB(0xababab);// UITextView在上下左右分别有一个8px的padding,设置为0后可以正常计算文本高度，否则要宽度-16[textView setContentOffset:CGPointZero];[self.view addSubview:textView];// 用此方法计算高度不需要设置内容边距CGSize sizeToFit = [textView sizeThatFits:CGSizeMake(SCREEN_WIDTH, MAXFLOAT)];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 百度地图SDK-配置开发环境]]></title>
    <url>%2F2017%2F05%2F01%2FiOS-%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BESDK-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[虽然百度地图应经用了很多次了，但是每次都浪费很长时间来配置，所以今天把配置百度地图SDK的过程记录下来，也方便日后查看。 第一步、导入百度SDK百度地图SDK支持手动和使用CocoaPods自动配置 自动配置.framework形式开发包（使用CocoaPods） 1、进入工程所在根目录执行：1pod init // 初始化后，会自动创建`Podfile`文件 2、搜索百度地图SDK在CocoaPods的版本号：1pod search BaiduMapKit 3、编辑Podfile内容如下：1pod 'BaiduMapKit', '3.3.0' // 3.3.0是当前最新的版本号 4.在Podfile所在的文件夹下输入命令：1pod install 成功以后，会出现如下记录： Analyzing dependenciesDownloading dependenciesInstalling BaiduMapKit (3.3.0)Generating Pods projectIntegrating client project[!] Please close any current Xcode sessions and use BaiDuPoiSearch.xcworkspace for this project from now on 手动配置.framework形式开发包1、根据需要导入 .framework包，将所需要的BaiduMapAPI_**.framework拷贝到工程所在文件夹下，BaiduMapAPI_Base.framework为基础包，使用SDK任何功能都需导入，其他分包可按需导入 2、在TARGETS-&gt;Build Phases-&gt;Link Binary With Libaries中点击“+”按钮，在弹出的窗口中点击Add Other按钮，选择BaiduMapAPI_**.framework添加到工程中 注意:静态库中采用Objective-C++实现，因此需要您保证您工程中至少有一个.mm后缀的源文件(您可以将任意一个.m后缀的文件改名为.mm)，或者在工程属性中指定编译方式，即在Xcode的Project -&gt; Edit Active Target-&gt;Build Setting 中找到 Compile Sources As，并将其设置为Objective-C++ 第二步、引入所需的系统依赖库百度地图SDK中提供了定位功能和动画效果，v2.0.0版本开始使用OpenGL渲染因此您需要在您的Xcode工程中引入：CoreLocation.framework、QuartzCore.framework、OpenGLES.framework、SystemConfiguration.framework、CoreGraphics.framework、Security.framework、libsqlite3.0.tbd、CoreTelephony.framework 、libstdc++.6.0.9.tbd 添加方法：在Xcode的Project -&gt; Active Target -&gt;Build Phases -&gt;Link Binary With Libraries，添加这几个系统库即可 第三步、引入所需的第三方openssl库添加支持HTTPS所需的penssl静态库：libssl.a和libcrypto.a（SDK打好的包存放于thirdlib目录下 添加方法： 在 TARGETS-&gt;Build Phases-&gt;Link Binary With Libaries中点击“+”按钮，在弹出的窗口中点击Add Other按钮，选择libssl.a和libcrypto.a添加到工程中 第四步、环境配置在TARGETS-&gt;Build Settings-&gt;Other Linker Flags 中添加-ObjC。 第五步、引入mapapi.bundle资源文件如果使用了基础地图功能，需要添加该资源，否则地图不能正常显示mapapi.bundle中存储了定位、默认大头针标注View及路线关键点的资源图片，还存储了矢量地图绘制必需的资源文件。如果您不需要使用内置的图片显示功能，则可以删除bundle文件中的image文件夹。您也可以根据具体需求任意替换或删除该bundle中image文件夹的图片文件。 添加方法：选中工程名，在右键菜单中选择Add Files to …，从BaiduMapAPI_Map.framework||Resources文件中选择mapapi.bundle文件，并勾选Copy items if needed复选框，单击Add按钮，将资源文件添加到工程中。 第六步、引入头文件在使用SDK的类 按需 引入下边的头文件：12345678#import &lt;BaiduMapAPI_Base/BMKBaseComponent.h&gt;//引入base相关所有的头文件#import &lt;BaiduMapAPI_Map/BMKMapComponent.h&gt;//引入地图功能所有的头文件#import &lt;BaiduMapAPI_Search/BMKSearchComponent.h&gt;//引入检索功能所有的头文件#import &lt;BaiduMapAPI_Cloud/BMKCloudSearchComponent.h&gt;//引入云检索功能所有的头文件#import &lt;BaiduMapAPI_Location/BMKLocationComponent.h&gt;//引入定位功能所有的头文件#import &lt;BaiduMapAPI_Utils/BMKUtilsComponent.h&gt;//引入计算工具所有的头文件#import &lt;BaiduMapAPI_Radar/BMKRadarComponent.h&gt;//引入周边雷达功能所有的头文件#import &lt;BaiduMapAPI_Map/BMKMapView.h&gt;//只引入所需的单个头文件 第七步、调用客户端如果在iOS9中使用了调起百度地图客户端功能，必须在Info.plist中进行如下配置，否则不能调起百度地图客户端。1234&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;&lt;array&gt; &lt;string&gt;baidumap&lt;/string&gt;&lt;/array&gt; 第八步、开启定位提醒自iOS SDK v2.5.0起，为了对iOS8的定位能力做兼容，做了相应的修改，开发者在使用过程中注意事项如下： 需要在info.plist里添加（以下二选一，两个都添加默认使用NSLocationWhenInUseUsageDescription）： NSLocationWhenInUseUsageDescription // 允许在前台使用时获取GPS的描述 NSLocationAlwaysUsageDescription // 允许永久使用GPS的描述 第九步、验证key和应用名称是否相符在使用Xcode6进行SDK开发过程中，需要在info.plist中添加：Bundle display name ，且其值不能为空（Xcode6新建的项目没有此配置，若没有会造成manager start failed） 第十步、APPDelegate配置.h文件123#import &lt;BaiduMapAPI_Base/BMKBaseComponent.h&gt;@interface AppDelegate : UIResponder &lt;UIApplicationDelegate,BMKGeneralDelegate&gt;@property (nonatomic,strong) BMKMapManager* mapManager; .m文件1234567891011121314151617181920212223242526272829303132333435-(void)setUpBaiMap &#123; //百度地图 if ([[UIDevice currentDevice].systemVersion floatValue] &gt;= 8) &#123; //由于IOS8中定位的授权机制改变 需要进行手动授权 CLLocationManager *locationManager = [[CLLocationManager alloc] init]; //获取授权认证 [locationManager requestAlwaysAuthorization]; [locationManager requestWhenInUseAuthorization]; [locationManager startUpdatingLocation]; &#125; _mapManager = [[BMKMapManager alloc]init]; // 如果要关注网络及授权验证事件，请设定 generalDelegate参数 BOOL ret = [_mapManager start:BaiDu_MapKey generalDelegate:self]; if (!ret) &#123; DLog(@"manager start failed!"); &#125;&#125;#pragma mark - 百度地图- (void)onGetNetworkState:(int)iError &#123; if (0 == iError) &#123; NSLog(@"联网成功"); &#125; else&#123; NSLog(@"onGetNetworkState %d",iError); &#125;&#125;- (void)onGetPermissionState:(int)iError &#123; if (0 == iError) &#123; NSLog(@"授权成功"); self.isMapPermission = YES; &#125; else &#123; NSLog(@"onGetPermissionState %d",iError); &#125;&#125; 第十一步、管理地图的生命周期自2.0.0起，BMKMapView新增viewWillAppear、viewWillDisappear方法来控制BMKMapView的生命周期，并且在一个时刻只能有一个`BMKMapView接受回调消息，因此在使用BMKMapView的viewController中需要在viewWillAppear、viewWillDisappear方法中调用BMKMapView的对应的方法，并处理delegate，代码如下：12345678910-(void)viewWillAppear:(BOOL)animated&#123; [_mapView viewWillAppear]; _mapView.delegate = self; // 此处记得不用的时候需要置nil，否则影响内存的释放&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [_mapView viewWillDisappear]; _mapView.delegate = nil; // 不用时，置nil&#125; 总结本文借鉴百度地图SDK-配置开发环境，只是对百度地图的配置进行了一下总结，仅供开发百度地图参考使用，如有侵权行为，请联系我并及时删除。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UISwitch]]></title>
    <url>%2F2017%2F04%2F14%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UISwitch%2F</url>
    <content type="text"><![CDATA[您可以使用UISwitch类来创建和管理ON/ OFF按钮，您会看到，例如在飞行模式等服务的偏好设定（设定）。这些对象被称为开关。 1234567891011121314151617181920212223NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UISwitch : UIControl &lt;NSCoding&gt;// 开关开启时的颜色 On@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 背景边框颜色@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(6_0);// 开关关闭时的颜色 Off@property(nullable, nonatomic, strong) UIColor *thumbTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;// 打开时的状态图片@property(nullable, nonatomic, strong) UIImage *onImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;// 关闭时的状态图片@property(nullable, nonatomic, strong) UIImage *offImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;// 开关@property(nonatomic,getter=isOn) BOOL on;// 初始化- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;// 设置开关并有动画效果- (void)setOn:(BOOL)on animated:(BOOL)animated; @end e.g.123456UISwitch *switch1 = [[UISwitch alloc]initWithFrame:CGRectMake(100, 100, 0, 0)];switch1.onTintColor = [UIColor redColor];switch1.thumbTintColor = [UIColor blueColor];switch1.tintColor = [UIColor yellowColor];[switch1 setOn:YES animated:YES];[self.view addSubview:switch1];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UISlider]]></title>
    <url>%2F2017%2F04%2F14%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UISlider%2F</url>
    <content type="text"><![CDATA[一个UISlider对象是一个可视化的控制，用来选择一个连续值范围从单一的值。滑块始终显示为单杠。拇指，注意到滑块的当前值，并更改设置的用户可以通过移动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UISlider : UIControl &lt;NSCoding&gt;// 当前的值@property(nonatomic) float value;// 滑动器的最小值@property(nonatomic) float minimumValue;// 滑动器的最大值@property(nonatomic) float maximumValue;// 左侧最小值图片 如🔊@property(nullable, nonatomic,strong) UIImage *minimumValueImage;// 右侧最大值图片 如🔊@property(nullable, nonatomic,strong) UIImage *maximumValueImage;// 是否拖动值改变后连续 默认YES@property(nonatomic,getter=isContinuous) BOOL continuous;// 最小的值的填充色@property(nullable, nonatomic,strong) UIColor *minimumTrackTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 最大的值的填充色@property(nullable, nonatomic,strong) UIColor *maximumTrackTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 滑块的填充色@property(nullable, nonatomic,strong) UIColor *thumbTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 设置值并有动画效果- (void)setValue:(float)value animated:(BOOL)animated;// 设置不同状态下滑块图片- (void)setThumbImage:(nullable UIImage *)image forState:(UIControlState)state;// 设置不同状态下最小值图片- (void)setMinimumTrackImage:(nullable UIImage *)image forState:(UIControlState)state;// 设置不同状态下最大值图片- (void)setMaximumTrackImage:(nullable UIImage *)image forState:(UIControlState)state;// 获取不同状态下滑块的图片- (nullable UIImage *)thumbImageForState:(UIControlState)state;// 获取不同状态下最小值的图片- (nullable UIImage *)minimumTrackImageForState:(UIControlState)state;// 获取不同状态下最大值的图片- (nullable UIImage *)maximumTrackImageForState:(UIControlState)state;// 获取当前滑块的图片@property(nullable,nonatomic,readonly) UIImage *currentThumbImage;// 获取当前最小值图片@property(nullable,nonatomic,readonly) UIImage *currentMinimumTrackImage;// 获取当前最大值图片@property(nullable,nonatomic,readonly) UIImage *currentMaximumTrackImage;// 返回最小值图片绘制的矩形- (CGRect)minimumValueImageRectForBounds:(CGRect)bounds;// 返回最大值图片绘制的矩形- (CGRect)maximumValueImageRectForBounds:(CGRect)bounds;// 返回为滑块轨道绘制的矩形- (CGRect)trackRectForBounds:(CGRect)bounds;// 返回为拇指滑块轨道绘制的矩形- (CGRect)thumbRectForBounds:(CGRect)bounds trackRect:(CGRect)rect value:(float)value;@end e.g.12345678UISlider *slider = [[UISlider alloc]initWithFrame:CGRectMake(0, 100, SCREEN_WIDTH, 10)];slider.minimumValue = 0.f;slider.maximumValue = 100.f;slider.thumbTintColor = [UIColor blueColor];slider.minimumTrackTintColor = [UIColor yellowColor];slider.maximumTrackTintColor = [UIColor redColor];[slider setValue:50 animated:YES];[self.view addSubview:slider];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UITextField]]></title>
    <url>%2F2017%2F04%2F14%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UITextField%2F</url>
    <content type="text"><![CDATA[UITextField对象是一个显示可编辑的文字和动作消息发送到目标对象，当用户按下返回按钮控制。通常可以使用这个类从用户收集少量的文字，并执行一些立即采取行动，如搜索操作，根据该文本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101NS_CLASS_AVAILABLE_IOS(2_0) @interface UITextField : UIControl &lt;UITextInput, NSCoding, UIContentSizeCategoryAdjusting&gt;// 文本@property(nullable, nonatomic,copy) NSString *text;// 富文本@property(nullable, nonatomic,copy) NSAttributedString *attributedText NS_AVAILABLE_IOS(6_0);// 字体颜色@property(nullable, nonatomic,strong) UIColor *textColor;// 字体 默认系统12号@property(nullable, nonatomic,strong) UIFont *font;// 对齐方式@property(nonatomic) NSTextAlignment textAlignment;// 文本边缘风格@property(nonatomic) UITextBorderStyle borderStyle;// 默认富文本属性@property(nonatomic,copy) NSDictionary&lt;NSString *, id&gt; *defaultTextAttributes NS_AVAILABLE_IOS(7_0);// 占位符@property(nullable, nonatomic,copy) NSString *placeholder;// 占位符富文本属性@property(nullable, nonatomic,copy) NSAttributedString *attributedPlaceholder NS_AVAILABLE_IOS(6_0);// 在文本开始编辑的时候是否移除旧文本@property(nonatomic) BOOL clearsOnBeginEditing;// 是否根据文本框宽度自动调节字体大小@property(nonatomic) BOOL adjustsFontSizeToFitWidth;// 允许最小的字号@property(nonatomic) CGFloat minimumFontSize;// 代理@property(nullable, nonatomic,weak) id&lt;UITextFieldDelegate&gt; delegate;// 表示启用时文本字段的背景外观的图像@property(nullable, nonatomic,strong) UIImage *background;// 表示禁用时文本字段的背景外观的图像@property(nullable, nonatomic,strong) UIImage *disabledBackground;// 文本是否处于编辑状态@property(nonatomic,readonly,getter=isEditing) BOOL editing;// 是否可以编辑文本中的属性@property(nonatomic) BOOL allowsEditingTextAttributes NS_AVAILABLE_IOS(6_0);// 用户输入的新文本属性@property(nullable, nonatomic,copy) NSDictionary&lt;NSString *, id&gt; *typingAttributes NS_AVAILABLE_IOS(6_0);// 清除按钮类型@property(nonatomic) UITextFieldViewMode clearButtonMode;// 左侧view@property(nullable, nonatomic,strong) UIView *leftView;// 左侧视图的类型@property(nonatomic) UITextFieldViewMode leftViewMode;// 右侧view@property(nullable, nonatomic,strong) UIView *rightView;// 右侧视图的类型@property(nonatomic) UITextFieldViewMode rightViewMode;// 返回接收者的CGRect- (CGRect)borderRectForBounds:(CGRect)bounds;- (CGRect)textRectForBounds:(CGRect)bounds;- (CGRect)placeholderRectForBounds:(CGRect)bounds;- (CGRect)editingRectForBounds:(CGRect)bounds;- (CGRect)clearButtonRectForBounds:(CGRect)bounds;- (CGRect)leftViewRectForBounds:(CGRect)bounds;- (CGRect)rightViewRectForBounds:(CGRect)bounds;// 绘制文本- (void)drawTextInRect:(CGRect)rect;// 绘制占位符文本- (void)drawPlaceholderInRect:(CGRect)rect;// 输入框成为第一响应显示自定义输入视图@property (nullable, readwrite, strong) UIView *inputView;// 输入框成为第一响应显示自定义附件输入视图@property (nullable, readwrite, strong) UIView *inputAccessoryView;// 插入文本之前是否替换前一个文本@property(nonatomic) BOOL clearsOnInsertion NS_AVAILABLE_IOS(6_0);@end@interface UIView (UITextField)// 是否结束编辑- (BOOL)endEditing:(BOOL)force;@end@protocol UITextFieldDelegate &lt;NSObject&gt;@optional// 是否可以在指定文本中编辑- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField;// 开始编辑- (void)textFieldDidBeginEditing:(UITextField *)textField;// 是否可以在指定文本中停止- (BOOL)textFieldShouldEndEditing:(UITextField *)textField;// 结束编辑- (void)textFieldDidEndEditing:(UITextField *)textField;// 替换textFieldDidEndEditing:- (void)textFieldDidEndEditing:(UITextField *)textField reason:(UITextFieldDidEndEditingReason)reason NS_AVAILABLE_IOS(10_0);// 指定文本是否可以发生改变- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;// 是否可以清除指定内容- (BOOL)textFieldShouldClear:(UITextField *)textField;// 按下返回按钮按下是否- (BOOL)textFieldShouldReturn:(UITextField *)textField;@end 1234567891011121314151617181920212223242526272829303132// 边界风格typedef NS_ENUM(NSInteger, UITextBorderStyle) &#123; UITextBorderStyleNone, // 无 UITextBorderStyleLine, // 矩形外观 UITextBorderStyleBezel, // 阴影矩形外观 UITextBorderStyleRoundedRect // 圆角矩形&#125;;// 右侧清空按钮typedef NS_ENUM(NSInteger, UITextFieldViewMode) &#123; UITextFieldViewModeNever, // 从不出现 UITextFieldViewModeWhileEditing, // 编辑时出现 UITextFieldViewModeUnlessEditing, // 除了编辑外出现 UITextFieldViewModeAlways // 一直出现&#125;;// 将要编辑完成的状态typedef NS_ENUM(NSInteger, UITextFieldDidEndEditingReason) &#123; UITextFieldDidEndEditingReasonCommitted, // 提交编辑 UITextFieldDidEndEditingReasonCancelled // 取消编辑&#125; NS_ENUM_AVAILABLE_IOS(10_0);// 开始编辑时发送通知UIKIT_EXTERN NSNotificationName const UITextFieldTextDidBeginEditingNotification;// 编辑结束时发送通知UIKIT_EXTERN NSNotificationName const UITextFieldTextDidEndEditingNotification;// 内容变化时发送通知UIKIT_EXTERN NSNotificationName const UITextFieldTextDidChangeNotification;UIKIT_EXTERN NSString *const UITextFieldDidEndEditingReasonKey NS_AVAILABLE_IOS(10_0); e.g.12345678910111213UITextField *TF = [[UITextField alloc] init];TF.placeholder = @"请输入用户名";TF.backgroundColor = [UIColor clearColor];TF.delegate = self;TF.clearButtonMode = UITextFieldViewModeWhileEditing;TF.secureTextEntry = YES;TF.font = [UIFont systemFontOfSize:15.0];TF.textColor = UIColorFromRGB(0x1a2220);TF.tintColor = UIColorFromRGB(0x25cfa6); // 光标颜色TF.keyboardType = UIKeyboardTypeNumberPad;TF.returnKeyType = UIReturnKeyNext;TF.text = @"18888888888";[self.view addSubview:TF];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UISegmentedControl]]></title>
    <url>%2F2017%2F04%2F14%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UISegmentedControl%2F</url>
    <content type="text"><![CDATA[一个UISegmentedControl对象是横向控制多个段，每个段作为一个独立的按钮运作。分段控制提供一个紧凑的手段，组合到一起的控制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859NS_CLASS_AVAILABLE_IOS(2_0) @interface UISegmentedControl : UIControl &lt;NSCoding&gt;// 初始化方法：传入的数组可以是字符串也可以是UIImage对象的图片数组- (instancetype)initWithItems:(nullable NSArray *)items;// 设置是否保持选中状态@property(nonatomic,getter=isMomentary) BOOL momentary;// 获取标签个数@property(nonatomic,readonly) NSUInteger numberOfSegments;// 设置标签宽度是否随内容自适应 默认是 NO.@property(nonatomic) BOOL apportionsSegmentWidthsByContent NS_AVAILABLE_IOS(5_0);// 插入文字标签在index位置- (void)insertSegmentWithTitle:(nullable NSString *)title atIndex:(NSUInteger)segment animated:(BOOL)animated;// 插入图片标签在index位置- (void)insertSegmentWithImage:(nullable UIImage *)image atIndex:(NSUInteger)segment animated:(BOOL)animated;// 根据索引删除标签- (void)removeSegmentAtIndex:(NSUInteger)segment animated:(BOOL)animated;// 删除所有标签- (void)removeAllSegments;// 重设标签标题- (void)setTitle:(nullable NSString *)title forSegmentAtIndex:(NSUInteger)segment;// 获取标签标题- (nullable NSString *)titleForSegmentAtIndex:(NSUInteger)segment;// 设置标签图片- (void)setImage:(nullable UIImage *)image forSegmentAtIndex:(NSUInteger)segment;// 获取标签图片- (nullable UIImage *)imageForSegmentAtIndex:(NSUInteger)segment;// 根据索引设置相应标签宽度 设置为0则自动获取，默认值0- (void)setWidth:(CGFloat)width forSegmentAtIndex:(NSUInteger)segment;// 根据索引获取标签宽度- (CGFloat)widthForSegmentAtIndex:(NSUInteger)segment;// 设置标签内容的偏移量 默认值0- (void)setContentOffset:(CGSize)offset forSegmentAtIndex:(NSUInteger)segment;// 根据索引获取变标签内容的偏移量- (CGSize)contentOffsetForSegmentAtIndex:(NSUInteger)segment;// 根据所以设置标签是否有效(默认有效)- (void)setEnabled:(BOOL)enabled forSegmentAtIndex:(NSUInteger)segment;// 根据索引获取当前标签是否有效- (BOOL)isEnabledForSegmentAtIndex:(NSUInteger)segment;// 设置和获取当前选中的标签索引@property(nonatomic) NSInteger selectedSegmentIndex;// 设置标签风格颜色@property(null_resettable,nonatomic,strong) UIColor *tintColor;// 置特定状态下segment的背景图案- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 获取背景图案- (nullable UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 设置标签之间分割线的图案- (void)setDividerImage:(nullable UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 获取标签之间分割线的图案- (nullable UIImage *)dividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 通过Attribute字符串属性字典设置标签标题- (void)setTitleTextAttributes:(nullable NSDictionary *)attributes forState:(UIControlState)state NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;- (nullable NSDictionary *)titleTextAttributesForState:(UIControlState)state NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 获取Attribute字符串属性字典- (void)setContentPositionAdjustment:(UIOffset)adjustment forSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 自行设置标签内容的偏移量- (UIOffset)contentPositionAdjustmentForSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;@end 123456789101112enum &#123; UISegmentedControlNoSegment = -1 // 没有选定分段的下标&#125;;// 分段类型typedef NS_ENUM(NSInteger, UISegmentedControlSegment) &#123; UISegmentedControlSegmentAny = 0,// 所有标签都受影响 UISegmentedControlSegmentLeft = 1, // 只有左边部分受到影响 UISegmentedControlSegmentCenter = 2, // 只有中间部分受到影响 UISegmentedControlSegmentRight = 3, // 只有右边部分受到影响 UISegmentedControlSegmentAlone = 4, // 在只有一个标签的时候生效&#125;; e.g.1234567UISegmentedControl *segmentedControl = [[UISegmentedControl alloc]initWithItems:@[@"1",@"2",@"3"]];segmentedControl.frame = CGRectMake(0, 0, 150, 44);segmentedControl.tintColor = [UIColor redColor];segmentedControl.apportionsSegmentWidthsByContent = YES;segmentedControl.selectedSegmentIndex = 2;[segmentedControl addTarget:self action:@selector(clickItem:) forControlEvents:UIControlEventTouchUpInside];self.navigationItem.titleView = segmentedControl;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UIPageControl]]></title>
    <url>%2F2017%2F03%2F08%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIPageControl%2F</url>
    <content type="text"><![CDATA[您可以使用UIPageControl类来创建和管理页面控制。一个页面控制是在控制中心的点继承。每个点对应一个应用程序的文档（或其他实体的数据模型）页面，白色圆点表示当前浏览的网页。 123456789101112131415161718192021NS_CLASS_AVAILABLE_IOS(2_0) @interface UIPageControl : UIControl// 页面总数 默认值0@property(nonatomic) NSInteger numberOfPages;// 当前第几页 默认值0@property(nonatomic) NSInteger currentPage;// 如果只有一页是否隐藏指示器 默认值NO@property(nonatomic) BOOL hidesForSinglePage;// 点击到新的一页不会更新当前的值，直到调用 -updateCurrentPageDisplay ，默认值NO@property(nonatomic) BOOL defersCurrentPageDisplay;// 更新当前控件显示的值- (void)updateCurrentPageDisplay;// 返回显示为点所需的最小大小给出页计数- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount;// 底层指示器颜色@property(nullable, nonatomic,strong) UIColor *pageIndicatorTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;// 当前指示器颜色@property(nullable, nonatomic,strong) UIColor *currentPageIndicatorTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UIDatePicker]]></title>
    <url>%2F2017%2F03%2F08%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIDatePicker%2F</url>
    <content type="text"><![CDATA[UIDatePicker类实现了一个对象，它使用多个旋转的车轮，以允许用户选择日期和时间。iPhone的例子是一个日期选择器，定时器和闹钟设置闹钟的时钟应用程序中的窗格。您也可以使用日期选择器作为一个倒数计时器。 1234567891011121314151617181920212223NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UIDatePicker : UIControl &lt;NSCoding&gt;// DatePicker模式 默认值UIDatePickerModeDateAndTime@property (nonatomic) UIDatePickerMode datePickerMode;// 设置日期选择器的范围 默认值 [NSLocale currentLocale]@property (nullable, nonatomic, strong) NSLocale *locale;// 要使用日期选择器的日历 默认值 [NSCalendar currentCalendar]@property (null_resettable, nonatomic, copy) NSCalendar *calendar;// 使用当前时区或时区从日历@property (nullable, nonatomic, strong) NSTimeZone *timeZone;// 日期选取器所显示的日期@property (nonatomic, strong) NSDate *date;// 日期选择器可以选择的最小日期@property (nullable, nonatomic, strong) NSDate *minimumDate;// 日期选择器可以选择的最大日期@property (nullable, nonatomic, strong) NSDate *maximumDate;// 当属性设置为UIDatePickerModeCountDownTimer模式是时间选择器上的值@property (nonatomic) NSTimeInterval countDownDuration;// 设置时间间隔的选择器，应为显示为分钟。最小1 最大30@property (nonatomic) NSInteger minuteInterval;// 设置带动画时间选择的的值- (void)setDate:(NSDate *)date animated:(BOOL)animated;@end 1234567// DatePicker模式typedef NS_ENUM(NSInteger, UIDatePickerMode) &#123; UIDatePickerModeTime, // 显示设置时分上、下午 (e.g. 6 | 53 | PM) UIDatePickerModeDate, // 显示年月日 (e.g. November | 15 | 2007) UIDatePickerModeDateAndTime, // 显示年月日时上、下午 (e.g. Wed Nov 15 | 6 | 53 | PM) UIDatePickerModeCountDownTimer, // 显示时分 (e.g. 1 | 53)&#125; __TVOS_PROHIBITED;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UIButton]]></title>
    <url>%2F2017%2F03%2F08%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIButton%2F</url>
    <content type="text"><![CDATA[UIButton的类的一个实例，实现了在触摸屏上的按钮。触摸一个按钮拦截事件和动作消息发送到目标对象时。设定的目和行动方法都继承自UIControl。这个类提供了方法来设置标题，图像，按钮等外观属性。通过这些访问，您可以为每个按钮状态指定一个不同的外观。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172NS_CLASS_AVAILABLE_IOS(2_0) @interface UIButton : UIControl &lt;NSCoding&gt;// 设置按钮类型+ (instancetype)buttonWithType:(UIButtonType)buttonType;// 按钮内容与边缘的距离@property(nonatomic) UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR;// 设置标题与边缘或插图的距离@property(nonatomic) UIEdgeInsets titleEdgeInsets;// 当按钮Highlighted状态时是否标题阴影更加突出@property(nonatomic) BOOL reversesTitleShadowWhenHighlighted;// 图片与边缘的距离@property(nonatomic) UIEdgeInsets imageEdgeInsets;// 当按钮Highlighted状态时是否图片突出 默认值YES@property(nonatomic) BOOL adjustsImageWhenHighlighted;// 当按钮Disabled状态时是否改变图片@property(nonatomic) BOOL adjustsImageWhenDisabled;// 点击按钮是否有高亮效果 默认值NO@property(nonatomic) BOOL showsTouchWhenHighlighted __TVOS_PROHIBITED;// 要应用到的按钮标题和图像的色调颜色@property(null_resettable, nonatomic,strong) UIColor *tintColor NS_AVAILABLE_IOS(5_0);// 按钮类型@property(nonatomic,readonly) UIButtonType buttonType;// 设置指定状态下的按钮标题- (void)setTitle:(nullable NSString *)title forState:(UIControlState)state;// 设置指定状态下按钮标题的颜色- (void)setTitleColor:(nullable UIColor *)color forState:(UIControlState)state UI_APPEARANCE_SELECTOR;// 设置指定状态下按钮阴影的颜色- (void)setTitleShadowColor:(nullable UIColor *)color forState:(UIControlState)state UI_APPEARANCE_SELECTOR;// 设置指定状态下按钮的图片- (void)setImage:(nullable UIImage *)image forState:(UIControlState)state;// 设置指定状态下按钮的背景图片- (void)setBackgroundImage:(nullable UIImage *)image forState:(UIControlState)state UI_APPEARANCE_SELECTOR;// 设置指定状态下按钮的属性标题- (void)setAttributedTitle:(nullable NSAttributedString *)title forState:(UIControlState)state NS_AVAILABLE_IOS(6_0);// 获取指定状态下按钮标题- (nullable NSString *)titleForState:(UIControlState)state;// 获取指定状态下按钮标题颜色- (nullable UIColor *)titleColorForState:(UIControlState)state;// 获取指定状态下按钮阴影颜色- (nullable UIColor *)titleShadowColorForState:(UIControlState)state;// 获取指定状态下按钮图片- (nullable UIImage *)imageForState:(UIControlState)state;// 获取指定状态下按钮背景图片- (nullable UIImage *)backgroundImageForState:(UIControlState)state;// 获取指定状态下按钮标题属性- (nullable NSAttributedString *)attributedTitleForState:(UIControlState)state NS_AVAILABLE_IOS(6_0);// 获取当前按钮的标题@property(nullable, nonatomic,readonly,strong) NSString *currentTitle;// 获取当前按钮标题颜色@property(nonatomic,readonly,strong) UIColor *currentTitleColor;// 获取当前按钮阴影边框的颜色@property(nullable, nonatomic,readonly,strong) UIColor *currentTitleShadowColor;// 获取当前按钮的图片@property(nullable, nonatomic,readonly,strong) UIImage *currentImage;// 获取当前按钮背景图片@property(nullable, nonatomic,readonly,strong) UIImage *currentBackgroundImage;// 获取当前按钮标题属性@property(nullable, nonatomic,readonly,strong) NSAttributedString *currentAttributedTitle NS_AVAILABLE_IOS(6_0);// 获取当前按钮标题Label@property(nullable, nonatomic,readonly,strong) UILabel *titleLabel NS_AVAILABLE_IOS(3_0);// 获取当前按钮的imageView@property(nullable, nonatomic,readonly,strong) UIImageView *imageView NS_AVAILABLE_IOS(3_0);// 返回按钮的背景的CGRect- (CGRect)backgroundRectForBounds:(CGRect)bounds;// 返回按钮内容的CGRect- (CGRect)contentRectForBounds:(CGRect)bounds;// 返回按钮标题内容的CGRect- (CGRect)titleRectForContentRect:(CGRect)contentRect;// 返回按钮image的CGRect- (CGRect)imageRectForContentRect:(CGRect)contentRect;@end 12345678910// 按钮风格类型typedef NS_ENUM(NSInteger, UIButtonType) &#123; UIButtonTypeCustom = 0, // 自定义类型无样式 UIButtonTypeSystem NS_ENUM_AVAILABLE_IOS(7_0), // 系统类型 UIButtonTypeDetailDisclosure, // 蓝色小箭头按钮，主要做详细说明用 UIButtonTypeInfoLight, // 亮色感叹号 UIButtonTypeInfoDark, // 暗色感叹号 UIButtonTypeContactAdd, // 十字加号按钮 UIButtonTypeRoundedRect = UIButtonTypeSystem, // 圆角矩形&#125;;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UIControl]]></title>
    <url>%2F2017%2F03%2F08%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIControl%2F</url>
    <content type="text"><![CDATA[UIControl是为控制对象，如用户的意图传达到应用程序的按钮和滑块的基类。你不能直接使用UIControl类实例化控制。相反，它定义了共同的界面和它的所有子类的行为结构。 1234567891011121314151617181920212223242526272829303132333435363738394041424344NS_CLASS_AVAILABLE_IOS(2_0) @interface UIControl : UIView// 触摸事件是否可用 默认值YES@property(nonatomic,getter=isEnabled) BOOL enabled;// 是否选中 默认值NO@property(nonatomic,getter=isSelected) BOOL selected;// 是否高亮 默认值NO@property(nonatomic,getter=isHighlighted) BOOL highlighted;// 内容垂直对齐方式 默认值中心对齐@property(nonatomic) UIControlContentVerticalAlignment contentVerticalAlignment;// 内容水平对齐方式 默认值中心对齐@property(nonatomic) UIControlContentHorizontalAlignment contentHorizontalAlignment;// 状态@property(nonatomic,readonly) UIControlState state;// 是否跟踪当前触摸事件@property(nonatomic,readonly,getter=isTracking) BOOL tracking;// 跟踪是否在当前触摸范围内@property(nonatomic,readonly,getter=isTouchInside) BOOL touchInside;// 开始跟踪触摸事件- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event;// 当触摸事件关联控件时调用更新- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event;// 结束跟踪触摸事件- (void)endTrackingWithTouch:(nullable UITouch *)touch withEvent:(nullable UIEvent *)event;// 取消触摸事件- (void)cancelTrackingWithEvent:(nullable UIEvent *)event;// 将目标控件和操作方法与该控件相关联- (void)addTarget:(nullable id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;// 移除目标控件和操作方法- (void)removeTarget:(nullable id)target action:(nullable SEL)action forControlEvents:(UIControlEvents)controlEvents;// 返回全部与该控件相关的对象@property(nonatomic,readonly) NSSet *allTargets;// 返回与控件相关的操作事件@property(nonatomic,readonly) UIControlEvents allControlEvents;// 返回指定对象发生操作时的字符串名称数组- (nullable NSArray&lt;NSString *&gt; *)actionsForTarget:(nullable id)target forControlEvent:(UIControlEvents)controlEvent;// 调用指定的操作事件- (void)sendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event;// 发送与控件相关的全部事件- (void)sendActionsForControlEvents:(UIControlEvents)controlEvents;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef NS_OPTIONS(NSUInteger, UIControlEvents) &#123; UIControlEventTouchDown = 1 &lt;&lt; 0, // 单点触摸按下事件 UIControlEventTouchDownRepeat = 1 &lt;&lt; 1, // 多点触摸按下事件 (触摸数 &gt; 1) UIControlEventTouchDragInside = 1 &lt;&lt; 2, // 触摸在控件窗口内拖动 UIControlEventTouchDragOutside = 1 &lt;&lt; 3, // 触摸在控件窗口之外拖动 UIControlEventTouchDragEnter = 1 &lt;&lt; 4, // 触摸从控件窗口之外拖动到内部 UIControlEventTouchDragExit = 1 &lt;&lt; 5, // 触摸从控件窗口内部拖动到外部 UIControlEventTouchUpInside = 1 &lt;&lt; 6, // 所有在控件之内触摸抬起事件 UIControlEventTouchUpOutside = 1 &lt;&lt; 7, // 所有在控件之外触摸抬起事件 UIControlEventTouchCancel = 1 &lt;&lt; 8, // 所有触摸取消事件 UIControlEventValueChanged = 1 &lt;&lt; 12, // 当控件的值发生改变时，发送通知 UIControlEventPrimaryActionTriggered NS_ENUM_AVAILABLE_IOS(9_0) = 1 &lt;&lt; 13, // semantic action: for buttons, etc. UIControlEventEditingDidBegin = 1 &lt;&lt; 16, // 当文本控件中开始编辑时发送通知 UIControlEventEditingChanged = 1 &lt;&lt; 17, // 当文本控件中的文本被改变时发送通知 UIControlEventEditingDidEnd = 1 &lt;&lt; 18, // 当文本控件中编辑结束时发送通知 UIControlEventEditingDidEndOnExit = 1 &lt;&lt; 19, // 当文本控件内通过按下回车键（或等价行为）结束编辑时，发送通知 UIControlEventAllTouchEvents = 0x00000FFF, // 通知所有触摸事件 UIControlEventAllEditingEvents = 0x000F0000, // 通知所有关于文本编辑的事件 UIControlEventApplicationReserved = 0x0F000000, // 通知应用内所有可用的事件 UIControlEventSystemReserved = 0xF0000000, // 通知系统内可用的事件 UIControlEventAllEvents = 0xFFFFFFFF // 通知所有事件&#125;;// 内容垂直对齐方式typedef NS_ENUM(NSInteger, UIControlContentVerticalAlignment) &#123; UIControlContentVerticalAlignmentCenter = 0, UIControlContentVerticalAlignmentTop = 1, UIControlContentVerticalAlignmentBottom = 2, UIControlContentVerticalAlignmentFill = 3,&#125;;// 内容水平对齐方式typedef NS_ENUM(NSInteger, UIControlContentHorizontalAlignment) &#123; UIControlContentHorizontalAlignmentCenter = 0, UIControlContentHorizontalAlignmentLeft = 1, UIControlContentHorizontalAlignmentRight = 2, UIControlContentHorizontalAlignmentFill = 3,&#125;;// UIControl状态typedef NS_OPTIONS(NSUInteger, UIControlState) &#123; UIControlStateNormal = 0, UIControlStateHighlighted = 1 &lt;&lt; 0, // 高亮状态 UIControlStateDisabled = 1 &lt;&lt; 1, // 禁用 UIControlStateSelected = 1 &lt;&lt; 2, // 选中 UIControlStateFocused NS_ENUM_AVAILABLE_IOS(9_0) = 1 &lt;&lt; 3, // 长按聚焦 UIControlStateApplication = 0x00FF0000, // 应用状态可用 UIControlStateReserved = 0xFF000000 // 保留&#125;;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UIWebView]]></title>
    <url>%2F2017%2F02%2F28%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIWebView%2F</url>
    <content type="text"><![CDATA[您使用了UIWebView类，在您的应用程序中嵌入网页内容。要做到这一点，你只需创建一个UIWebView对象，将它附加到一个窗口，它发送一个请求加载网页内容。您也可以使用这个类在网页的历史向前和向后移动，你甚至可以设置一些网页内容属性的编程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@class UIWebViewInternal;@protocol UIWebViewDelegate;NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UIWebView : UIView &lt;NSCoding, UIScrollViewDelegate&gt;// 代理@property (nullable, nonatomic, assign) id &lt;UIWebViewDelegate&gt; delegate;// scrollView属性@property (nonatomic, readonly, strong) UIScrollView *scrollView NS_AVAILABLE_IOS(5_0);// 加载URL请求链接- (void)loadRequest:(NSURLRequest *)request;// 加载本地html字符串网页- (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;// 加载本地NSData数据网页- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;// URL请求@property (nullable, nonatomic, readonly, strong) NSURLRequest *request;// 重载- (void)reload;// 停止加载- (void)stopLoading;// 后退到上一个界面- (void)goBack;// 前进到一个之前到过页面- (void)goForward;// 是否可以后退@property (nonatomic, readonly, getter=canGoBack) BOOL canGoBack;// 是否可以前进@property (nonatomic, readonly, getter=canGoForward) BOOL canGoForward;// 是否正在加载@property (nonatomic, readonly, getter=isLoading) BOOL loading;// 加载完成后调动，通过它可以很方便的操作UIWebView中的页面元素。参数script用来传进当前页面文件元素字符串，对传进来的字符串进行相应的操作- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;// 是否将页面内容缩放到当前屏幕适合的尺寸@property (nonatomic) BOOL scalesPageToFit;// 网页内容可识别类型，如邮箱、电话、网址@property (nonatomic) UIDataDetectorTypes dataDetectorTypes NS_AVAILABLE_IOS(3_0);// 是否使用网页内嵌的视频播放。为了内嵌视频播放，不仅仅需要在这个页面上设置这个属性，还需要在HTML的viedeo元素必须包含webkit-playsinline属性 iPhone默认值NO，iPad默认值是YES@property (nonatomic) BOOL allowsInlineMediaPlayback NS_AVAILABLE_IOS(4_0);// 是否自动播放视频还是用户手动播放视频 默认值是YES@property (nonatomic) BOOL mediaPlaybackRequiresUserAction NS_AVAILABLE_IOS(4_0);// 是否支持Air Play播放 默认值是YES@property (nonatomic) BOOL mediaPlaybackAllowsAirPlay NS_AVAILABLE_IOS(5_0);// 是否把网页渲染全部加载到内存中去处理 默认值是NO@property (nonatomic) BOOL suppressesIncrementalRendering NS_AVAILABLE_IOS(6_0);// 是否必须用户操作输入控件才会显示键盘 默认值是YES@property (nonatomic) BOOL keyboardDisplayRequiresUserAction NS_AVAILABLE_IOS(6_0);// 设置页面分页模型@property (nonatomic) UIWebPaginationMode paginationMode NS_AVAILABLE_IOS(7_0);// CSS采用的页面模式@property (nonatomic) UIWebPaginationBreakingMode paginationBreakingMode NS_AVAILABLE_IOS(7_0);// 页面的长度@property (nonatomic) CGFloat pageLength NS_AVAILABLE_IOS(7_0);// 分页之间的差距@property (nonatomic) CGFloat gapBetweenPages NS_AVAILABLE_IOS(7_0);// 页面个数@property (nonatomic, readonly) NSUInteger pageCount NS_AVAILABLE_IOS(7_0);// 是否网页自带的照片浏览器@property (nonatomic) BOOL allowsPictureInPictureMediaPlayback NS_AVAILABLE_IOS(9_0);// 按下连接是否显示连接的预览 默认值为NO@property (nonatomic) BOOL allowsLinkPreview NS_AVAILABLE_IOS(9_0);@end__TVOS_PROHIBITED @protocol UIWebViewDelegate &lt;NSObject&gt;@optional// 当开始加载网页的时候调用，可以拦截一些用户操作行为，返回YES代表允许加载，否则反之- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;// 开始加载网页时调用- (void)webViewDidStartLoad:(UIWebView *)webView;// 加载完成时调用- (void)webViewDidFinishLoad:(UIWebView *)webView;// 加载出错时调用- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error;@end 123456789101112131415161718192021222324// 导航行为类型typedef NS_ENUM(NSInteger, UIWebViewNavigationType) &#123; UIWebViewNavigationTypeLinkClicked, // 点击了链接 UIWebViewNavigationTypeFormSubmitted, // 提交表单 UIWebViewNavigationTypeBackForward, // 前进或返回 UIWebViewNavigationTypeReload, // 重载 UIWebViewNavigationTypeFormResubmitted, // 再次提交 UIWebViewNavigationTypeOther&#125; __TVOS_PROHIBITED;// 翻页效果typedef NS_ENUM(NSInteger, UIWebPaginationMode) &#123; UIWebPaginationModeUnpaginated, // 无 UIWebPaginationModeLeftToRight, // 当内容超出View时，从左到右 UIWebPaginationModeTopToBottom, // 当内容超出View时，从顶部到底部 UIWebPaginationModeBottomToTop, // 当内容超出View时，从底部到顶部 UIWebPaginationModeRightToLeft // 当内容超出View时，从右到左&#125; __TVOS_PROHIBITED;// 有css时页面样式类型typedef NS_ENUM(NSInteger, UIWebPaginationBreakingMode) &#123; UIWebPaginationBreakingModePage, // 页面样式 UIWebPaginationBreakingModeColumn // 圆柱样式&#125; __TVOS_PROHIBITED;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UISearchBar]]></title>
    <url>%2F2017%2F02%2F28%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UISearchBar%2F</url>
    <content type="text"><![CDATA[UISearchBar类实现一个基于文本的搜索的文本字段控制。该控件提供了一个搜索按钮，输入文字的文本字段书签“按钮，一个取消按钮。UISearchBar对象实际上并不执行任何搜索。您可以使用委托，符合UISearchBarDelegate协议的对象，实施行动时，输入文本和按钮被点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@protocol UISearchBarDelegate;NS_CLASS_AVAILABLE_IOS(2_0) @interface UISearchBar : UIView &lt;UIBarPositioning, UITextInputTraits&gt;// 初始化- (instancetype)init __TVOS_PROHIBITED;- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER __TVOS_PROHIBITED;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER __TVOS_PROHIBITED;// 搜索框的风格 默认蓝色@property(nonatomic) UIBarStyle barStyle __TVOS_PROHIBITED;// 代理@property(nullable,nonatomic,weak) id&lt;UISearchBarDelegate&gt; delegate;// 当前搜索的文本@property(nullable,nonatomic,copy) NSString *text;// 搜索栏顶部显示的单行文本@property(nullable,nonatomic,copy) NSString *prompt;// 占位符文本@property(nullable,nonatomic,copy) NSString *placeholder;// 是否展示标签按钮 默认为NO@property(nonatomic) BOOL showsBookmarkButton __TVOS_PROHIBITED;// 是否显示取消按钮 默认为NO@property(nonatomic) BOOL showsCancelButton __TVOS_PROHIBITED;// 是否显示搜索结果的按钮 默认为NO@property(nonatomic) BOOL showsSearchResultsButton NS_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED;// 是否选择搜索结果按钮@property(nonatomic, getter=isSearchResultsButtonSelected) BOOL searchResultsButtonSelected NS_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED;// 用动画设置取消按钮的显示- (void)setShowsCancelButton:(BOOL)showsCancelButton animated:(BOOL)animated NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED;// 用于配置键盘的输入助手@property (nonatomic, readonly, strong) UITextInputAssistantItem *inputAssistantItem NS_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED __WATCHOS_PROHIBITED;// 搜索栏中关键要素的背景底色@property(null_resettable, nonatomic,strong) UIColor *tintColor;// 搜索栏的背景底色@property(nullable, nonatomic,strong) UIColor *barTintColor NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;// 搜索栏的风格@property (nonatomic) UISearchBarStyle searchBarStyle NS_AVAILABLE_IOS(7_0);// 搜索是否半透明@property(nonatomic,assign,getter=isTranslucent) BOOL translucent NS_AVAILABLE_IOS(3_0);// 一个指示范围按钮标题的字符串的数组@property(nullable, nonatomic,copy) NSArray&lt;NSString *&gt; *scopeButtonTitles NS_AVAILABLE_IOS(3_0);// 选中指示按钮的下标@property(nonatomic) NSInteger selectedScopeButtonIndex NS_AVAILABLE_IOS(3_0);// 是否显示范围栏 默认值是NO@property(nonatomic) BOOL showsScopeBar NS_AVAILABLE_IOS(3_0);// 自定义输入框附件视图@property (nullable, nonatomic, readwrite, strong) UIView *inputAccessoryView;// 设置搜索栏的背景图片@property(nullable, nonatomic,strong) UIImage *backgroundImage NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 设置范围栏的背景图片@property(nullable, nonatomic,strong) UIImage *scopeBarBackgroundImage NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 设置提示栏背景图片- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;// 返回提示栏的背景图片- (nullable UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;// 设置指定搜索文本的图片- (void)setSearchFieldBackgroundImage:(nullable UIImage *)backgroundImage forState:(UIControlState)state NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 返回指定搜索文本的图片- (nullable UIImage *)searchFieldBackgroundImageForState:(UIControlState)state NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 设置搜索栏图标类型和控件状态图片- (void)setImage:(nullable UIImage *)iconImage forSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 返回给定搜索栏图标类型和控件状态的图像- (nullable UIImage *)imageForSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 设置指定范围下按钮的背景图片- (void)setScopeBarButtonBackgroundImage:(nullable UIImage *)backgroundImage forState:(UIControlState)state NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 返回指定状态下按钮的背景图片- (nullable UIImage *)scopeBarButtonBackgroundImageForState:(UIControlState)state NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 设置左右分段控制控件的状态及隔离器的图片- (void)setScopeBarButtonDividerImage:(nullable UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 返回左右分段控制控件的隔离器的图片- (nullable UIImage *)scopeBarButtonDividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 为给定状态的“搜索栏”按钮的标题字符串设置文本属性- (void)setScopeBarButtonTitleTextAttributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attributes forState:(UIControlState)state NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 返回给定状态的“搜索栏”按钮的文本属性- (nullable NSDictionary&lt;NSString *, id&gt; *)scopeBarButtonTitleTextAttributesForState:(UIControlState)state NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 搜索栏中搜索文本字段背景的偏移量@property(nonatomic) UIOffset searchFieldBackgroundPositionAdjustment NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 搜索文本字段背景中文本的偏移量@property(nonatomic) UIOffset searchTextPositionAdjustment NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 返回给定图标的位置调整- (void)setPositionAdjustment:(UIOffset)adjustment forSearchBarIcon:(UISearchBarIcon)icon NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;- (UIOffset)positionAdjustmentForSearchBarIcon:(UISearchBarIcon)icon NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;@end@protocol UISearchBarDelegate &lt;UIBarPositioningDelegate&gt;@optional// 是否在指定的搜索栏中编辑- (BOOL)searchBarShouldBeginEditing:(UISearchBar *)searchBar;// 当用户开始编辑搜索文本时调用- (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar;// 是否搜索文本编辑完成- (BOOL)searchBarShouldEndEditing:(UISearchBar *)searchBar;// 当用用户编辑完成时调用- (void)searchBarTextDidEndEditing:(UISearchBar *)searchBar;// 当文本发生变化时调用（包括清除）- (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText;// 文本发生改变前调用- (BOOL)searchBar:(UISearchBar *)searchBar shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text NS_AVAILABLE_IOS(3_0);// 当按下键盘的搜索按钮时调用- (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar;// 当按下书签按钮时调用- (void)searchBarBookmarkButtonClicked:(UISearchBar *)searchBar __TVOS_PROHIBITED;// 当按下取消按钮时调用- (void)searchBarCancelButtonClicked:(UISearchBar *)searchBar __TVOS_PROHIBITED;// 当按下搜索结果按钮时调用- (void)searchBarResultsListButtonClicked:(UISearchBar *)searchBar NS_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED;// 当范围选择按钮改变是调用- (void)searchBar:(UISearchBar *)searchBar selectedScopeButtonIndexDidChange:(NSInteger)selectedScope NS_AVAILABLE_IOS(3_0);@end 1234567891011121314// 搜索框后的图标样式typedef NS_ENUM(NSInteger, UISearchBarIcon) &#123; UISearchBarIconSearch, // 放大镜 UISearchBarIconClear __TVOS_PROHIBITED, // 有一个x的圆 UISearchBarIconBookmark __TVOS_PROHIBITED, // 打开书的图标 UISearchBarIconResultsList __TVOS_PROHIBITED, // 菱形图标列表&#125;;// 搜索框的风格typedef NS_ENUM(NSUInteger, UISearchBarStyle) &#123; UISearchBarStyleDefault, // currently UISearchBarStyleProminent UISearchBarStyleProminent, // 用于邮件、消息和联系人 UISearchBarStyleMinimal // 用于日历、笔记和音乐&#125; NS_ENUM_AVAILABLE_IOS(7_0);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UITableView]]></title>
    <url>%2F2017%2F02%2F16%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UITableView%2F</url>
    <content type="text"><![CDATA[UITableView在iOS开发中是使用最广泛的一个控件，用于展示单个项目数据的列表，同时也可以进行选择和编辑操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328@class UITableView;NS_CLASS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED @interface UITableViewRowAction : NSObject &lt;NSCopying&gt;// 创建左划时显示的按钮+ (instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style title:(nullable NSString *)title handler:(void (^)(UITableViewRowAction *action, NSIndexPath *indexPath))handler;// 滑动时cell的风格@property (nonatomic, readonly) UITableViewRowActionStyle style;// 标题@property (nonatomic, copy, nullable) NSString *title;// 背景颜色@property (nonatomic, copy, nullable) UIColor *backgroundColor;// 毛玻璃效果@property (nonatomic, copy, nullable) UIVisualEffect* backgroundEffect;@end// UITableViewFocusUpdateContext ： 焦点更新的上下文NS_CLASS_AVAILABLE_IOS(9_0) @interface UITableViewFocusUpdateContext : UIFocusUpdateContext@property (nonatomic, strong, readonly, nullable) NSIndexPath *previouslyFocusedIndexPath;@property (nonatomic, strong, readonly, nullable) NSIndexPath *nextFocusedIndexPath;@end//_______________________________________________________________________________________________________________// this represents the display and behaviour of the cells.@protocol UITableViewDelegate&lt;NSObject, UIScrollViewDelegate&gt;@optional// 即将显示tableviewcell时调用- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;// 即将显示header时调用，在cell之后调用- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0);// 即将显示footer时调用，在header之后调用- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0);// 在删除cell之后调用，停止显示cell的时候调用,界面不显示cell时。- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath NS_AVAILABLE_IOS(6_0);// 停止显示header的时候调用- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0);// 停止显示footer的时候调用- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0);// 设置某行cell高度- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;// 设置header高度- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section;// 设置footer高度- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section;// 设置每行cell的估算高度- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(7_0);// 对可变的header 高度的估算- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section NS_AVAILABLE_IOS(7_0);// 对可变的footer 高度的估算- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section NS_AVAILABLE_IOS(7_0);// 设置第section分组的headers自定义视图- (nullable UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;// 设置第section分组的footer自定义视图- (nullable UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section;// 可手动调用,在其他的触发事件中 传入tableview 以及indexPath参数，进行操作- (void)tableView:(UITableView *)tableView accessoryButtonTappedForRowWithIndexPath:(NSIndexPath *)indexPath;// Selection// 设置是否允许cell高亮状态- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);// 按下cell未弹起时调用，即即将高亮时调用,如果return no 则点击的时候没有反应，但是还是会执行此方法- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);// 按下cell弹起时调用- (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);// 将要选定指定的cell时调用- (nullable NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath;// 将要取消选定的cell时调用- (nullable NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(3_0);// 选择指定的cell时调用- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;// 取消选择指定cell时调用- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(3_0);// 编辑// 返回每一行cell的编辑模式， 可以再次设置add或者删除操作- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;// cell左滑删除时，删除按钮的标题- (nullable NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED;// 自定义编辑左滑后出现的界面- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;// 编辑模式下是否缩进指定行背景- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath *)indexPath;// 进入编辑模式时调用- (void)tableView:(UITableView *)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath __TVOS_PROHIBITED;// 编辑结束时调用- (void)tableView:(UITableView *)tableView didEndEditingRowAtIndexPath:(nullable NSIndexPath *)indexPath __TVOS_PROHIBITED;// 移动// 在编辑状态下，返回可以进行移动重新排序的indexpath- (NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath;// 缩进// 设置cell的缩进- (NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath;// 复制/粘贴// 是否在指定行显示菜单，返回值为YES时，长按显示菜单- (BOOL)tableView:(UITableView *)tableView shouldShowMenuForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(5_0);// 弹出菜单后回调用此方法。- (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender NS_AVAILABLE_IOS(5_0);// 选择菜单完成后，调用此方法。- (void)tableView:(UITableView *)tableView performAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(nullable id)sender NS_AVAILABLE_IOS(5_0);// cell是否可以获得焦点- (BOOL)tableView:(UITableView *)tableView canFocusRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(9_0);// 是否更新聚焦范围内发生的内容- (BOOL)tableView:(UITableView *)tableView shouldUpdateFocusInContext:(UITableViewFocusUpdateContext *)context NS_AVAILABLE_IOS(9_0);// 聚焦范围内容更新完成后调用- (void)tableView:(UITableView *)tableView didUpdateFocusInContext:(UITableViewFocusUpdateContext *)context withAnimationCoordinator:(UIFocusAnimationCoordinator *)coordinator NS_AVAILABLE_IOS(9_0);// 设置聚焦时首选视图- (nullable NSIndexPath *)indexPathForPreferredFocusedViewInTableView:(UITableView *)tableView NS_AVAILABLE_IOS(9_0);@endNS_CLASS_AVAILABLE_IOS(2_0) @interface UITableView : UIScrollView &lt;NSCoding&gt;// cell的构造方法,自定义cell时,如果要初始化设置cell属性时,可以重写该方法,在方法内部设置- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;// UITableView的类型: plain类型和group分组类型@property (nonatomic, readonly) UITableViewStyle style;// 数据源@property (nonatomic, weak, nullable) id &lt;UITableViewDataSource&gt; dataSource;// 代理@property (nonatomic, weak, nullable) id &lt;UITableViewDelegate&gt; delegate;// 预读取数据@property (nonatomic, weak) id&lt;UITableViewDataSourcePrefetching&gt; prefetchDataSource NS_AVAILABLE_IOS(10_0);// 行高@property (nonatomic) CGFloat rowHeight;// 分组Header的高度@property (nonatomic) CGFloat sectionHeaderHeight;// 分组Footer的高度@property (nonatomic) CGFloat sectionFooterHeight; // will return the default// 估计行高@property (nonatomic) CGFloat estimatedRowHeight NS_AVAILABLE_IOS(7_0); //// 分组Header估计高度@property (nonatomic) CGFloat estimatedSectionHeaderHeight NS_AVAILABLE_IOS(7_0);// 分组Footer估计高度@property (nonatomic) CGFloat estimatedSectionFooterHeight NS_AVAILABLE_IOS(7_0);// 分割线内边距@property (nonatomic) UIEdgeInsets separatorInset NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;// 背景view@property (nonatomic, strong, nullable) UIView *backgroundView NS_AVAILABLE_IOS(3_2);// 重新载入tableview所有cell 一般是在数据源有改变的时候- (void)reloadData;// 重新载入，section的索引标题。- (void)reloadSectionIndexTitles NS_AVAILABLE_IOS(3_0);// 获取TableView共有多少组@property (nonatomic, readonly) NSInteger numberOfSections;// 获取第section组共有多少行- (NSInteger)numberOfRowsInSection:(NSInteger)section;// 获取某一组的frame,头部frame,尾部frame,cell的frame- (CGRect)rectForSection:(NSInteger)section;- (CGRect)rectForHeaderInSection:(NSInteger)section;- (CGRect)rectForFooterInSection:(NSInteger)section;- (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath;// 返回指定坐标点的indexPath- (nullable NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point;// 返回指定cell所在的indexPath- (nullable NSIndexPath *)indexPathForCell:(UITableViewCell *)cell;// 返回指定范围内的所有indexPath的数组- (nullable NSArray&lt;NSIndexPath *&gt; *)indexPathsForRowsInRect:(CGRect)rect;// 返回indexPath所指向的cell- (nullable __kindof UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;// 当前可以看到的cell数组@property (nonatomic, readonly) NSArray&lt;__kindof UITableViewCell *&gt; *visibleCells;// 返回tableView中标识的可见的indexPath数组@property (nonatomic, readonly, nullable) NSArray&lt;NSIndexPath *&gt; *indexPathsForVisibleRows;// 设置tableView的headerView- (nullable UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section NS_AVAILABLE_IOS(6_0);indexPathsForVisibleRows;// 设置tableView的footerView- (nullable UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section NS_AVAILABLE_IOS(6_0);// 根据传入的indexPath，滚动到相对应的位置，第二个参数是控制对应的cell再滚动后处于tableview的顶部/底部/中部等- (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;// 滚动到被选中项。滚动后处于tableview的顶部/底部/中部等- (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;// 开始一系列的增删改移操作- (void)beginUpdates;// 操作结束更新数据- (void)endUpdates;// 对section进行插入,删除,刷新,移动操作- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection NS_AVAILABLE_IOS(5_0);// 对行进行插入,删除,刷新,移动批量操作- (void)insertRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;- (void)deleteRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;- (void)reloadRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath NS_AVAILABLE_IOS(5_0);// 编辑状态 默认为NO@property (nonatomic, getter=isEditing) BOOL editing;// 设置编辑状态动画显示- (void)setEditing:(BOOL)editing animated:(BOOL)animated;// cell 是否可以选择 默认为YES@property (nonatomic) BOOL allowsSelection NS_AVAILABLE_IOS(3_0);// 编辑模式是否可以选择 默认为NO@property (nonatomic) BOOL allowsSelectionDuringEditing;// 是否可以多选 默认为NO@property (nonatomic) BOOL allowsMultipleSelection NS_AVAILABLE_IOS(5_0);// 编辑模式是否可以多选 默认为NO@property (nonatomic) BOOL allowsMultipleSelectionDuringEditing NS_AVAILABLE_IOS(5_0);// 获取选中行的indexPath@property (nonatomic, readonly, nullable) NSIndexPath *indexPathForSelectedRow;// 返回一个多行选中的indexpath数组@property (nonatomic, readonly, nullable) NSArray&lt;NSIndexPath *&gt; *indexPathsForSelectedRows NS_AVAILABLE_IOS(5_0);// 调用此方法，此indexpath的cell被选中，若此cell不再可视范围内，自动按照最后一个参数的方式进行滚动- (void)selectRowAtIndexPath:(nullable NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition;// 取消此indexpath的选中状态- (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;// 索引条设置@property (nonatomic) NSInteger sectionIndexMinimumDisplayRowCount;// 索引条字体颜色@property (nonatomic, strong, nullable) UIColor *sectionIndexColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;// 索引条背景颜色@property (nonatomic, strong, nullable) UIColor *sectionIndexBackgroundColor NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;// 按住时,索引条显示的背景颜色@property (nonatomic, strong, nullable) UIColor *sectionIndexTrackingBackgroundColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;// 分割线的样式@property (nonatomic) UITableViewCellSeparatorStyle separatorStyle __TVOS_PROHIBITED;// 分割线的颜色@property (nonatomic, strong, nullable) UIColor *separatorColor UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED;// 分割线的玻璃效果@property (nonatomic, copy, nullable) UIVisualEffect *separatorEffect NS_AVAILABLE_IOS(8_0) UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED;// 判断是否需要根据内容留有空白@property (nonatomic) BOOL cellLayoutMarginsFollowReadableWidth NS_AVAILABLE_IOS(9_0);// tableView的头部视图，不要和section header混淆@property (nonatomic, strong, nullable) UIView *tableHeaderView;// tableView的底部视图，不要和section footer混淆@property (nonatomic, strong, nullable) UIView *tableFooterView;// 从缓冲池获取cell- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;// 从缓冲池获取指定下标的cell- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);// 从缓冲池获取header,footer- (nullable __kindof UITableViewHeaderFooterView *)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);// 注册xib创建的cell- (void)registerNib:(nullable UINib *)nib forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(5_0);// 注册cell- (void)registerClass:(nullable Class)cellClass forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);// 注册xib创建的header,footer- (void)registerNib:(nullable UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);// 注册header,footer- (void)registerClass:(nullable Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);// 是否自动将焦点上次集中索引的路径的单元格上 默认值为NO@property (nonatomic) BOOL remembersLastFocusedIndexPath NS_AVAILABLE_IOS(9_0); .@end@protocol UITableViewDataSource&lt;NSObject&gt;@required// 每组有多少行- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;// 返回显示的cell- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;@optional// tablaView上有多少组- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;// 返回某个section对应的header标题- (nullable NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section;// 返回某个section对应的footer标题- (nullable NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;// 设置cell为可编辑模式- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;// 设置cell为可移动模式- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;// 设置右边栏的索引目录数组 e.g. "ABCD...Z#"- (nullable NSArray&lt;NSString *&gt; *)sectionIndexTitlesForTableView:(UITableView *)tableView __TVOS_PROHIBITED;// 点击右侧索引表项时调用 e.g. "B",1- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index __TVOS_PROHIBITED;// 提交编辑- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;// 移动时使用- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;@end@protocol UITableViewDataSourcePrefetching &lt;NSObject&gt;@required// 设置预读取的优先排序数组- (void)tableView:(UITableView *)tableView prefetchRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;@optional// 预读取indexPath数组- (void)tableView:(UITableView *)tableView cancelPrefetchingForRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;@end@interface NSIndexPath (UITableView)// 获取indexPath+ (instancetype)indexPathForRow:(NSInteger)row inSection:(NSInteger)section;// 获取第几组@property (nonatomic, readonly) NSInteger section;// 获取第几行@property (nonatomic, readonly) NSInteger row;@end 12345678910111213141516171819202122232425262728293031323334353637// UITableView风格样式typedef NS_ENUM(NSInteger, UITableViewStyle) &#123; UITableViewStylePlain, // 平铺式(补充：有section时，自动悬浮在顶部) UITableViewStyleGrouped // 分段式&#125;;// 选中某一行滚动到tableView顶、中、下的位置typedef NS_ENUM(NSInteger, UITableViewScrollPosition) &#123; UITableViewScrollPositionNone, UITableViewScrollPositionTop, // 滚动到顶部 UITableViewScrollPositionMiddle, // 滚动到中部 UITableViewScrollPositionBottom // 滚到到底部&#125;;// 删除/添加时，cell过渡动画效果typedef NS_ENUM(NSInteger, UITableViewRowAnimation) &#123; UITableViewRowAnimationFade, // 褪去 UITableViewRowAnimationRight, // 从右边滑入（或滑出） UITableViewRowAnimationLeft, // 从左边滑入（或滑出） UITableViewRowAnimationTop, // 从顶部插入（或删除） UITableViewRowAnimationBottom, // 从底部插入（或删除） UITableViewRowAnimationNone, // 无效果 UITableViewRowAnimationMiddle, // UITableViewRowAnimationAutomatic = 100&#125;;// 在编辑状态下左划cell时,cell右侧显示的按钮类型typedef NS_ENUM(NSInteger, UITableViewRowActionStyle) &#123; UITableViewRowActionStyleDefault = 0, // 红色 UITableViewRowActionStyleDestructive = UITableViewRowActionStyleDefault, UITableViewRowActionStyleNormal&#125; NS_ENUM_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;// 设置索引的标题为搜索.UIKIT_EXTERN NSString *const UITableViewIndexSearch NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED;// 选择发生改变后发送通知的keyUIKIT_EXTERN NSNotificationName const UITableViewSelectionDidChangeNotification;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UIScrollView]]></title>
    <url>%2F2017%2F02%2F10%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIScrollView%2F</url>
    <content type="text"><![CDATA[UIScrollView的类提供支持显示的内容是大于应用程序的窗口大小。它可以使用户内滚动的内容，通过刷卡手势，和捏的手势放大和部分内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@class UIEvent, UIImageView, UIPanGestureRecognizer, UIPinchGestureRecognizer;@protocol UIScrollViewDelegate;NS_CLASS_AVAILABLE_IOS(2_0) @interface UIScrollView : UIView &lt;NSCoding&gt;// 内容视图原点与滚动视图原点的偏移值，默认值为0@property(nonatomic) CGPoint contentOffset;// 内容视图的大小，默认值为0@property(nonatomic) CGSize contentSize;// 内容视图额外的滚动范围，默认值为UIEdgeInsetsZero@property(nonatomic) UIEdgeInsets contentInset;// 代理@property(nullable,nonatomic,weak) id&lt;UIScrollViewDelegate&gt; delegate;// 是否锁定视图垂直或水平方向滚动，默认为NO@property(nonatomic,getter=isDirectionalLockEnabled) BOOL directionalLockEnabled;// 拖动到屏幕的边缘是否弹跳效果，默认值为YES@property(nonatomic) BOOL bounces;// 是否总是允许垂直方向拉伸拖动，默认值为YES@property(nonatomic) BOOL alwaysBounceVertical;// 是否总是允许水平方向拉伸拖动，默认值为YES@property(nonatomic) BOOL alwaysBounceHorizontal;// 是否支持翻页，默认值为NO@property(nonatomic,getter=isPagingEnabled) BOOL pagingEnabled;// 是否开启拖动效果，默认值是YES@property(nonatomic,getter=isScrollEnabled) BOOL scrollEnabled;// 水平方向滚动指示器是否可见，默认值为YES@property(nonatomic) BOOL showsHorizontalScrollIndicator;// 垂直方向滚动指示器是否可见，默认值为YES@property(nonatomic) BOOL showsVerticalScrollIndicator;// 滚动指示器的间距范围，默认值为UIEdgeInsetsZero@property(nonatomic) UIEdgeInsets scrollIndicatorInsets;// 滚动指示器的风格@property(nonatomic) UIScrollViewIndicatorStyle indicatorStyle;// 当手指离开屏幕滚动的减速率// UIScrollViewDecelerationRateNormal and UIScrollViewDecelerationRateFast@property(nonatomic) CGFloat decelerationRate;// 设置内容的偏移量。与contentOffset属性设置有区别，如：关闭动画效果没有抖动- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;// 设置在指定滚动区域可见- (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated;// 短暂的显示滚动指示器- (void)flashScrollIndicators;// 获取用户是否触摸了滚动视图@property(nonatomic,readonly,getter=isTracking) BOOL tracking;// 获取用户是否应经滚动视图@property(nonatomic,readonly,getter=isDragging) BOOL dragging;// 获取用户手指离开视图后是否在滚动@property(nonatomic,readonly,getter=isDecelerating) BOOL decelerating;// 是否延迟处理触摸手势，默认值为YES@property(nonatomic) BOOL delaysContentTouches;// 是否总是监听滚动视图中触摸事件，默认值为YES@property(nonatomic) BOOL canCancelContentTouches;// 由子类重写自定义默认的行为，当手指触摸到显示的内容。默认值为YES- (BOOL)touchesShouldBegin:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event inContentView:(UIView *)view;// 返回是否取消涉及相关内容的子视图并开始拖放- (BOOL)touchesShouldCancelInContentView:(UIView *)view;// 滚动视图内容可拖放的最大比例，默认值为1@property(nonatomic) CGFloat minimumZoomScale;// 滚动视图内容可拖放的最小比例，默认值为1@property(nonatomic) CGFloat maximumZoomScale;// 指定当前公洞视图的拖放比例，默认值为1@property(nonatomic) CGFloat zoomScale NS_AVAILABLE_IOS(3_0);// 新的值应该在是minimumZoomScale和maximumZoomScale之间- (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated NS_AVAILABLE_IOS(3_0);// 设定特定区域内的视图可见- (void)zoomToRect:(CGRect)rect animated:(BOOL)animated NS_AVAILABLE_IOS(3_0);// 确定视图动画的缩放大小是否超过最大或最小缩放限制，默认值为YES@property(nonatomic) BOOL bouncesZoom;// 是否在使用缩放手势@property(nonatomic,readonly,getter=isZooming) BOOL zooming;// 是否正在缩放回最大或最小值@property(nonatomic,readonly,getter=isZoomBouncing) BOOL zoomBouncing;// 是否启用滚动到顶部的手势，默认值为YES@property(nonatomic) BOOL scrollsToTop __TVOS_PROHIBITED;// 点击手势@property(nonatomic, readonly) UIPanGestureRecognizer *panGestureRecognizer NS_AVAILABLE_IOS(5_0);// 捏合手势@property(nullable, nonatomic, readonly) UIPinchGestureRecognizer *pinchGestureRecognizer NS_AVAILABLE_IOS(5_0);// 按压手势@property(nonatomic, readonly) UIGestureRecognizer *directionalPressGestureRecognizer UIKIT_AVAILABLE_TVOS_ONLY(9_0);// 键盘显示方式@property(nonatomic) UIScrollViewKeyboardDismissMode keyboardDismissMode NS_AVAILABLE_IOS(7_0); // default is UIScrollViewKeyboardDismissModeNone// 属性控制器@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl NS_AVAILABLE_IOS(10_0) __TVOS_PROHIBITED;@end 123456789101112131415161718192021222324252627282930313233@protocol UIScrollViewDelegate&lt;NSObject&gt;@optional// 当用户滚动内容视图事调用- (void)scrollViewDidScroll:(UIScrollView *)scrollView;// 滚动视图的缩放比例发生改变时调用- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2);// 开始拖动视图时调用- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;// 当拖动内容滚动视图将要完成时调用- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset NS_AVAILABLE_IOS(5_0);// 告诉代理拖动内容滚动视图结束- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;// 到拖动结束滚动视图正在减速时调用- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;// 减速效果结束调用- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;// 当滚动视图的滚动动画结束时调用- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView;// 返回按比例缩放视图，当缩放将要发生时调用- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;// 当缩放滚动视图的内容即将展开时调用- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view NS_AVAILABLE_IOS(3_2);// 滚动视图的缩放完成- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view atScale:(CGFloat)scale;// 询问是否将要返回到视图顶部时调用- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView;// 返回到视图顶部时滚动动画完成后调用- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView;@end 12345678910111213// 滚动指示器的风格typedef NS_ENUM(NSInteger, UIScrollViewIndicatorStyle) &#123; UIScrollViewIndicatorStyleDefault, // 默认风格、适用任何背景 UIScrollViewIndicatorStyleBlack, // 黑色， 适用白色背景 UIScrollViewIndicatorStyleWhite // 白色&#125;;// 当开始拖动scroll view时，键盘的消失方式typedef NS_ENUM(NSInteger, UIScrollViewKeyboardDismissMode) &#123; UIScrollViewKeyboardDismissModeNone, // 无 UIScrollViewKeyboardDismissModeOnDrag, // 拖动时，关闭键盘 UIScrollViewKeyboardDismissModeInteractive, // 随着scroll view向下滚动，键盘随着一起消失&#125; NS_ENUM_AVAILABLE_IOS(7_0);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C Runtime]]></title>
    <url>%2F2017%2F02%2F08%2FObjective-C%20Runtime%2F</url>
    <content type="text"><![CDATA[Objective-C Runtime是提供Objective-C语言动态特性的运行时的库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340/* Types */#if !OBJC_TYPES_DEFINED// 类方法typedef struct objc_method *Method;// 实例变量typedef struct objc_ivar *Ivar;// 分类typedef struct objc_category *Category;// 对象声明的属性typedef struct objc_property *objc_property_t;// objc_class结构体struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; // 父类 const char *name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表 struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表#endif &#125; OBJC2_UNAVAILABLE;#endif#ifdef __OBJC__@class Protocol;#elsetypedef struct objc_object Protocol;#endif// 定义方法struct objc_method_description &#123; SEL name; // 方法的名称 char *types; // 方法的参数类型&#125;;// 定义属性typedef struct &#123; const char *name; // 属性名称 const char *value; // 属性值&#125; objc_property_attribute_t;// 返回指定对象的一个副本OBJC_EXPORT id object_copy(id obj, size_t size);// 释放指定对象内存 返回nilOBJC_EXPORT id object_dispose(id obj);// 返回对象的类OBJC_EXPORT Class object_getClass(id obj);// 设置对象的类OBJC_EXPORT Class object_setClass(id obj, Class cls);// 是否是类对象OBJC_EXPORT BOOL object_isClass(id obj);// 返回给定对象的类名OBJC_EXPORT const char *object_getClassName(id obj);// 返回指向给定对象分配的任何额外字节的指针OBJC_EXPORT void *object_getIndexedIvars(id obj);// 返回对象中实例变量的值OBJC_EXPORT id object_getIvar(id obj, Ivar ivar);// 设置对象中实例变量的值OBJC_EXPORT void object_setIvar(id obj, Ivar ivar, id value);// 在对象中设置实例变量的值 iOS 10 AVAILABLEOBJC_EXPORT void object_setIvarWithStrongDefault(id obj, Ivar ivar, id value);// 修改类实例的实例变量的值OBJC_EXPORT Ivar object_setInstanceVariable(id obj, const char *name, void *value);// 更改一个实例类中实例变量的值 iOS 10 AVAILABLEOBJC_EXPORT Ivar object_setInstanceVariableWithStrongDefault(id obj, const char *name, void *value);// 返回对象实例变量的值OBJC_EXPORT Ivar object_getInstanceVariable(id obj, const char *name, void **outValue);// 返回指定的类OBJC_EXPORT Class objc_getClass(const char *name);// 返回指定的元类OBJC_EXPORT Class objc_getMetaClass(const char *name);// 返回指定的类OBJC_EXPORT Class objc_lookUpClass(const char *name);// 返回指定的类OBJC_EXPORT Class objc_getRequiredClass(const char *name);// 返回已注册的类定义的列表OBJC_EXPORT int objc_getClassList(Class *buffer, int bufferCount);// 创建并返回一个指向所有已注册类的指针列表OBJC_EXPORT Class *objc_copyClassList(unsigned int *outCount);// 返回类的类名OBJC_EXPORT const char *class_getName(Class cls);// 是否是元类OBJC_EXPORT BOOL class_isMetaClass(Class cls);// 返回类的父类OBJC_EXPORT Class class_getSuperclass(Class cls);// 给类指定一个父类OBJC_EXPORT Class class_setSuperclass(Class cls, Class newSuper);// 返回类版本号OBJC_EXPORT int class_getVersion(Class cls);// 设置类版本号OBJC_EXPORT void class_setVersion(Class cls, int version);// 返回实例类的大小OBJC_EXPORT size_t class_getInstanceSize(Class cls);// 返回类中指定名称实例成员变量的信息OBJC_EXPORT Ivar class_getInstanceVariable(Class cls, const char *name);// 返回类成员变量的信息OBJC_EXPORT Ivar class_getClassVariable(Class cls, const char *name);// 返回整个成员变量列表OBJC_EXPORT Ivar *class_copyIvarList(Class cls, unsigned int *outCount);// 返回实例方法OBJC_EXPORT Method class_getInstanceMethod(Class cls, SEL name);// 返回类方法OBJC_EXPORT Method class_getClassMethod(Class cls, SEL name);// 返回类方法实现的指针OBJC_EXPORT IMP class_getMethodImplementation(Class cls, SEL name);// 返回类方法实现的指针OBJC_EXPORT IMP class_getMethodImplementation_stret(Class cls, SEL name);// 类实例是否响应指定的selectorOBJC_EXPORT BOOL class_respondsToSelector(Class cls, SEL sel);// 返回所有方法的数组OBJC_EXPORT Method *class_copyMethodList(Class cls, unsigned int *outCount);// 返回类是否实现指定的协议OBJC_EXPORT BOOL class_conformsToProtocol(Class cls, Protocol *protocol);// 返回类实现的协议列表OBJC_EXPORT Protocol * __unsafe_unretained*class_copyProtocolList(Class cls, unsigned int *outCount);// 返回指定的属性OBJC_EXPORT objc_property_t class_getProperty(Class cls, const char *name);// 返回属性列表OBJC_EXPORT objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount);// 返回指定变量布局OBJC_EXPORT const uint8_t *class_getIvarLayout(Class cls);// 返回指定弱引用的变量布局OBJC_EXPORT const uint8_t *class_getWeakIvarLayout(Class cls);// 添加方法 如果返回YES则添加成功OBJC_EXPORT BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types);// 替代方法的实现OBJC_EXPORT IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types);// 添加变量OBJC_EXPORT BOOL class_addIvar(Class cls, const char *name, size_t size,uint8_t alignment, const char *types);// 添加协议OBJC_EXPORT BOOL class_addProtocol(Class cls, Protocol *protocol);// 添加属性OBJC_EXPORT BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);// 替换属性OBJC_EXPORT void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);// 设置变量布局OBJC_EXPORT void class_setIvarLayout(Class cls, const uint8_t *layout);// 设置弱属性的变量布局OBJC_EXPORT void class_setWeakIvarLayout(Class cls, const uint8_t *layout);// 通过CoreFoundation's自由连接。不能自己调用此方法OBJC_EXPORT Class objc_getFutureClass(const char *name);// 创建类实例OBJC_EXPORT id class_createInstance(Class cls, size_t extraBytes);// 在指定位置创建类实例OBJC_EXPORT id objc_constructInstance(Class cls, void *bytes);// 销毁类实例OBJC_EXPORT void *objc_destructInstance(id obj);// 创建新的类OBJC_EXPORT Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes);// 注册创建的类OBJC_EXPORT void objc_registerClassPair(Class cls);// 用于KVO观察者模式。 不能自己调用此方法OBJC_EXPORT Class objc_duplicateClass(Class original, const char *name, size_t extraBytes);// 销毁一个类及其相关联的类OBJC_EXPORT void objc_disposeClassPair(Class cls);// 返回方法的名称OBJC_EXPORT SEL method_getName(Method m);// 返回一个方法指针OBJC_EXPORT IMP method_getImplementation(Method m);// 返回描述方法的字符串OBJC_EXPORT const char *method_getTypeEncoding(Method m);// 返回方法接收参数的个数OBJC_EXPORT unsigned int method_getNumberOfArguments(Method m);// 返回描述方法返回类型的字符串OBJC_EXPORT char *method_copyReturnType(Method m);// 返回描述方法单个参数类型的字符串OBJC_EXPORT char *method_copyArgumentType(Method m, unsigned int index);// 返回一个描述方法返回类型OBJC_EXPORT void method_getReturnType(Method m, char *dst, size_t dst_len);// 返回描述方法单个参数类型OBJC_EXPORT void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len);// 返回指定方法的结构描述OBJC_EXPORT struct objc_method_description *method_getDescription(Method m);// 设置方法的指针地址OBJC_EXPORT IMP method_setImplementation(Method m, IMP imp);/** * 交换两个方法指针地址 * @note 交换原理如下: * \code * IMP imp1 = method_getImplementation(m1); * IMP imp2 = method_getImplementation(m2); * method_setImplementation(m1, imp2); * method_setImplementation(m2, imp1); * \endcode */OBJC_EXPORT void method_exchangeImplementations(Method m1, Method m2);// 返回实例变量的名称OBJC_EXPORT const char *ivar_getName(Ivar v);// 返回实例变量类型的字符串OBJC_EXPORT const char *ivar_getTypeEncoding(Ivar v);// 返回实例变量的偏移量OBJC_EXPORT ptrdiff_t ivar_getOffset(Ivar v);// 返回OBJC_EXPORT const char *property_getName(objc_property_t property);// 返回属性的属性字符串OBJC_EXPORT const char *property_getAttributes(objc_property_t property);// 返回属性的属性数组OBJC_EXPORT objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount);// 返回指定属性名称的属性的值OBJC_EXPORT char *property_copyAttributeValue(objc_property_t property, const char *attributeName);// 返回协议的名称OBJC_EXPORT Protocol *objc_getProtocol(const char *name);// 返回runtime已知的所有协议的数组OBJC_EXPORT Protocol * __unsafe_unretained *objc_copyProtocolList(unsigned int *outCount);// 判断一个协议是否遵循了另一个协议OBJC_EXPORT BOOL protocol_conformsToProtocol(Protocol *proto, Protocol *other);// 判断两个协议是否相等OBJC_EXPORT BOOL protocol_isEqual(Protocol *proto, Protocol *other);// 返回协议的名称OBJC_EXPORT const char *protocol_getName(Protocol *p);// 返回执行协议指定方法结构的描述OBJC_EXPORT struct objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod);// 返回满足指定协议方法描述的数组OBJC_EXPORT struct objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount);// 返回指定协议的属性OBJC_EXPORT objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty);/** * 返回声明协议所需要的属性的数组. * @note Identical to * \code * protocol_copyPropertyList2(proto, outCount, YES, YES); * \endcode */OBJC_EXPORT objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount);OBJC_EXPORT objc_property_t *protocol_copyPropertyList2(Protocol *proto, unsigned int *outCount, BOOL isRequiredProperty, BOOL isInstanceProperty)OBJC_AVAILABLE(10.12, 10.0, 10.0, 3.0);// 返回协议所采用的协议的数组OBJC_EXPORT Protocol * __unsafe_unretained *protocol_copyProtocolList(Protocol *proto, unsigned int *outCount);// 创建一个新的协议，添加到objc_registerProtocol方法中OBJC_EXPORT Protocol *objc_allocateProtocol(const char *name);// 注册新协议OBJC_EXPORT void objc_registerProtocol(Protocol *proto);// 添加一个方法到协议中，此协议必须正在建设中OBJC_EXPORT void protocol_addMethodDescription(Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod);// 把已经建设的协议添加到正在建设的协议中去OBJC_EXPORT void protocol_addProtocol(Protocol *proto, Protocol *addition);// 添加一个属性到协议中去，此协议必须正在建设中OBJC_EXPORT void protocol_addProperty(Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty);// 返回所有加载在Objective-C框架和动态库上的名称OBJC_EXPORT const char **objc_copyImageNames(unsigned int *outCount);// 返回一个来自类动态库的名称OBJC_EXPORT const char *class_getImageName(Class cls);// 返回库中所有类的名称OBJC_EXPORT const char **objc_copyClassNamesForImage(const char *image,unsigned int *outCount);// 返回指定sel的方法的名称OBJC_EXPORT const char *sel_getName(SEL sel);// 注册一个Objective-C运行时系统的方法名称OBJC_EXPORT SEL sel_getUid(const char *str);// 注册一个sel方法，并映方法名称到sel中并返回sel值OBJC_EXPORT SEL sel_registerName(const char *str);// 判断两个sel是否相同OBJC_EXPORT BOOL sel_isEqual(SEL lhs, SEL rhs);// 当发现突变的foreach迭代过程中时插入编译器OBJC_EXPORT void objc_enumerationMutation(id obj);// 设置当前突变的处理程序OBJC_EXPORT void objc_setEnumerationMutationHandler(void (*handler)(id));// 设置函数调用objc_msgForwardOBJC_EXPORT void objc_setForwardHandler(void *fwd, void *fwd_stret);// 创建一个当调用此方法时调用指定块的函数指针OBJC_EXPORT IMP imp_implementationWithBlock(id block);// 返回一个使用imp_implementationWithBlock创建的与块相关的函数指针OBJC_EXPORT id imp_getBlock(IMP anImp);// 移除与函数指针相关联的块OBJC_EXPORT BOOL imp_removeBlock(IMP anImp);// 加载弱指针引用的对象并返回它OBJC_EXPORT id objc_loadWeak(id *location);// 存储_weak变量的新值OBJC_EXPORT id objc_storeWeak(id *location, id obj);// 设置关联OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);// 获取关联值OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key);// 移除关联对象OBJC_EXPORT void objc_removeAssociatedObjects(id object);// 发送一个具有简单返回值的消息到一个实例类上OBJC_EXPORT void objc_msgSend(void /* id self, SEL op, ... */ );// 发送一个具有结构返回值的消息到一个实例类上OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ );// 发送一个具有返回数据结构值的消息到一个实例类上OBJC_EXPORT void objc_msgSend_stret(void /* id self, SEL op, ... */ );// 发送一个具有返回数据结构值的消息到一个实例父类上OBJC_EXPORT void objc_msgSendSuper_stret(void /* struct objc_super *super, SEL op, ... */ );// 发送一个具有返回浮点类型值的消息到一个实例类上OBJC_EXPORT void objc_msgSend_fpret(void /* id self, SEL op, ... */ );OBJC_EXPORT void objc_msgSend_fp2ret(void /* id self, SEL op, ... */ );// 调用指定方法的实现OBJC_EXPORT void method_invoke(void /* id receiver, Method m, ... */ );// 调用返回数据结构的指定方法的实现OBJC_EXPORT void method_invoke_stret(void /* id receiver, Method m, ... */ );// 关联策略typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, // 表示弱引用关联，非线程安全,通常是数据类型 OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 表示强（strong）引用关联对象，非线程安全 OBJC_ASSOCIATION_COPY_NONATOMIC = 3, // 表示关联对象copy，非线程安全 OBJC_ASSOCIATION_RETAIN = 01401, // 表示强（strong）引用关联对象，是线程安全的 OBJC_ASSOCIATION_COPY = 01403 // 表示关联对象copy，是线程安全的&#125;;// 编码类型#define _C_ID '@' // 代表对象类型#define _C_CLASS '#' // 代表类对象 (Class)#define _C_SEL ':' // 代表方法selector (SEL)#define _C_CHR 'c' // 代表char类型#define _C_UCHR 'C' // 代表unsigned char类型#define _C_SHT 's' // 代表short类型#define _C_USHT 'S' // 代表unsigned short类型#define _C_INT 'i' // 代表int类型#define _C_UINT 'I' // 代表unsigned int类型#define _C_LNG 'l' // 代表long类型，在64位处理器上也是按照32位处理#define _C_ULNG 'L' // 代表unsigned long类型#define _C_LNG_LNG 'q' // 代表long long类型#define _C_ULNG_LNG 'Q' // 代表unsigned long long类型#define _C_FLT 'f' // 代表float类型#define _C_DBL 'd' // 代表double类型#define _C_BFLD 'b' //#define _C_BOOL 'B' // 代表C++中的bool或者C99中的_Bool#define _C_VOID 'v' // 代表void类型#define _C_UNDEF '?' // 代表未知类型#define _C_PTR '^' // 代表指针类型#define _C_CHARPTR '*' // 代表字符串类型 (char *)#define _C_ATOM '%' //#define _C_ARY_B '[' // 代表array#define _C_ARY_E ']'#define _C_UNION_B '(' // 代表UNION#define _C_UNION_E ')'#define _C_STRUCT_B '&#123;' // 代表结构体#define _C_STRUCT_E '&#125;'#define _C_VECTOR '!' // 代表矢量类型#define _C_CONST 'r' // 代表常量类型 例子1 Runtime123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 获取属性列表&amp;&amp;获取属性名称unsigned int count;objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);for (int i = 0; i &lt; count ; i++) &#123; const char *propertyName = property_getName(propertyList[i]); NSString *str = [NSString stringWithUTF8String:propertyName]; NSLog(@"property_getName==%@",str);&#125;// 获取方法列表&amp;&amp;获取方法名称Method *methodList = class_copyMethodList([self class], &amp;count);for (int i = 0; i &lt; count; i++) &#123; Method method = methodList[i]; //获取方法的参数列表 int arguments = method_getNumberOfArguments(method); NSLog(@"method_getNumberOfArguments===%d",arguments); NSLog(@"method_getName===%@",NSStringFromSelector(method_getName(method)));&#125;// 获取类成员变量列表&amp;&amp;获取成员变量名称Ivar *ivarList = class_copyIvarList([self class], &amp;count);for (int i = 0; i &lt; count; i++) &#123; Ivar ivar = ivarList[i]; NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; NSLog(@"ivar_getName===%@",ivarName);&#125;// 获取类协议列表&amp;&amp;获取协议名称__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);for (unsigned int i = 0; i &lt; count; i++) &#123; Protocol *protocol = protocolList[i]; NSString *protocolStr = [NSString stringWithUTF8String:protocol_getName(protocol)]; NSLog(@"protocol_getName===%@",protocolStr);&#125;// 是不是元类BOOL isMetaClass = class_isMetaClass(self.class);NSLog(@"ViewController is the meta class? %d", isMetaClass);// 是不是类对象ViewController *obj = [ViewController new];BOOL isClass = object_isClass(obj);NSLog(@"ViewController is the class? %d", isClass);// 获取类名称const char *name = class_getName(self.class);NSLog(@"class_getName===%@",[NSString stringWithCString:name encoding:NSUTF8StringEncoding]);// 设置关联&amp;&amp;获取关联static char *key = "key";objc_setAssociatedObject(self, &amp;key, @"hello world", OBJC_ASSOCIATION_COPY_NONATOMIC);NSString *associated = objc_getAssociatedObject(self, &amp;key);NSLog(@"objc_getAssociatedObject===%@",associated);/*----------------------Method Swizzling------------------------*/// 获取实例方法Method originalMethod = class_getInstanceMethod([self class], @selector(original:));Method exchangeMethod = class_getInstanceMethod([self class], @selector(exchange:));// 获取方法指针IMP exchangeImp = method_getImplementation(exchangeMethod);IMP originalImp = method_getImplementation(originalMethod);// 获取描述方法的参数类型const char *originalType = method_getTypeEncoding(originalMethod);const char *exchangeType = method_getTypeEncoding(exchangeMethod);// 添加方法BOOL didAddMethod = class_addMethod([self class], @selector(original:), exchangeImp, exchangeType);if (didAddMethod) &#123; // 替换方法 class_replaceMethod([self class], @selector(exchange:), originalImp, originalType);&#125;else&#123; // Method Swizzling method_exchangeImplementations(exchangeMethod, originalMethod);&#125;/*----------------------Method Swizzling------------------------*/ 例子2 Runtime message12345678910111213141516171819202122232425262728293031323334// 初始化 [[MsgSend1 alloc] init]; MsgSend1 *msg = ((MsgSend1 * (*)(id,SEL))objc_msgSend)((id)[MsgSend1 class], @selector(alloc)); msg = ((MsgSend1 * (*)(id,SEL))objc_msgSend)((id)msg, @selector(init)); // 发送无参无返回值消息 ((void (*)(id,SEL))objc_msgSend)((id)msg, @selector(noArgumentsAndNoReturnValue)); // 发送有参数无返回值得消息 ((void (*)(id,SEL,NSString *))objc_msgSend)((id)msg, @selector(hasArguments:),@"带参数但是无返回值"); // 带返回值不带参数消息 NSString *retValue = ((NSString * (*)(id,SEL))objc_msgSend)((id)msg,@selector(noArgumentsButReturnValue)); NSLog(@"%@",retValue); // 带参数带返回值消息 int returnValue = ((int (*)(id,SEL,NSString *,int))objc_msgSend)((id)msg,@selector(hasValue1:Value2:),@"参数",999); NSLog(@"return value is %d",returnValue); // 动态添加方法再调用 其中i代表返回类型int，@代表参数，:代表SEL class_addMethod(msg.class, NSSelectorFromString(@"cStyleFunc"), (IMP)cStyleFunc,"i@:"); returnValue = ((int (*)(id,SEL,const void *,const void *))objc_msgSend)((id)msg,NSSelectorFromString(@"cStyleFunc"),"one","two"); NSLog(@"return value is %d",returnValue); // 带返回浮点值的消息 //objc_msgSend //float returnFloatValue = ((float (*)(id,SEL))objc_msgSend)((id)msg,@selector(returnFloatType)); //objc_msgSend_fpret float returnFloatValue = ((float (*)(id,SEL))objc_msgSend_fpret)((id)msg,@selector(returnFloatType)); NSLog(@"return float is %f",returnFloatValue); // 带结构体返回值的消息 //objc_msgSend_stret CGRect frame = ((CGRect (*)(id,SEL))objc_msgSend_stret)((id)self,@selector(returnTypeIsStruct)); NSLog(@"return frame is %@",NSStringFromCGRect(frame));]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UIAlertController]]></title>
    <url>%2F2017%2F02%2F06%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIAlertController%2F</url>
    <content type="text"><![CDATA[UIAlertController对象向用户展示一个提示消息。这个类替换了用于显示提示 UIActionSheet和UIAlertViewclasses类。可以使用presentViewController:animated:completion:方法配置你想要的事件和风格。 12345678910111213141516171819202122232425262728293031323334NS_CLASS_AVAILABLE_IOS(8_0) @interface UIAlertAction : NSObject &lt;NSCopying&gt;// 创建提示事件的标题、风格、点击事件的处理并返回提示事件+ (instancetype)actionWithTitle:(nullable NSString *)title style:(UIAlertActionStyle)style handler:(void (^ __nullable)(UIAlertAction *action))handler;// 标题@property (nullable, nonatomic, readonly) NSString *title;// 风格@property (nonatomic, readonly) UIAlertActionStyle style;// 是否启用事件@property (nonatomic, getter=isEnabled) BOOL enabled;@endNS_CLASS_AVAILABLE_IOS(8_0) @interface UIAlertController : UIViewController// 创建并返回一个用户展示提示的控制器+ (instancetype)alertControllerWithTitle:(nullable NSString *)title message:(nullable NSString *)message preferredStyle:(UIAlertControllerStyle)preferredStyle;// 添加UIAlertAction到控制器中- (void)addAction:(UIAlertAction *)action;// 用户可以操作的事件数组@property (nonatomic, readonly) NSArray&lt;UIAlertAction *&gt; *actions;// 设置首选的事件@property (nonatomic, strong, nullable) UIAlertAction *preferredAction NS_AVAILABLE_IOS(9_0);// 添加输入框- (void)addTextFieldWithConfigurationHandler:(void (^ __nullable)(UITextField *textField))configurationHandler;// 设置输入框数组@property (nullable, nonatomic, readonly) NSArray&lt;UITextField *&gt; *textFields;// 标题@property (nullable, nonatomic, copy) NSString *title;// 内容@property (nullable, nonatomic, copy) NSString *message;// 首选的风格@property (nonatomic, readonly) UIAlertControllerStyle preferredStyle;@end 123456789101112// 事件风格typedef NS_ENUM(NSInteger, UIAlertActionStyle) &#123;UIAlertActionStyleDefault = 0, // 默认UIAlertActionStyleCancel, // 取消UIAlertActionStyleDestructive // 红色&#125; NS_ENUM_AVAILABLE_IOS(8_0);// 控制器风格typedef NS_ENUM(NSInteger, UIAlertControllerStyle) &#123;UIAlertControllerStyleActionSheet = 0, // ActionSheetUIAlertControllerStyleAlert // AlertView&#125; NS_ENUM_AVAILABLE_IOS(8_0);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UIAlertView]]></title>
    <url>%2F2017%2F02%2F06%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIAlertView%2F</url>
    <content type="text"><![CDATA[使用UIAlertView类向用户显示一条警告消息。警报视图的功能相似，但在外观上不同于一个动作表（UIActionSheet的一个实例）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@protocol UIAlertViewDelegate;// iOS 2.0 - iOS 9.0可用 使用UIAlertController顶替NS_CLASS_DEPRECATED_IOS(2_0, 9_0, "UIAlertView is deprecated. Use UIAlertController with a preferredStyle of UIAlertControllerStyleAlert instead") __TVOS_PROHIBITED@interface UIAlertView : UIView// 初始化设置标题、代理、操作按钮- (instancetype)initWithTitle:(nullable NSString *)title message:(nullable NSString *)message delegate:(nullable id /*&lt;UIAlertViewDelegate&gt;*/)delegate cancelButtonTitle:(nullable NSString *)cancelButtonTitle otherButtonTitles:(nullable NSString *)otherButtonTitles, ... NS_REQUIRES_NIL_TERMINATION NS_EXTENSION_UNAVAILABLE_IOS("Use UIAlertController instead.");// 初始化设置frame- (id)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;- (nullable instancetype) initWithCoder:(nonnull NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;// 代理@property(nullable,nonatomic,weak) id /*&lt;UIAlertViewDelegate&gt;*/ delegate;// 标题@property(nonatomic,copy) NSString *title;// 提示内容@property(nullable,nonatomic,copy) NSString *message;// 在提示框中添加自定义按钮- (NSInteger)addButtonWithTitle:(nullable NSString *)title;// 返回指定索引按钮的标题- (nullable NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex;@property(nonatomic,readonly) NSInteger numberOfButtons;// 操作栏的按钮数@property(nonatomic) NSInteger cancelButtonIndex;// 第一个更多按钮的下标@property(nonatomic,readonly) NSInteger firstOtherButtonIndex;// 接收器是否显示@property(nonatomic,readonly,getter=isVisible) BOOL visible;// 显示提示框- (void)show;// 隐藏提示框- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;// 提示框的风格@property(nonatomic,assign) UIAlertViewStyle alertViewStyle NS_AVAILABLE_IOS(5_0);// 返回指定索引的文本框- (nullable UITextField *)textFieldAtIndex:(NSInteger)textFieldIndex NS_AVAILABLE_IOS(5_0);@end__TVOS_PROHIBITED@protocol UIAlertViewDelegate &lt;NSObject&gt;@optional// 点击操作按钮后调用- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex NS_DEPRECATED_IOS(2_0, 9_0);// 点击取消按钮后调用- (void)alertViewCancel:(UIAlertView *)alertView NS_DEPRECATED_IOS(2_0, 9_0);// 即将弹出提示框之前调用- (void)willPresentAlertView:(UIAlertView *)alertView NS_DEPRECATED_IOS(2_0, 9_0);// 提示框弹出后调用- (void)didPresentAlertView:(UIAlertView *)alertView NS_DEPRECATED_IOS(2_0, 9_0);// 操作后将要隐藏的提示框时调用- (void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex NS_DEPRECATED_IOS(2_0, 9_0);// 提示框隐藏完成后调用- (void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex NS_DEPRECATED_IOS(2_0, 9_0);// 是否启用提示框中第一个非取消按钮- (BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView *)alertView NS_DEPRECATED_IOS(2_0, 9_0);@end 1234567// 提示框风格typedef NS_ENUM(NSInteger, UIAlertViewStyle) &#123;UIAlertViewStyleDefault = 0, // 默认UIAlertViewStyleSecureTextInput, // 有密码输入框UIAlertViewStylePlainTextInput, // 普通文本输入框UIAlertViewStyleLoginAndPasswordInput // 登陆框&#125; __TVOS_PROHIBITED;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-UIKit框架学习—UIActionSheet]]></title>
    <url>%2F2017%2F02%2F06%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIActionSheet%2F</url>
    <content type="text"><![CDATA[使用UIActionSheet类可以把一套如何继续给定任务的替代品给用户。您还可以使用行动表，以提示用户确认是否有潜在危险的行动。该行动表包含一个可选的标题和一个或多个按钮，其中每个对应采取的行动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@protocol UIActionSheetDelegate;// iOS 2.0 - iOS 8.3可用 使用UIAlertController顶替NS_CLASS_DEPRECATED_IOS(2_0, 8_3, "UIActionSheet is deprecated. Use UIAlertController with a preferredStyle of UIAlertControllerStyleActionSheet instead") __TVOS_PROHIBITED@interface UIActionSheet : UIView// 初始化设置标题、代理、操作按钮- (instancetype)initWithTitle:(nullable NSString *)title delegate:(nullable id&lt;UIActionSheetDelegate&gt;)delegate cancelButtonTitle:(nullable NSString *)cancelButtonTitle destructiveButtonTitle:(nullable NSString *)destructiveButtonTitle otherButtonTitles:(nullable NSString *)otherButtonTitles, ... NS_REQUIRES_NIL_TERMINATION NS_EXTENSION_UNAVAILABLE_IOS("Use UIAlertController instead.");// 代理@property(nullable,nonatomic,weak) id&lt;UIActionSheetDelegate&gt; delegate;// 标题属性@property(nonatomic,copy) NSString *title;// 操作栏的风格@property(nonatomic) UIActionSheetStyle actionSheetStyle; // default is UIActionSheetStyleAutomatic.// 在操作栏中添加自定义按钮- (NSInteger)addButtonWithTitle:(nullable NSString *)title;// 返回指定索引按钮的标题- (nullable NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex;// 操作栏的按钮数@property(nonatomic,readonly) NSInteger numberOfButtons;// 取消按钮的下标@property(nonatomic) NSInteger cancelButtonIndex;// 破坏那妞的下标@property(nonatomic) NSInteger destructiveButtonIndex;// 第一个更多按钮的下标@property(nonatomic,readonly) NSInteger firstOtherButtonIndex;// 接收器是否显示@property(nonatomic,readonly,getter=isVisible) BOOL visible;// 显示一个来自指定工具栏的操作栏- (void)showFromToolbar:(UIToolbar *)view;// 显示一个来自指定标签栏的操作栏- (void)showFromTabBar:(UITabBar *)view;// 显示一个来自指定BarButtonItem的操作栏- (void)showFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated NS_AVAILABLE_IOS(3_2);// 显示一个来自指定矩形的操作栏- (void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated NS_AVAILABLE_IOS(3_2);// 显示一个来自指定视图的操作栏- (void)showInView:(UIView *)view;// 隐藏弹出框- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;@end__TVOS_PROHIBITED@protocol UIActionSheetDelegate &lt;NSObject&gt;@optional// 点击按钮操作调用- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex NS_DEPRECATED_IOS(2_0, 8_3) __TVOS_PROHIBITED;// 点击取消操作按钮调用- (void)actionSheetCancel:(UIActionSheet *)actionSheet NS_DEPRECATED_IOS(2_0, 8_3) __TVOS_PROHIBITED;// 即将弹出操作栏之前调用- (void)willPresentActionSheet:(UIActionSheet *)actionSheet NS_DEPRECATED_IOS(2_0, 8_3)__TVOS_PROHIBITED;// 操作栏弹出后调用- (void)didPresentActionSheet:(UIActionSheet *)actionSheet NS_DEPRECATED_IOS(2_0, 8_3) __TVOS_PROHIBITED;// 操作后将要隐藏的操作栏时调用- (void)actionSheet:(UIActionSheet *)actionSheet willDismissWithButtonIndex:(NSInteger)buttonIndex NS_DEPRECATED_IOS(2_0, 8_3) __TVOS_PROHIBITED;// 操作栏隐藏完成后调用- (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex NS_DEPRECATED_IOS(2_0, 8_3) __TVOS_PROHIBITED; // after animation@end 1234567// 操作栏风格typedef NS_ENUM(NSInteger, UIActionSheetStyle) &#123;UIActionSheetStyleAutomatic = -1, // take appearance from toolbar style otherwise uses 'default'UIActionSheetStyleDefault = UIBarStyleDefault, // 默认UIActionSheetStyleBlackTranslucent = UIBarStyleBlackTranslucent, // 半透明黑色UIActionSheetStyleBlackOpaque = UIBarStyleBlackOpaque , // 不透明黑色&#125; __TVOS_PROHIBITED;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UITableViewCell]]></title>
    <url>%2F2017%2F01%2F25%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UITableViewCell%2F</url>
    <content type="text"><![CDATA[UITableViewCell类定义了在UITableView对象出现时每个单元格的属性和行为。该类包括设置和管理单元格内容和背景（包括文本、图像和自定义视图）的属性和方法，管理单元格的选择和突出状态，管理附件视图，以及启动单元格内容的编辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768NS_CLASS_AVAILABLE_IOS(2_0) @interface UITableViewCell : UIView &lt;NSCoding, UIGestureRecognizerDelegate&gt;// 初始化设置风格，设置重用标识符- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(nullable NSString *)reuseIdentifier NS_AVAILABLE_IOS(3_0) NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;// 单元格中的图像视图（根据选择的方式视图位置会不同）@property (nonatomic, readonly, strong, nullable) UIImageView *imageView NS_AVAILABLE_IOS(3_0);// 文本主要内容标签@property (nonatomic, readonly, strong, nullable) UILabel *textLabel NS_AVAILABLE_IOS(3_0);// 详细内容的标签@property (nonatomic, readonly, strong, nullable) UILabel *detailTextLabel NS_AVAILABLE_IOS(3_0);// 单元格中的内容视图，可以添加自定义视图到内容视图上@property (nonatomic, readonly, strong) UIView *contentView;// 背景视图@property (nonatomic, strong, nullable) UIView *backgroundView;// 只用选中时才会显示的视图@property (nonatomic, strong, nullable) UIView *selectedBackgroundView;// 多重选择是的视图@property (nonatomic, strong, nullable) UIView *multipleSelectionBackgroundView NS_AVAILABLE_IOS(5_0);// 重用标识符@property (nonatomic, readonly, copy, nullable) NSString *reuseIdentifier;// 准备重用- (void)prepareForReuse;// 选中的风格@property (nonatomic) UITableViewCellSelectionStyle selectionStyle;// 时候可以选中@property (nonatomic, getter=isSelected) BOOL selected; //default is NO.// 是否可以高亮@property (nonatomic, getter=isHighlighted) BOOL highlighted; // default is NO.// 是否可以选中，是否带动画效果- (void)setSelected:(BOOL)selected animated:(BOOL)animated;// 是否可以高亮，是否带动画效果- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated;// 编辑状态下单元格的风格@property (nonatomic, readonly) UITableViewCellEditingStyle editingStyle;// 是否重新排序@property (nonatomic) BOOL showsReorderControl; // default is NO// 编辑状态下单元格是否缩进@property (nonatomic) BOOL shouldIndentWhileEditing; // default is YES.// 单元格左侧附件样式@property (nonatomic) UITableViewCellAccessoryType accessoryType;// 自定义附件视图@property (nonatomic, strong, nullable) UIView *accessoryView;// 编辑状态的附件样式@property (nonatomic) UITableViewCellAccessoryType editingAccessoryType;// 编辑状态的自定义附件视图@property (nonatomic, strong, nullable) UIView *editingAccessoryView;// 单元格内容的缩进级别@property (nonatomic) NSInteger indentationLevel; // default is 0// 单元格内容宽度缩进级别@property (nonatomic) CGFloat indentationWidth; // default is 10.0// 设置间隔@property (nonatomic) UIEdgeInsets separatorInset NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED;// 是否编辑状态@property (nonatomic, getter=isEditing) BOOL editing;- (void)setEditing:(BOOL)editing animated:(BOOL)animated;// 单元格是否显示删除按钮@property(nonatomic, readonly) BOOL showingDeleteConfirmation; // currently showing "Delete" button// 聚焦样式@property (nonatomic) UITableViewCellFocusStyle focusStyle NS_AVAILABLE_IOS(9_0) UI_APPEARANCE_SELECTOR;// 当单元格将要改变的时候调用- (void)willTransitionToState:(UITableViewCellStateMask)state NS_AVAILABLE_IOS(3_0);// 当单元格已经改变的时候调用- (void)didTransitionToState:(UITableViewCellStateMask)state NS_AVAILABLE_IOS(3_0);@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 单元格风格typedef NS_ENUM(NSInteger, UITableViewCellStyle) &#123;UITableViewCellStyleDefault, // 左侧显示textLabel（不显示detailTextLabel），imageView可选（显示在最左边）UITableViewCellStyleValue1, // 左侧显示textLabel、右侧显示detailTextLabel（默认蓝色），imageView可选（显示在最左边UITableViewCellStyleValue2, // 左侧依次显示textLabel(默认蓝色)和detailTextLabel，imageView可选（显示在最左边）UITableViewCellStyleSubtitle // 左上方显示textLabel，左下方显示detailTextLabel（默认灰色）,imageView可选（显示在最左边）&#125;;// 单元格分割样式typedef NS_ENUM(NSInteger, UITableViewCellSeparatorStyle) &#123;UITableViewCellSeparatorStyleNone, // 无UITableViewCellSeparatorStyleSingleLine, // 有单条分割线，默认UITableViewCellSeparatorStyleSingleLineEtched // 两条分割线&#125; __TVOS_PROHIBITED;// 单元格选中样式typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &#123;UITableViewCellSelectionStyleNone, // 无UITableViewCellSelectionStyleBlue, // 默认选中样式UITableViewCellSelectionStyleGray, // 选中呈现灰色UITableViewCellSelectionStyleDefault NS_ENUM_AVAILABLE_IOS(7_0) // 表格单元格显示样式&#125;;// 聚焦样式typedef NS_ENUM(NSInteger, UITableViewCellFocusStyle) &#123;UITableViewCellFocusStyleDefault, // 当聚焦时采用系统默认样式UITableViewCellFocusStyleCustom // 当聚焦是采用自定义样式&#125; NS_ENUM_AVAILABLE_IOS(9_0);// 编辑状态样式typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123;UITableViewCellEditingStyleNone, // 无UITableViewCellEditingStyleDelete, // 删除UITableViewCellEditingStyleInsert // 插入&#125;;// 附件样式typedef NS_ENUM(NSInteger, UITableViewCellAccessoryType) &#123;UITableViewCellAccessoryNone, // 无UITableViewCellAccessoryDisclosureIndicator, // 箭头UITableViewCellAccessoryDetailDisclosureButton __TVOS_PROHIBITED, // 显示详情符号和灰色箭头UITableViewCellAccessoryCheckmark, // 复选框UITableViewCellAccessoryDetailButton NS_ENUM_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED&#125;;// 表格状态typedef NS_OPTIONS(NSUInteger, UITableViewCellStateMask) &#123;UITableViewCellStateDefaultMask = 0, // 默认UITableViewCellStateShowingEditControlMask = 1 &lt;&lt; 0, // 编辑状态UITableViewCellStateShowingDeleteConfirmationMask = 1 &lt;&lt; 1 // 删除状态&#125;;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UINavigationBar]]></title>
    <url>%2F2017%2F01%2F25%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UINavigationBar%2F</url>
    <content type="text"><![CDATA[一种支持分层内容导航的视觉控制，最常用于导航控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394@class UINavigationItem, UIBarButtonItem, UIImage, UIColor;@protocol UINavigationBarDelegate;NS_CLASS_AVAILABLE_IOS(2_0) @interface UINavigationBar : UIView &lt;NSCoding, UIBarPositioning&gt;// 外观样式@property(nonatomic,assign) UIBarStyle barStyle UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED;// 代理@property(nullable,nonatomic,weak) id&lt;UINavigationBarDelegate&gt; delegate;// 是否半透明显示@property(nonatomic,assign,getter=isTranslucent) BOOL translucent NS_AVAILABLE_IOS(3_0) UI_APPEARANCE_SELECTOR;// 将给定导航项推到导航的栏栈上，并更新界面- (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated;// 返回被弹出的项目- (nullable UINavigationItem *)popNavigationItemAnimated:(BOOL)animated; // 导航栏顶部的导航项@property(nullable, nonatomic,readonly,strong) UINavigationItem *topItem;// 导航栏堆栈中最顶层以下的项目@property(nullable, nonatomic,readonly,strong) UINavigationItem *backItem;// 导航栏管理的导航项数组@property(nullable,nonatomic,copy) NSArray&lt;UINavigationItem *&gt; *items;// 替换当前导航栏上的项目- (void)setItems:(nullable NSArray&lt;UINavigationItem *&gt; *)items animated:(BOOL)animated;// 底色@property(null_resettable, nonatomic,strong) UIColor *tintColor;@property(nullable, nonatomic,strong) UIColor *barTintColor NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;// 设置用于在给定位置和给定度量的背景的图像- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;// 返回用于在给定位置和给定度量的背景的图像- (nullable UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forBarMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;- (nullable UIImage *)backgroundImageForBarMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 边框图片@property(nullable, nonatomic,strong) UIImage *shadowImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;// 标题的属性文本@property(nullable,nonatomic,copy) NSDictionary&lt;NSString *,id&gt; *titleTextAttributes NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 设置标题垂直位置调整- (void)setTitleVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 返回标题垂直调整的数值- (CGFloat)titleVerticalPositionAdjustmentForBarMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 返回按钮的图片@property(nullable,nonatomic,strong) UIImage *backIndicatorImage NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED;// push和pop操作用于遮挡的图片@property(nullable,nonatomic,strong) UIImage *backIndicatorTransitionMaskImage NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED;@end@protocol UINavigationBarDelegate &lt;UIBarPositioningDelegate&gt;@optional// 导航栏是否应该推送选项- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPushItem:(UINavigationItem *)item;// 将项目推到导航栏上- (void)navigationBar:(UINavigationBar *)navigationBar didPushItem:(UINavigationItem *)item;// 导航栏是否应该弹出选项- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPopItem:(UINavigationItem *)item;// 从导航栏中弹出- (void)navigationBar:(UINavigationBar *)navigationBar didPopItem:(UINavigationItem *)item;@endNS_CLASS_AVAILABLE_IOS(2_0) @interface UINavigationItem : NSObject &lt;NSCoding&gt;// 初始化并设置标题- (instancetype)initWithTitle:(NSString *)title NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;// 标题@property(nullable, nonatomic,copy) NSString *title;// 自定义标题视图@property(nullable, nonatomic,strong) UIView *titleView;// 显示在导航栏顶部不得单行文本@property(nullable,nonatomic,copy) NSString *prompt __TVOS_PROHIBITED;// 返回按钮项@property(nullable,nonatomic,strong) UIBarButtonItem *backBarButtonItem __TVOS_PROHIBITED;// 是否隐藏返回按钮@property(nonatomic,assign) BOOL hidesBackButton __TVOS_PROHIBITED;// 隐藏返回按钮并带动画效果- (void)setHidesBackButton:(BOOL)hidesBackButton animated:(BOOL)animated __TVOS_PROHIBITED;// 导航栏左侧操作按钮数组@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *leftBarButtonItems NS_AVAILABLE_IOS(5_0);// 导航栏右侧操作按钮数组@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *rightBarButtonItems NS_AVAILABLE_IOS(5_0);- (void)setLeftBarButtonItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated NS_AVAILABLE_IOS(5_0);- (void)setRightBarButtonItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated NS_AVAILABLE_IOS(5_0);// 除了返回按钮外是否显示左侧的项目@property(nonatomic) BOOL leftItemsSupplementBackButton NS_AVAILABLE_IOS(5_0) __TVOS_PROHIBITED;// 左侧按钮视图@property(nullable, nonatomic,strong) UIBarButtonItem *leftBarButtonItem;// 右侧按钮视图@property(nullable, nonatomic,strong) UIBarButtonItem *rightBarButtonItem;- (void)setLeftBarButtonItem:(nullable UIBarButtonItem *)item animated:(BOOL)animated;- (void)setRightBarButtonItem:(nullable UIBarButtonItem *)item animated:(BOOL)animated;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UIToolbar]]></title>
    <url>%2F2017%2F01%2F25%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIToolbar%2F</url>
    <content type="text"><![CDATA[UIToolbar是显示一个或多个按钮的控件又称工具栏项。工具栏轻按时突出显示或不更改项目的外观。 12345678910111213141516171819202122232425262728293031@class UIBarButtonItem, UIColor;@protocol UIToolbarDelegate;NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UIToolbar : UIView &lt;UIBarPositioning&gt;// 工具栏外观样式@property(nonatomic) UIBarStyle barStyle UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED; // default is UIBarStyleDefault (blue)// 工具栏上显示的选项@property(nullable, nonatomic, copy) NSArray&lt;UIBarButtonItem *&gt; *items;// 是否半透明显示@property(nonatomic,assign,getter=isTranslucent) BOOL translucent NS_AVAILABLE_IOS(3_0) UI_APPEARANCE_SELECTOR;// 工具栏上显示的选项，有动画效果- (void)setItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated;// 工具栏上按钮的底色@property(null_resettable, nonatomic, strong) UIColor *tintColor;// 工具栏的底色@property(nullable, nonatomic, strong) UIColor *barTintColor NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR; // default is nil// 设置用于在给定位置和给定度量的背景的图像- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 返回用于在给定位置和给定度量的背景的图像- (nullable UIImage *)backgroundImageForToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 设置用于给定位置的工具栏阴影的图像- (void)setShadowImage:(nullable UIImage *)shadowImage forToolbarPosition:(UIBarPosition)topOrBottom NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;// 返回用于给定位置的工具栏阴影的图像- (nullable UIImage *)shadowImageForToolbarPosition:(UIBarPosition)topOrBottom NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;// 代理@property(nullable, nonatomic, weak) id&lt;UIToolbarDelegate&gt; delegate NS_AVAILABLE_IOS(7_0); // You may not set the delegate when the toolbar is managed by a UINavigationController.@end__TVOS_PROHIBITED@protocol UIToolbarDelegate &lt;UIBarPositioningDelegate&gt;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UITabBar]]></title>
    <url>%2F2017%2F01%2F25%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UITabBar%2F</url>
    <content type="text"><![CDATA[UITabBar是一个应用之前不同子任务、视图和模式之间选择控制。通常情况下，UITabBar是和UITabBarController配合使用，但是你也可一把他当做单独的控件使用。标签栏总是出现在屏幕的底部边缘和显示一个或多个的内容UITabBarItem的对象。标签栏的外观可以使用背景图片或色调颜色进行自定义，以满足界面的需要。点击项目将选择并突出显示该项目，并使用该项目的选择为应用启用相应的模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@class UITabBarItem;@class UIImageView;@protocol UITabBarDelegate;NS_CLASS_AVAILABLE_IOS(2_0) @interface UITabBar : UIView// 代理@property(nullable, nonatomic, weak) id&lt;UITabBarDelegate&gt; delegate;// 填充的UITabBarItem数组@property(nullable, nonatomic, copy) NSArray&lt;UITabBarItem *&gt; *items;// 当前选中的item@property(nullable, nonatomic, weak) UITabBarItem *selectedItem;// 设置标签栏项目可选动画- (void)setItems:(nullable NSArray&lt;UITabBarItem *&gt; *)items animated:(BOOL)animated;// 可以自定义标签栏- (void)beginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items __TVOS_PROHIBITED;// 隐藏自定义的标签栏- (BOOL)endCustomizingAnimated:(BOOL)animated __TVOS_PROHIBITED;// 是否可以自定义标签栏#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly, getter=isCustomizing) BOOL customizing __TVOS_PROHIBITED;#else- (BOOL)isCustomizing __TVOS_PROHIBITED;#endif// 标签栏的底部色值@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(5_0);// 标签栏背景的底部色值@property(nullable, nonatomic, strong) UIColor *barTintColor NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR; // default is nil// 未被选中标签栏的item被渲染的颜色@property (nonatomic, readwrite, copy, nullable) UIColor *unselectedItemTintColor NS_AVAILABLE_IOS(10_0) UI_APPEARANCE_SELECTOR;// 被选中itme的渲染图片颜色@property(nullable, nonatomic, strong) UIColor *selectedImageTintColor NS_DEPRECATED_IOS(5_0,8_0,"Use tintColor") UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED;// 标签栏的背景图片@property(nullable, nonatomic, strong) UIImage *backgroundImage NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 选择指示器的图片@property(nullable, nonatomic, strong) UIImage *selectionIndicatorImage NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 边框图片@property(nullable, nonatomic, strong) UIImage *shadowImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;// 标签栏中标签项目的定位方案@property(nonatomic) UITabBarItemPositioning itemPositioning NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED;// 标签栏项目的宽度@property(nonatomic) CGFloat itemWidth NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;// 标签项目的空格数量@property(nonatomic) CGFloat itemSpacing NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR;// 标签栏风格@property(nonatomic) UIBarStyle barStyle NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED;// 是否半透明 默认是YES@property(nonatomic,getter=isTranslucent) BOOL translucent NS_AVAILABLE_IOS(7_0);@end//___________________________________________________________________________________________________@protocol UITabBarDelegate&lt;NSObject&gt;@optional// 当用户选择项目的时候调用- (void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item;// 自定定义视图显示之前调用- (void)tabBar:(UITabBar *)tabBar willBeginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items __TVOS_PROHIBITED;// 自定义视图显示后调用- (void)tabBar:(UITabBar *)tabBar didBeginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items __TVOS_PROHIBITED;// 自定义将要消失调用- (void)tabBar:(UITabBar *)tabBar willEndCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items changed:(BOOL)changed __TVOS_PROHIBITED;// 自定义视图消失后调用- (void)tabBar:(UITabBar *)tabBar didEndCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items changed:(BOOL)changed __TVOS_PROHIBITED;@end// 标签栏的布局方式typedef NS_ENUM(NSInteger, UITabBarItemPositioning) &#123;UITabBarItemPositioningAutomatic, // 自动UITabBarItemPositioningFill, // 充满UITabBarItemPositioningCentered, // 居中&#125; NS_ENUM_AVAILABLE_IOS(7_0);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UIImageView]]></title>
    <url>%2F2017%2F01%2F25%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIImageView%2F</url>
    <content type="text"><![CDATA[UIImageView 是在界面中显示单个图像或动画的图像控件。图像视图允许您有效地绘制可以使用 UIImage 对象指定的任何图像。例如，您可以使用此类来显示许多标准图像文件，如 JPEG 和 PNG 文件的内容。你可以以编程方式或演示图板文件中配置图像视图并更改它们在运行时显示的图像。对于动画图像，也可以使用此类的方法来启动和停止动画和指定其他动画参数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@class UIImage;NS_CLASS_AVAILABLE_IOS(2_0) @interface UIImageView : UIView// 初始化并设置图片- (instancetype)initWithImage:(nullable UIImage *)image;// 初始化并设置高亮时的图片- (instancetype)initWithImage:(nullable UIImage *)image highlightedImage:(nullable UIImage *)highlightedImage NS_AVAILABLE_IOS(3_0);// 图片属性@property (nullable, nonatomic, strong) UIImage *image; // default is nil// 高亮图片@property (nullable, nonatomic, strong) UIImage *highlightedImage NS_AVAILABLE_IOS(3_0); // default is nil// 是否可以交互@property (nonatomic, getter=isUserInteractionEnabled) BOOL userInteractionEnabled; // default is NO// 是否高亮@property (nonatomic, getter=isHighlighted) BOOL highlighted NS_AVAILABLE_IOS(3_0); // default is NO// 设置动画图片的数组 （例如：播放微信语音消息效果）@property (nullable, nonatomic, copy) NSArray&lt;UIImage *&gt; *animationImages;// 设置高亮时动画图片的数组@property (nullable, nonatomic, copy) NSArray&lt;UIImage *&gt; *highlightedAnimationImages NS_AVAILABLE_IOS(3_0);// 设置一个动画的周期时间@property (nonatomic) NSTimeInterval animationDuration;// 设置动画重复次数@property (nonatomic) NSInteger animationRepeatCount;// 设置底色色彩@property (null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(7_0);// 开始播放图片动画- (void)startAnimating;// 停止播放图片动画- (void)stopAnimating;// 是否允许动画#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly, getter=isAnimating) BOOL animating;#else- (BOOL)isAnimating;#endif// 是否UIImageView响应时，父视图成为焦点@property (nonatomic) BOOL adjustsImageWhenAncestorFocused UIKIT_AVAILABLE_TVOS_ONLY(9_0);// 当图像视图聚焦时使用的布局指南@property(readonly,strong) UILayoutGuide *focusedFrameGuide UIKIT_AVAILABLE_TVOS_ONLY(9_0);@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UIActivityIndicatorView]]></title>
    <url>%2F2017%2F01%2F25%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIActivityIndicatorView%2F</url>
    <content type="text"><![CDATA[使用活动指示灯显示任务进行过程中。活动指示灯显示为一个”齿轮”，是旋转或停止。 1234567891011121314151617181920212223242526272829303132NS_CLASS_AVAILABLE_IOS(2_0) @interface UIActivityIndicatorView : UIView &lt;NSCoding&gt;// 初始化并设置风格- (instancetype)initWithActivityIndicatorStyle:(UIActivityIndicatorViewStyle)style NS_DESIGNATED_INITIALIZER;// 初始化并设置位置和大小- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;// 初始化并设置nib- (instancetype) initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;// 指示器的风格@property(nonatomic) UIActivityIndicatorViewStyle activityIndicatorViewStyle;// 当指示器隐藏时是否停止@property(nonatomic) BOOL hidesWhenStopped; // default is YES.// 活动指示器的颜色@property (nullable, readwrite, nonatomic, strong) UIColor *color NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 启动活动指示器动画- (void)startAnimating;// 停止活动指示器动画- (void)stopAnimating;// 是否开启动画#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly, getter=isAnimating) BOOL animating;#else- (BOOL)isAnimating;#endif@end// 活动指示器的风格typedef NS_ENUM(NSInteger, UIActivityIndicatorViewStyle) &#123;UIActivityIndicatorViewStyleWhiteLarge, UIActivityIndicatorViewStyleWhite, UIActivityIndicatorViewStyleGray __TVOS_PROHIBITED, &#125;;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UIProgressView]]></title>
    <url>%2F2017%2F01%2F25%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIProgressView%2F</url>
    <content type="text"><![CDATA[您可以使用 UIProgressView 类来描述任务的进度，随着时间的推移。进度栏示例是在当它下载邮件时应用程序的底部所示。1234567891011121314151617181920212223242526272829303132@class UIImageView, CAGradientLayer;// 进度条风格typedef NS_ENUM(NSInteger, UIProgressViewStyle) &#123;UIProgressViewStyleDefault, // 默认UIProgressViewStyleBar __TVOS_PROHIBITED, // 用于工具栏&#125;;NS_CLASS_AVAILABLE_IOS(2_0) @interface UIProgressView : UIView &lt;NSCoding&gt;// 初始化并设置坐标和大小- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;// 初始化并设置nib- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;// 初始化并设置进度条风格- (instancetype)initWithProgressViewStyle:(UIProgressViewStyle)style;// 进度条的风格属性@property(nonatomic) UIProgressViewStyle progressViewStyle;// 进度值 0.0-1.0@property(nonatomic) float progress;// 填充进度条的显示颜色@property(nonatomic, strong, nullable) UIColor* progressTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 进度条不填充的部分的显示颜色@property(nonatomic, strong, nullable) UIColor* trackTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 填充进度条的显示图片@property(nonatomic, strong, nullable) UIImage* progressImage NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 进度条不填充的部分的显示图片@property(nonatomic, strong, nullable) UIImage* trackImage NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;// 设置进度- (void)setProgress:(float)progress animated:(BOOL)animated NS_AVAILABLE_IOS(5_0);// 用于更新进度视图的进展对象@property(nonatomic, strong, nullable) NSProgress *observedProgress NS_AVAILABLE_IOS(9_0);@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UIPickerView]]></title>
    <url>%2F2017%2F01%2F25%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIPickerView%2F</url>
    <content type="text"><![CDATA[UIPickerView 类实现对象，称为选取器视图，用纺车或老虎机的隐喻来显示一个或多个集合的值。用户通过旋转的车轮，以便与选择指示器对齐所需的行的值来选择值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@protocol UIPickerViewDataSource, UIPickerViewDelegate;NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UIPickerView : UIView &lt;NSCoding&gt;// 数据源@property(nullable,nonatomic,weak) id&lt;UIPickerViewDataSource&gt; dataSource;// 代理@property(nullable,nonatomic,weak) id&lt;UIPickerViewDelegate&gt; delegate;// 是否显示选择指示符@property(nonatomic) BOOL showsSelectionIndicator; // default is NO// 获取该选择视图组件的数量@property(nonatomic,readonly) NSInteger numberOfComponents;// 返回组件的行数- (NSInteger)numberOfRowsInComponent:(NSInteger)component;// 返回组件行的大小- (CGSize)rowSizeForComponent:(NSInteger)component;// 返回指定行和控件的视图控制器- (nullable UIView *)viewForRow:(NSInteger)row forComponent:(NSInteger)component;// 刷新单一视图组件或全部- (void)reloadAllComponents;- (void)reloadComponent:(NSInteger)component;// 将指定的行滚动到选择器中心- (void)selectRow:(NSInteger)row inComponent:(NSInteger)component animated:(BOOL)animated;// 返回选定的组件的下标- (NSInteger)selectedRowInComponent:(NSInteger)component;@end__TVOS_PROHIBITED@protocol UIPickerViewDataSource&lt;NSObject&gt;@required// 返回要显示列的数目- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView;// 返回指定选择器的组件的行数- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component;@end__TVOS_PROHIBITED@protocol UIPickerViewDelegate&lt;NSObject&gt;@optional// 返回组件列的宽度和高度- (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component __TVOS_PROHIBITED;- (CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component __TVOS_PROHIBITED;// 给组件设置标题- (nullable NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component __TVOS_PROHIBITED;// 给组件设置带样式的标题- (nullable NSAttributedString *)pickerView:(UIPickerView *)pickerView attributedTitleForRow:(NSInteger)row forComponent:(NSInteger)component NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;// 设置指定的行指定组件的视图- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(nullable UIView *)view __TVOS_PROHIBITED;// 用户选择组件中的行时调用- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component __TVOS_PROHIBITED;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客搭建]]></title>
    <url>%2F2017%2F01%2F18%2FHexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[上一篇文章 阿里云虚拟机下搭建Typecho、WordPress博客 简单的记录了Typecho、WordPress下搭建个人博客过程，今天这篇文章记录下Hexo搭建个人博客的过程，对于此平台的介绍分析个人博客搭建前期工作这篇文章也有说道。 配置 Git 安装 Git：下载安装后，注册 GitHub 账号并配置 Git 创建 GitHub Repository：Repository 名字必须是 你的 GitHub 名.GitHub.io 配置 SSH打开终端 ，输入cd ~/.ssh，如果果提示：No such file or directory说明未配置 SSH 本地生成密钥对ssh-keygen -t rsa -C &quot;你的邮件地址&quot;，注意命令中的大小写不要搞混。按提示指定保存文件夹，不设置密码。 添加公钥到 GitHub 根据上一步的提示，找到公钥文件（默认为id_rsa.pub），用记事本打开，全选并复制。 登录 GitHub，右上角 头像 —&gt; Settings —&gt;SSH keys and GPG keys —&gt; New SSK key。把公钥粘贴到 Key 中，任意填好 Title 并点击 Add SSH key。 终端中输入命令 ssh -T git@github.com，选 yes，等待片刻可看到成功提示。 修改本地的 ssh remote url，不用 HTTPS 协议，改用 Git 协议 GitHub 仓库中获取 ssh 协议相应的 url 本地仓库执行命令git remote set-url origin &quot;你的仓库的url&quot; ，配置完后可用git remote -v 查看结果 配置 hexo 安装 Node.js 安装 Hexo：npm install hexo-deployer-git --save，可用 hexo -v查看版本可能安装过程并不是那么顺利，这个时候就需要到代理来安装： 清除代理：npm config delete http-proxy和npm config delete https-proxy 指向国内镜像源：npm config set registry http://registry.cnpmjs.org/ 创建 Hexo 文件夹：新建放置博客的文件夹，进入并执行命令hexo init。hexo 会在目标文件夹建立网站所需要的所有文件 安装依赖包：npm install 部署：打开博客根目录下的 _config.yml 文件，修改配置: 官方配置文档##把Hexo部署到 GitHub 生成静态页面执行命令：hexo generate 或hexo g 启动本地服务器执行命令：hexo server或hexo s在浏览器中打开http://localhost:4000/，如果打开正常执行下一步。 部署网站执行命令：hexo deploy或hexo d 在浏览器中打开iOSWynter.github.io预览效果，反正我是打不开。 绑定域名 向你的 Github Pages 仓库添加一个CNAME文件 写入域名如：wynter.wang 注意不要带www 执行hexo d -g 向DNS中添加三条记录 @ A 192.30.252.153@ A 192.30.252.154www CNAME username.github.io 等待 DNS 配置生效（10分钟左右） 通过在浏览器中输入域名访问网站 配置HTTPS为了使网站更全最好的方法就是使用HTTPS，使用HTTPS后也会让人感觉网站更专业点，瞬间提升逼格。我们这里选用第三方免费的证书来给自己的网站做HTTPS。推荐使用CloudFlare 和 Netlify 这两个平台都提供了免费SSL证书，两者使用同样简单，但是 Netlify 创建成功后会关联到你的github中XXXX.github.io的项目，以后每次 GitHub 的 push 操作都会自动触发 Netlify 重新编译部署，而且还会生成一个xxx.netlify.com的二级域名，同样也支持HTTPS。 CloudFlare 配置： 1、Add a website 填写域名如：xxx.com，检测DNS记录值2、根据提示设置CloudFlare站点IP解析（等待10分钟左右）3、选择CloudFlare免费加速Free Website方案 Netlify 配置： 1、登陆Netlify入XXXX.github.io项目2、设置Name和Domain3、根据提示设置CloudFlare站点IP解析（等待10分钟左右）4、在官网菜单中选择HTTPS点击Let’s Encrypt开启HTTPS 解决多说功能失效在配置完HTTPS后发现多说的评论和分享功能失效，然后使用浏览器的审查，发现是由于多说资源网址并不支持HTTPS导致，强制使用https://static.duoshuo.com/embed.js无法获取embed.js文件，那么问题就找到了，解决办法如下： 1、在浏览器中输入http://static.duoshuo.com/embed.js，然后command+s选择页面源码点击储存2、将储存的embed.js文件，放到~/hexo/themes/next/source/js/的目录下3、打开~/hexo/themes/next/layout/_scripts/third-party/comments/目录下的duoshuo.swig,将ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;;替换为ds.src = &#39;/js/embed.js&#39;; 附加Hexo常用命令 命令 介绍 简写 hexo init [folder] 新建一个网站。如果没有设置 folder，Hexo 默认在目前的文件夹建立网站 无 hexo new [layout] &#39;title&#39; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的default_layout 参数代替。如果标题包含空格的话，请使用引号括起来 hexo n &#39;title&#39; hexo new page &#39;title&#39; 新建页面 无 hexo generate 生成静态文件 hexo g hexo publish &#39;title&#39; 发表草稿 hexo p hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/ hexo s hexo deploy 部署网站 hexo d hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo c hexo deploy -generate 生成静态页面并部署 hexo d -g 总结hexo搭建博客并不是这么简单，也是美美的折腾了一波搭建成功的，让我先去哭会。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云虚拟机下搭建Typecho、WordPress博客]]></title>
    <url>%2F2017%2F01%2F17%2F%E9%98%BF%E9%87%8C%E4%BA%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B%E6%90%AD%E5%BB%BATypecho%E3%80%81WordPress%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天记录下在阿里云虚拟机下搭建Tpyecho和WordPress两个平台，对是两个不同的平台。为什么把两个平台合并到一起介绍呢？我解释下因为两个平台的搭建过程、配置都很相似，并且这两个平台配置都很简单，不足以写两篇文章。下面开始平台搭建。 下载平台下载地址：Typecho、WordPress文件上传工具：File Zilla 配置Typecho不要配置。WordPress下载下来后拷贝wp-config-sample.php文件，重新命名为wp-config.php，打开这两个配置文件设置如下：对应的数据库信息在：控制台-&gt;云虚拟主机-&gt;管理-&gt;数据库信息出现如下： 注意：WordPress平台要求PHP 5.2.4以上版本，所以记得将主机PHP环境设置高于PHP 5.2.4 如图： 域名绑定服务器上篇个人博客搭建前期工作中介绍了域名、服务器的选择和购买，并且完成域名备案，如果没有域名备案还在进行中，那也没关系，因为在阿里购买虚拟机赠送了一个月的备案域名，只能用于网站的调试（哈哈，有点给阿里云打广告的嫌疑）。如果备案完成进入控制台-&gt;域名-&gt;wynter.wang点击后面的解析-&gt;设置网站解析点击立即解析，如果是购买阿里云的虚拟主机系统会自动检测到主机IP的地址，不是的话就手动设置其他主机的IP地址，然后点击提交，主机和域名绑定完成。 文件上传使用File Zilla工具将下载的Typecho、WordPress文件上传到服务器上的htdocs目录下 数据库和网站配置 文件上传文成之后，在浏览器中输入wynter.wang，会看到Typecho、WordPress的数据库配置和网站配置界面，按照说明填写即可。 配置完成后就会看到Hello world界面了。 更改主题 Typecho：主要是一些主题、插件，需要手动放到themes文件下，然后进入后台主题选择启用。 WordPress：也可以通过后台主题管理下载主题，直接应用非常方便。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Typecho</tag>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UIWindow]]></title>
    <url>%2F2017%2F01%2F13%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIWindow%2F</url>
    <content type="text"><![CDATA[一个UIWindow对象提供了您的应用程序的用户界面的背景和提供了重要的事件处理行为。Windows没有自己的任何视觉外观，但它们对于应用程序视图的呈现至关重要。屏幕上显示的每个视图都由一个窗口包围，每个窗口独立于应用程序中的其他窗口。应用程序接收的事件最初会传送到相应的窗口对象，然后将这些事件转发到相应的视图。Windows与您的视图控制器一起实现方向更改，并执行许多其他任务，这些任务是您应用程序操作的基础。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 相对窗的定位typedef CGFloat UIWindowLevel;@class UIEvent, UIScreen, NSUndoManager, UIViewController;NS_CLASS_AVAILABLE_IOS(2_0) @interface UIWindow : UIView// 显示窗口的屏幕@property(nonatomic,strong) UIScreen *screen NS_AVAILABLE_IOS(3_2);// 该窗口在Z轴的位置。@property(nonatomic) UIWindowLevel windowLevel; // default = 0.0// 该窗口是不是应用的主视图@property(nonatomic,readonly,getter=isKeyWindow) BOOL keyWindow;// 通知已经变为主视图- (void)becomeKeyWindow;// 通知应经不是主视图- (void)resignKeyWindow;// 接收关键窗口- (void)makeKeyWindow;// 显示窗口并使其成为关键窗口- (void)makeKeyAndVisible;// 窗口的跟视图控制器@property(nullable, nonatomic,strong) UIViewController *rootViewController NS_AVAILABLE_IOS(4_0); // default is nil// 发送指定事件 UIApplication通过此方法来调度事件窗口- (void)sendEvent:(UIEvent *)event;// 转换一个点从接受对象的坐标系到指定窗口- (CGPoint)convertPoint:(CGPoint)point toWindow:(nullable UIWindow *)window;// 与上面相反，指定窗口坐标中的一个点转换为接收对象- (CGPoint)convertPoint:(CGPoint)point fromWindow:(nullable UIWindow *)window;// 将当前的矩形坐标空间转换到指定的矩形窗口空间- (CGRect)convertRect:(CGRect)rect toWindow:(nullable UIWindow *)window;// 将指定的矩形坐标空间转换到当前的矩形窗口空间- (CGRect)convertRect:(CGRect)rect fromWindow:(nullable UIWindow *)window;@endUIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal;UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert;UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar __TVOS_PROHIBITED;UIKIT_EXTERN NSNotificationName const UIWindowDidBecomeVisibleNotification;UIKIT_EXTERN NSNotificationName const UIWindowDidBecomeHiddenNotification;UIKIT_EXTERN NSNotificationName const UIWindowDidBecomeKeyNotification;UIKIT_EXTERN NSNotificationName const UIWindowDidResignKeyNotification;UIKIT_EXTERN NSNotificationName const UIKeyboardWillShowNotification __TVOS_PROHIBITED;UIKIT_EXTERN NSNotificationName const UIKeyboardDidShowNotification __TVOS_PROHIBITED;UIKIT_EXTERN NSNotificationName const UIKeyboardWillHideNotification __TVOS_PROHIBITED;UIKIT_EXTERN NSNotificationName const UIKeyboardDidHideNotification __TVOS_PROHIBITED;UIKIT_EXTERN NSString *const UIKeyboardFrameBeginUserInfoKey NS_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED; // NSValue of CGRectUIKIT_EXTERN NSString *const UIKeyboardFrameEndUserInfoKey NS_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED; // NSValue of CGRectUIKIT_EXTERN NSString *const UIKeyboardAnimationDurationUserInfoKey NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED; // NSNumber of doubleUIKIT_EXTERN NSString *const UIKeyboardAnimationCurveUserInfoKey NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED; // NSNumber of NSUInteger (UIViewAnimationCurve)UIKIT_EXTERN NSString *const UIKeyboardIsLocalUserInfoKey NS_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED; // NSNumber of BOOLUIKIT_EXTERN NSNotificationName const UIKeyboardWillChangeFrameNotification NS_AVAILABLE_IOS(5_0) __TVOS_PROHIBITED;UIKIT_EXTERN NSNotificationName const UIKeyboardDidChangeFrameNotification NS_AVAILABLE_IOS(5_0) __TVOS_PROHIBITED;UIKIT_EXTERN NSString *const UIKeyboardCenterBeginUserInfoKey NS_DEPRECATED_IOS(2_0, 3_2) __TVOS_PROHIBITED;UIKIT_EXTERN NSString *const UIKeyboardCenterEndUserInfoKey NS_DEPRECATED_IOS(2_0, 3_2) __TVOS_PROHIBITED;UIKIT_EXTERN NSString *const UIKeyboardBoundsUserInfoKey NS_DEPRECATED_IOS(2_0, 3_2) __TVOS_PROHIBITED;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UILabel]]></title>
    <url>%2F2017%2F01%2F13%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UILabel%2F</url>
    <content type="text"><![CDATA[显示一个或多个只读文本行的视图，通常与控件一起使用，以描述其预期用途。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@class UIColor, UIFont;NS_CLASS_AVAILABLE_IOS(2_0) @interface UILabel : UIView &lt;NSCoding, UIContentSizeCategoryAdjusting&gt;// 文本@property(nullable, nonatomic,copy) NSString *text;// 字体 默认是17号@property(null_resettable, nonatomic,strong) UIFont *font;// 文本颜色 默认深黑色@property(null_resettable, nonatomic,strong) UIColor *textColor;// 阴影颜色@property(nullable, nonatomic,strong) UIColor *shadowColor;// 阴影大小@property(nonatomic) CGSize shadowOffset;// 文本对齐方式 默认左对齐@property(nonatomic) NSTextAlignment textAlignment;// 文本截断方式 用于label不能完全展示文本内容@property(nonatomic) NSLineBreakMode lineBreakMode;// 设置label当前的显示的样式@property(nullable, nonatomic,copy) NSAttributedString *attributedText NS_AVAILABLE_IOS(6_0);// label高亮状态下的文本颜色 ↓@property(nullable, nonatomic,strong) UIColor *highlightedTextColor;// 是否高亮显示@property(nonatomic,getter=isHighlighted) BOOL highlighted; // default is NO// 是否忽略交互事件@property(nonatomic,getter=isUserInteractionEnabled) BOOL userInteractionEnabled; // default is NO// 在绘制文本时lable是否启用的状态@property(nonatomic,getter=isEnabled) BOOL enabled; // default is YES.// 文本展示的行数 默认是1行@property(nonatomic) NSInteger numberOfLines;// 是否根据lable宽度自动调整字体大小@property(nonatomic) BOOL adjustsFontSizeToFitWidth; // default is NO// 根据文本基线自动调整@property(nonatomic) UIBaselineAdjustment baselineAdjustment; // default is UIBaselineAdjustmentAlignBaselines// 文本最小缩小值@property(nonatomic) CGFloat minimumScaleFactor NS_AVAILABLE_IOS(6_0); // default is 0.0// 是否收紧之前截断的文本@property(nonatomic) BOOL allowsDefaultTighteningForTruncation NS_AVAILABLE_IOS(9_0); // default is NO// 返回label文件绘制的矩形- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines;// 在指定矩形中绘制文本- (void)drawTextInRect:(CGRect)rect;// 设置label的最大宽度@property(nonatomic) CGFloat preferredMaxLayoutWidth NS_AVAILABLE_IOS(6_0);@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客搭建前期工作]]></title>
    <url>%2F2017%2F01%2F12%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%89%8D%E6%9C%9F%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言最近刚好项目不是很忙，然后就想搭建下自己的个人博客，之前都是在印象笔记上记录，记录的也是乱七八糟，正好借此机会把笔记整理下。下面将给大家介绍域名、服务器、博客平台的选择。 域名个人博客域名通常都是自己英文+后缀组成，例如本网站域名：wynter.wang，就是笔者的英文名字+姓氏。 域名后缀个人博客常用后缀 后缀 说明 COM 全球注册量第一、注册首选; ( abc.com ) NET 寓意网络; ( abc.net ) ME 国别域名，引申义：英文me（我）; ( abc.me ) NAME 用于个人。很多个人博客和网站都已经注册 WANG 王牌域名、.网、寓意网络、互联网域名首选 ; ( abc.wang ) WIN 赢，3个月时间冲入全球4强，潜力巨大; ( abc.win ) 域名选择建议 首选COM 千万别加“-” 注意数字0和字母“O” 方便输入和易懂 个人推荐阿里云购买域名 域名购买完成之后，要做好备案，大概需要10-20天左右，购买域名的网站都有详细流程，并且免费备案，这里就不再赘述。 服务器如何选择服务器，主要可以从服务器健康状况、稳定性、访问速度、功能支持这四个方面来考虑，说到这里大家应该也会想到阿里的服务器，毕竟是经过几年双十一考验的，当然除了这四个主要的方面我们还会考虑到服务器的价格，根据主机的不同类型和配置价格也都不一样，有虚拟主机、VPS、专属主机几种，推荐选择虚拟主机，后面还会说道使用GitHub Pages搭建个人博客，也是现在很多技术博客的首选，不过只有300M免费空间，但是对于个人博客这个空间也够用了。 平台接来就是平台的选择，准备介绍这三个平台：Hexo、Typecho、WordPress 平台 介绍 优点 缺点 Hexo 一个基于 Node.js 的静态博客程序，可以方便的生成静态网页托管在 GitHub 和 Heroku 上 生成静态页面快、支持Markdown、高扩展性、自订性等 配置起来相对繁琐 Typecho 一个基于PHP5开发，支持多种数据库，是一款内核强健﹑扩展方便﹑体验友好﹑运行流畅的轻量级开源博客程序 轻量高效、稳定、简洁、部署方便 资源少、更新慢、兼容性低 WordPress 一个基于PHP5开发，一个注重美学、易用性和网络标准的个人信息发布平台 资源主题多、部署方便、更新快、兼容性高 臃肿 笔者也是专门去折腾了一番，最终选择hexo，对于为什么没有选择WordPress真的就两个字“臃肿”可以解释了，而为什么没有选择Typecho，是因为一方面资源太少，也没有全面的参考手册，有点小问题无从下手，还有一个重要的原因就是很多Markdown的语法都不支持。 主题对于主题选择那就要看个人爱好了，这里提供主题网址： Typecho：主要是一些主题、插件，需要手动放到themes文件下。 WordPress：也可以通过后台主题管理下载主题，直接应用非常方便。 Hexo: 主题很多，如果没有你满意的推荐next，yilia 总结总的来说搭建个人博客大框架就是：域名+服务器+博客平台+主题。后续还有具体的实现过程的文章]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>typecho</tag>
        <tag>Wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UIView]]></title>
    <url>%2F2017%2F01%2F12%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIView%2F</url>
    <content type="text"><![CDATA[UIView类定义了屏幕上一个矩形区域，在iOS中几乎所有的可视化控件都是UIView的子类，它还负责视图的内容管理、子视图管理、事件处理、动画实现等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469@protocol UICoordinateSpace &lt;NSObject&gt;// 将当前的坐标空间点转换到指定的坐标空间- (CGPoint)convertPoint:(CGPoint)point toCoordinateSpace:(id &lt;UICoordinateSpace&gt;)coordinateSpace NS_AVAILABLE_IOS(8_0);// 将指定的坐标空间点转换到当前的坐标空间- (CGPoint)convertPoint:(CGPoint)point fromCoordinateSpace:(id &lt;UICoordinateSpace&gt;)coordinateSpace NS_AVAILABLE_IOS(8_0);// 将当前的矩形坐标空间转换到指定的矩形坐标空间- (CGRect)convertRect:(CGRect)rect toCoordinateSpace:(id &lt;UICoordinateSpace&gt;)coordinateSpace NS_AVAILABLE_IOS(8_0);// 将指定的矩形坐标空间转换到当前的矩形坐标空间- (CGRect)convertRect:(CGRect)rect fromCoordinateSpace:(id &lt;UICoordinateSpace&gt;)coordinateSpace NS_AVAILABLE_IOS(8_0);// 该view在本地坐标系统中的位置和大小(参照点是，本地坐标系统)@property (readonly, nonatomic) CGRect bounds NS_AVAILABLE_IOS(8_0);@end// 视图的基础图层#if UIKIT_DEFINE_AS_PROPERTIES@property(class, nonatomic, readonly) Class layerClass;#else+ (Class)layerClass;#endif// 初始化视图并设置位置和大小- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;// 用于xib初始化- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;// 是否可以交互@property(nonatomic,getter=isUserInteractionEnabled) BOOL userInteractionEnabled; // default is YES.// 当前视图标签@property(nonatomic) NSInteger tag; // default is 0// 用于视图渲染的核心动画层@property(nonatomic,readonly,strong) CALayer *layer;#if UIKIT_DEFINE_AS_PROPERTIES// 视图是否可以被聚集（返回YES可能是：视图被隐藏、透明度为0，userInteractionEnabled设置为NO等）@property(nonatomic,readonly) BOOL canBecomeFocused NS_AVAILABLE_IOS(9_0); // NO by default#else- (BOOL)canBecomeFocused NS_AVAILABLE_IOS(9_0); // NO by default#endif// 当前项是否可以被聚焦@property (readonly, nonatomic, getter=isFocused) BOOL focused NS_AVAILABLE_IOS(9_0);// 左右滑动翻转效果@property (nonatomic) UISemanticContentAttribute semanticContentAttribute NS_AVAILABLE_IOS(9_0);// 返回界面的方向+ (UIUserInterfaceLayoutDirection)userInterfaceLayoutDirectionForSemanticContentAttribute:(UISemanticContentAttribute)attribute NS_AVAILABLE_IOS(9_0);// 返回相对于指定视图的界面方向+(UIUserInterfaceLayoutDirection)userInterfaceLayoutDirectionForSemanticContentAttribute:(UISemanticContentAttribute)semanticContentAttribute relativeToLayoutDirection:(UIUserInterfaceLayoutDirection)layoutDirection NS_AVAILABLE_IOS(10_0);// 安排即时内容的布局的方向@property (readonly, nonatomic) UIUserInterfaceLayoutDirection effectiveUserInterfaceLayoutDirection NS_AVAILABLE_IOS(10_0);@end@interface UIView(UIViewGeometry)// 父视图位置(参照点是，父view坐标系统)@property(nonatomic) CGRect frame;// 该view在本地坐标系统中的位置和大小(参照点是，本地坐标系统)@property(nonatomic) CGRect bounds;// frame中的中心点（决定当前视图是否是处理触摸事件的唯一对象）@property(nonatomic) CGPoint center;// 视图变换@property(nonatomic) CGAffineTransform transform;// 视图内容的缩放比例@property(nonatomic) CGFloat contentScaleFactor NS_AVAILABLE_IOS(4_0);// 支持多点触控@property(nonatomic,getter=isMultipleTouchEnabled) BOOL multipleTouchEnabled __TVOS_PROHIBITED; // default is NO// 决定当前视图是否处理出门事件的唯一对象@property(nonatomic,getter=isExclusiveTouch) BOOL exclusiveTouch __TVOS_PROHIBITED; // default is NO// 在指定点上点击测试指定事件- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;// 测试指定的点是否包含在接收对象中- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; // default returns YES if point is in bounds// 转换视图间坐标// 转换一个点从接受对象的坐标系到指定视图- (CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;// 与上面相反，指定视图坐标中的一个点转换为接收对象- (CGPoint)convertPoint:(CGPoint)point fromView:(nullable UIView *)view;// 将当前的矩形坐标空间转换到指定的矩形坐标空间- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;// 将指定的矩形坐标空间转换到当前的矩形坐标空间- (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;// 自动尺寸调整@property(nonatomic) BOOL autoresizesSubviews; // default is YES. if set, subviews are adjusted according to their autoresizingMask if self.bounds changes// 自动调整子控件与父控件中间的位置，宽高@property(nonatomic) UIViewAutoresizing autoresizingMask;// 计算并返回的大小最适合它的子视图的视图。（让视图计算最适合子视图的大小，即能把全部子视图显示出来所需要的最小的size）- (CGSize)sizeThatFits:(CGSize)size;// 得到最适合当前包含它子视图的尺寸- (void)sizeToFit;@end@interface UIView(UIViewHierarchy)// 当前视图的父视图@property(nullable, nonatomic,readonly) UIView *superview;// 当前视图的所有子视图@property(nonatomic,readonly,copy) NSArray&lt;__kindof UIView *&gt; *subviews;// 当前视图上的UIWindow@property(nullable, nonatomic,readonly) UIWindow *window;// 从父视图中移除- (void)removeFromSuperview;// 在指定的位置插入子视图，视图的所有视图其实组成了一个数组- (void)insertSubview:(UIView *)view atIndex:(NSInteger)index;// 交换两子视图的位置- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;// 添加视图- (void)addSubview:(UIView *)view;// 将指定的子视图移动到指定siblingSubview子视图的后面- (void)insertSubview:(UIView *)view belowSubview:(UIView *)siblingSubview;// 将指定的子视图移动到指定siblingSubview子视图的前面- (void)insertSubview:(UIView *)view aboveSubview:(UIView *)siblingSubview;// 移动指定的子视图到最顶层- (void)bringSubviewToFront:(UIView *)view;// 移动制定的子视图到后方，所有子视图的下面- (void)sendSubviewToBack:(UIView *)view;// 通知视图指定子视图已经添加- (void)didAddSubview:(UIView *)subview;// 通知视图将要移除指定的子视图- (void)willRemoveSubview:(UIView *)subview;// 通知视图将要移动到一个新的父视图中- (void)willMoveToSuperview:(nullable UIView *)newSuperview;// 通知视图已经移动到一个新的父视图中- (void)didMoveToSuperview;// 通知视图将要移动到一个新的window中- (void)willMoveToWindow:(nullable UIWindow *)newWindow;// 通知视图已经移动到一个新的window中- (void)didMoveToWindow;// 判断接收对象是否是指定视图的子视图，或与指定视图是同一视图- (BOOL)isDescendantOfView:(UIView *)view; // returns YES for self.// 返回指定标签匹配到的视图- (nullable __kindof UIView *)viewWithTag:(NSInteger)tag; // recursive search. includes self// 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用- (void)setNeedsLayout;// 如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）- (void)layoutIfNeeded;// 将子类重新布局- (void)layoutSubviews;// 设置视图的间距@property (nonatomic) UIEdgeInsets layoutMargins NS_AVAILABLE_IOS(8_0);// 是否将当前视图的间距和父视图相同@property (nonatomic) BOOL preservesSuperviewLayoutMargins NS_AVAILABLE_IOS(8_0); // default is NO// 通知布局发生变化- (void)layoutMarginsDidChange NS_AVAILABLE_IOS(8_0);// 视图间距引导@property(readonly,strong) UILayoutGuide *layoutMarginsGuide NS_AVAILABLE_IOS(9_0);/// 获取此区域的内的布局引导@property (nonatomic, readonly, strong) UILayoutGuide *readableContentGuide NS_AVAILABLE_IOS(9_0);@end@interface UIView(UIViewRendering)// 在指定的区域绘画视图- (void)drawRect:(CGRect)rect;// 标记整个视图的边界矩形需要重绘- (void)setNeedsDisplay;// 标记在指定区域内的视图的边界需要重绘- (void)setNeedsDisplayInRect:(CGRect)rect;// 决定子视图是否被限定在当前视图的bounds中@property(nonatomic) BOOL clipsToBounds; //Default is NO.// 背景色@property(nullable, nonatomic,copy) UIColor *backgroundColor UI_APPEARANCE_SELECTOR;// 透明度@property(nonatomic) CGFloat alpha; // animatable. default is 1.0// 不透明度@property(nonatomic,getter=isOpaque) BOOL opaque; // default is YES.// 决定在视图重画之前是否先清理视图以前的内容@property(nonatomic) BOOL clearsContextBeforeDrawing; // default is YES.// 是否隐藏视图@property(nonatomic,getter=isHidden) BOOL hidden; // default is NO.// 视图内容风格@property(nonatomic) UIViewContentMode contentMode; // default is UIViewContentModeScaleToFill// 一个可选视图，用于屏蔽视图内容@property(nullable, nonatomic,strong) UIView *maskView NS_AVAILABLE_IOS(8_0);// 最底部视图色彩@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(7_0);// 色彩调整风格@property(nonatomic) UIViewTintAdjustmentMode tintAdjustmentMode NS_AVAILABLE_IOS(7_0);// 告诉系统tintColor值将会改变- (void)tintColorDidChange NS_AVAILABLE_IOS(7_0);@end@interface UIView(UIViewAnimation)// 标记开始/提交动画块的开始+ (void)beginAnimations:(nullable NSString *)animationID context:(nullable void *)context;// 标记开始/提交动画块的结束，并为执行调度动画+ (void)commitAnimations;// 设置动画消息的委托+ (void)setAnimationDelegate:(nullable id)delegate; // default = nil// 设置动画启动时发送给动画委托的消息+ (void)setAnimationWillStartSelector:(nullable SEL)selector; // default = NULL. -animationWillStart:(NSString *)animationID context:(void *)context// 设置动画停止时发送给动画委托的消息+ (void)setAnimationDidStopSelector:(nullable SEL)selector; // default = NULL. -animationDidStop:(NSString *)animationID finished:(NSNumber *)finished context:(void *)context// 设置动画持续时间+ (void)setAnimationDuration:(NSTimeInterval)duration; // default = 0.2// 设置动画延迟执行时间+ (void)setAnimationDelay:(NSTimeInterval)delay; // default = 0.0// 设置动画开始时间+ (void)setAnimationStartDate:(NSDate *)startDate; // default = now ([NSDate date])// 设置动画曲线+ (void)setAnimationCurve:(UIViewAnimationCurve)curve; // default = UIViewAnimationCurveEaseInOut// 设置动画重复次数+ (void)setAnimationRepeatCount:(float)repeatCount; // default = 0.0.// 设置动画是否反转执行+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses; // default = NO.// 设置动画是否从当前状态开始播放+ (void)setAnimationBeginsFromCurrentState:(BOOL)fromCurrentState; // default = NO.// 设置到指定视图的过渡动画+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache;// 设置是否启用了动画+ (void)setAnimationsEnabled:(BOOL)enabled;// 是否启用了动画#if UIKIT_DEFINE_AS_PROPERTIES@property(class, nonatomic, readonly) BOOL areAnimationsEnabled;#else+ (BOOL)areAnimationsEnabled;#endif// 禁用视图的过渡动画+ (void)performWithoutAnimation:(void (NS_NOESCAPE ^)(void))actionsWithoutAnimation NS_AVAILABLE_IOS(7_0);// 当前动画的持续时间#if UIKIT_DEFINE_AS_PROPERTIES@property(class, nonatomic, readonly) NSTimeInterval inheritedAnimationDuration NS_AVAILABLE_IOS(9_0);#else+ (NSTimeInterval)inheritedAnimationDuration NS_AVAILABLE_IOS(9_0);#endif@end@interface UIView(UIViewAnimationWithBlocks)// 用于对一个或多个视图的改变的持续时间、延时、选项动画完成时的操作+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);// 用于对一个或多个视图的改变的持续时间、选项动画完成时的操作+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); // delay = 0.0, options = 0// 用于对一个或多个视图的改变的持续时间内动画完成时的操作+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations NS_AVAILABLE_IOS(4_0); // delay = 0.0, options = 0, completion = NULL// 使用与物理弹簧运动相对应的定时曲线执行视图动画+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);// 为指定的容器视图创建转换动画+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);// 使用给定的参数在指定视图之间创建转换动画+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);// 在一个或多个视图上执行指定的系统提供的动画，以及定义的可选并行动画.+ (void)performSystemAnimation:(UISystemAnimation)animation onViews:(NSArray&lt;__kindof UIView *&gt; *)views options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))parallelAnimations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);@end@interface UIView (UIViewKeyframeAnimations)// 创建一个动画块对象，可用于为当前视图设置基于关键帧的动画+ (void)animateKeyframesWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewKeyframeAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);// 添加指定开始时间、持续时间的关键帧动画+ (void)addKeyframeWithRelativeStartTime:(double)frameStartTime relativeDuration:(double)frameDuration animations:(void (^)(void))animations NS_AVAILABLE_IOS(7_0);@end@interface UIView (UIViewGestureRecognizers)// 当前视图所附加的手势识别器@property(nullable, nonatomic,copy) NSArray&lt;__kindof UIGestureRecognizer *&gt; *gestureRecognizers NS_AVAILABLE_IOS(3_2);// 为视图添加一个手势识别器- (void)addGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2);// 删除视图上的一个手势识别器- (void)removeGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer NS_AVAILABLE_IOS(3_2);// 开始一个手势识别器- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer NS_AVAILABLE_IOS(6_0);@end@interface UIView (UIViewMotionEffects)// 开始向视图中添加运动效果- (void)addMotionEffect:(UIMotionEffect *)effect NS_AVAILABLE_IOS(7_0);// 删除视图中的运动效果- (void)removeMotionEffect:(UIMotionEffect *)effect NS_AVAILABLE_IOS(7_0);// 视图中运动效果的数组@property (copy, nonatomic) NSArray&lt;__kindof UIMotionEffect *&gt; *motionEffects NS_AVAILABLE_IOS(7_0);@end@interface UIView (UIConstraintBasedLayoutInstallingConstraints)// 视图所持有的约束@property(nonatomic,readonly) NSArray&lt;__kindof NSLayoutConstraint *&gt; *constraints NS_AVAILABLE_IOS(6_0);// 添加一个约束- (void)addConstraint:(NSLayoutConstraint *)constraint NS_AVAILABLE_IOS(6_0);// 添加多个约束- (void)addConstraints:(NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraints NS_AVAILABLE_IOS(6_0);// 移除视图上指定的约束- (void)removeConstraint:(NSLayoutConstraint *)constraint NS_AVAILABLE_IOS(6_0);// 移除指定的一组约束- (void)removeConstraints:(NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraints NS_AVAILABLE_IOS(6_0);@end@interface UIView (UIConstraintBasedLayoutCoreMethods)// 更新视图和其子视图的约束- (void)updateConstraintsIfNeeded NS_AVAILABLE_IOS(6_0);// 为视图更新约束- (void)updateConstraints NS_AVAILABLE_IOS(6_0) NS_REQUIRES_SUPER;// 视图的约束是否需要更新- (BOOL)needsUpdateConstraints NS_AVAILABLE_IOS(6_0);// 设置视图的约束需要更新- (void)setNeedsUpdateConstraints NS_AVAILABLE_IOS(6_0);@end@interface UIView (UIConstraintBasedCompatibility)// 是否自动尺寸转换为自动布局@property(nonatomic) BOOL translatesAutoresizingMaskIntoConstraints NS_AVAILABLE_IOS(6_0); // Default YES// 视图是否一来与基础自动布局的约束#if UIKIT_DEFINE_AS_PROPERTIES@property(class, nonatomic, readonly) BOOL requiresConstraintBasedLayout NS_AVAILABLE_IOS(6_0);#else+ (BOOL)requiresConstraintBasedLayout NS_AVAILABLE_IOS(6_0);#endif@end@interface UIView (UIConstraintBasedLayoutLayering)// 返回给定框架的视图的对齐矩阵- (CGRect)alignmentRectForFrame:(CGRect)frame NS_AVAILABLE_IOS(6_0);// 返回给定对齐矩形的视图的frame- (CGRect)frameForAlignmentRect:(CGRect)alignmentRect NS_AVAILABLE_IOS(6_0);// 返回从视图的frame上定义的对齐矩阵的边框#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly) UIEdgeInsets alignmentRectInsets NS_AVAILABLE_IOS(6_0);#else- (UIEdgeInsets)alignmentRectInsets NS_AVAILABLE_IOS(6_0);#endif// 返回满足基线约束条件的视图- (UIView *)viewForBaselineLayout NS_DEPRECATED_IOS(6_0, 9_0, "Override -viewForFirstBaselineLayout or -viewForLastBaselineLayout as appropriate, instead") __TVOS_PROHIBITED;// 返回用于满足第一基线约束的视图@property(readonly,strong) UIView *viewForFirstBaselineLayout NS_AVAILABLE_IOS(9_0);// 返回用于满足上次基线约束的视图@property(readonly,strong) UIView *viewForLastBaselineLayout NS_AVAILABLE_IOS(9_0);UIKIT_EXTERN const CGFloat UIViewNoIntrinsicMetric NS_AVAILABLE_IOS(6_0); // -1// 返回接收对象的原本大小#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly) CGSize intrinsicContentSize NS_AVAILABLE_IOS(6_0);#else- (CGSize)intrinsicContentSize NS_AVAILABLE_IOS(6_0);#endif// 废除视图原本内容的size- (void)invalidateIntrinsicContentSize NS_AVAILABLE_IOS(6_0);// 设置当视图要变大时，视图的压缩改变方式，返回一个优先权（确定view有多大的优先级阻止自己变大）- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);// 设置放先权- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);// 设置当视图要变小时，视图的压缩改变方式，是水平缩小还是垂直缩小，并返回一个优先权（确定有多大的优先级阻止自己变小）- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);// 设置优先权- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);@end// Size To FitUIKIT_EXTERN const CGSize UILayoutFittingCompressedSize NS_AVAILABLE_IOS(6_0);UIKIT_EXTERN const CGSize UILayoutFittingExpandedSize NS_AVAILABLE_IOS(6_0);@interface UIView (UIConstraintBasedLayoutFittingSize)// 返回满足持有约束的视图的size- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize NS_AVAILABLE_IOS(6_0);// 返回满足它所包含的约束的视图的大小- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority NS_AVAILABLE_IOS(8_0);@end@interface UIView (UILayoutGuideSupport)// 此视图拥有布局向导对象的数组@property(nonatomic,readonly,copy) NSArray&lt;__kindof UILayoutGuide *&gt; *layoutGuides NS_AVAILABLE_IOS(9_0);// 向视图中添加布局向导- (void)addLayoutGuide:(UILayoutGuide *)layoutGuide NS_AVAILABLE_IOS(9_0);// 移除视图中的布局向导- (void)removeLayoutGuide:(UILayoutGuide *)layoutGuide NS_AVAILABLE_IOS(9_0);@end@class NSLayoutXAxisAnchor,NSLayoutYAxisAnchor,NSLayoutDimension;@interface UIView (UIViewLayoutConstraintCreation)// 布局视图的前缘框的布局锚点@property(readonly, strong) NSLayoutXAxisAnchor *leadingAnchor NS_AVAILABLE_IOS(9_0);// 布局视图的后缘边框的布局锚点@property(readonly, strong) NSLayoutXAxisAnchor *trailingAnchor NS_AVAILABLE_IOS(9_0);// 布局视图的左边框的布局锚点@property(readonly, strong) NSLayoutXAxisAnchor *leftAnchor NS_AVAILABLE_IOS(9_0);// 布局视图的右边框的布局锚点@property(readonly, strong) NSLayoutXAxisAnchor *rightAnchor NS_AVAILABLE_IOS(9_0);// 布局视图的顶边框的布局锚点@property(readonly, strong) NSLayoutYAxisAnchor *topAnchor NS_AVAILABLE_IOS(9_0);// 布局视图的底边框的布局锚点@property(readonly, strong) NSLayoutYAxisAnchor *bottomAnchor NS_AVAILABLE_IOS(9_0);// 布局视图的宽度@property(readonly, strong) NSLayoutDimension *widthAnchor NS_AVAILABLE_IOS(9_0);// 布局视图的高度@property(readonly, strong) NSLayoutDimension *heightAnchor NS_AVAILABLE_IOS(9_0);// 布局视图的水平中心轴@property(readonly, strong) NSLayoutXAxisAnchor *centerXAnchor NS_AVAILABLE_IOS(9_0);// 布局视图的垂直中心轴@property(readonly, strong) NSLayoutYAxisAnchor *centerYAnchor NS_AVAILABLE_IOS(9_0);// 一个代表对视图中的文本的最高线基线布置锚@property(readonly, strong) NSLayoutYAxisAnchor *firstBaselineAnchor NS_AVAILABLE_IOS(9_0);// 一个代表对视图中的文本的最低线基线布置锚@property(readonly, strong) NSLayoutYAxisAnchor *lastBaselineAnchor NS_AVAILABLE_IOS(9_0);@end@interface UIView (UIConstraintBasedLayoutDebugging)// 返回影响一个给定轴视图布局的约束- (NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraintsAffectingLayoutForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);// 视图的位置是否不完全指定#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly) BOOL hasAmbiguousLayout NS_AVAILABLE_IOS(6_0);#else- (BOOL)hasAmbiguousLayout NS_AVAILABLE_IOS(6_0);#endif// 在不同的有效值之间用一个模糊的布局随机改变视图的frame- (void)exerciseAmbiguityInLayout NS_AVAILABLE_IOS(6_0);@end@interface UILayoutGuide (UIConstraintBasedLayoutDebugging)// 返回对给定轴影响视图布局的约束- (NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraintsAffectingLayoutForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(10_0);// 确定影响视图布局的约束是否完全指定视图的位置#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly) BOOL hasAmbiguousLayout NS_AVAILABLE_IOS(10_0);#else- (BOOL)hasAmbiguousLayout NS_AVAILABLE_IOS(10_0);#endif@end@interface UIView (UIStateRestoration)// 该标示符决定该视图是否支持恢复状态@property (nullable, nonatomic, copy) NSString *restorationIdentifier NS_AVAILABLE_IOS(6_0);// 编码视图的状态信息- (void) encodeRestorableStateWithCoder:(NSCoder *)coder NS_AVAILABLE_IOS(6_0);// 解码一个视图状态信息- (void) decodeRestorableStateWithCoder:(NSCoder *)coder NS_AVAILABLE_IOS(6_0);@end@interface UIView (UISnapshotting)// 根据当前视图的内容返回快照视图- (nullable UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates NS_AVAILABLE_IOS(7_0);// 返回一个基于当前视图指定内容的快照视图，可插入- (nullable UIView *)resizableSnapshotViewFromRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates withCapInsets:(UIEdgeInsets)capInsets NS_AVAILABLE_IOS(7_0);// 呈现一个快照的完整视图层次可见屏幕为当前上下文- (BOOL)drawViewHierarchyInRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates NS_AVAILABLE_IOS(7_0);@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// 动画效果typedef NS_ENUM(NSInteger, UIViewAnimationCurve) &#123;UIViewAnimationCurveEaseInOut, // 淡入淡出UIViewAnimationCurveEaseIn, // 淡入UIViewAnimationCurveEaseOut, // 淡出UIViewAnimationCurveLinear,&#125;;// 视图内容风格typedef NS_ENUM(NSInteger, UIViewContentMode) &#123;UIViewContentModeScaleToFill, // 缩放内容到合适比例大小UIViewContentModeScaleAspectFit, // 缩放内容到合适的大小，边界多余部分透明UIViewContentModeScaleAspectFill, // 缩放内容填充到指定大小，边界多余的部分省略.UIViewContentModeRedraw, // 重绘视图边界 (需调用 -setNeedsDisplay)UIViewContentModeCenter, // 视图保持等比缩放UIViewContentModeTop, // 视图顶部对齐UIViewContentModeBottom, // 视图底部对齐UIViewContentModeLeft, // 视图左侧对齐UIViewContentModeRight, // 视图右侧对齐UIViewContentModeTopLeft, // 视图左上角对齐UIViewContentModeTopRight, // 视图右上角对齐UIViewContentModeBottomLeft, // 视图左下角对齐UIViewContentModeBottomRight, // 视图右下角对齐&#125;;// 过渡动画typedef NS_ENUM(NSInteger, UIViewAnimationTransition) &#123;UIViewAnimationTransitionNone, // 无UIViewAnimationTransitionFlipFromLeft, // 沿视图垂直中心轴左到右移动UIViewAnimationTransitionFlipFromRight, // 沿视图垂直中心轴右到左移动UIViewAnimationTransitionCurlUp, // 由底部向上卷起UIViewAnimationTransitionCurlDown, // 由顶部向下展开&#125;;// 视图布局typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;UIViewAutoresizingNone = 0, // 无UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, // 调整扩大或缩小左边间距UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, // 调整宽度UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, // 调整扩大或缩小右边间距UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, // 调整视图顶部间距UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, // 调整高度UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5 // 调整视图底部间距&#125;;// 动画选项typedef NS_OPTIONS(NSUInteger, UIViewAnimationOptions) &#123;UIViewAnimationOptionLayoutSubviews = 1 &lt;&lt; 0, // 子视图在指定的时间内完成在父视图上的自动UIViewAnimationOptionAllowUserInteraction = 1 &lt;&lt; 1, // 开启交互动画UIViewAnimationOptionBeginFromCurrentState = 1 &lt;&lt; 2, // 从当前值开始动画UIViewAnimationOptionRepeat = 1 &lt;&lt; 3, // 无限重复UIViewAnimationOptionAutoreverse = 1 &lt;&lt; 4, // 自动来回UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt; 5, // 忽略嵌套的动画的时间UIViewAnimationOptionOverrideInheritedCurve = 1 &lt;&lt; 6, // 忽略嵌套的路径动画UIViewAnimationOptionAllowAnimatedContent = 1 &lt;&lt; 7, // 只执行过渡动画UIViewAnimationOptionShowHideTransitionViews = 1 &lt;&lt; 8, // 隐藏或展示过渡动画视图UIViewAnimationOptionOverrideInheritedOptions = 1 &lt;&lt; 9, // 不继承任何动画类型// 同上UIViewAnimationOptionCurveEaseInOut = 0 &lt;&lt; 16, // defaultUIViewAnimationOptionCurveEaseIn = 1 &lt;&lt; 16,UIViewAnimationOptionCurveEaseOut = 2 &lt;&lt; 16,UIViewAnimationOptionCurveLinear = 3 &lt;&lt; 16,UIViewAnimationOptionTransitionNone = 0 &lt;&lt; 20, // defaultUIViewAnimationOptionTransitionFlipFromLeft = 1 &lt;&lt; 20,UIViewAnimationOptionTransitionFlipFromRight = 2 &lt;&lt; 20,UIViewAnimationOptionTransitionCurlUp = 3 &lt;&lt; 20,UIViewAnimationOptionTransitionCurlDown = 4 &lt;&lt; 20,UIViewAnimationOptionTransitionCrossDissolve = 5 &lt;&lt; 20,UIViewAnimationOptionTransitionFlipFromTop = 6 &lt;&lt; 20,UIViewAnimationOptionTransitionFlipFromBottom = 7 &lt;&lt; 20,&#125; NS_ENUM_AVAILABLE_IOS(4_0);// 关键帧动画typedef NS_OPTIONS(NSUInteger, UIViewKeyframeAnimationOptions) &#123;UIViewKeyframeAnimationOptionLayoutSubviews = UIViewAnimationOptionLayoutSubviews, // 子视图在指定的时间内完成在父视图上的自动布局的动画UIViewKeyframeAnimationOptionAllowUserInteraction = UIViewAnimationOptionAllowUserInteraction, // 开启交互动画UIViewKeyframeAnimationOptionBeginFromCurrentState = UIViewAnimationOptionBeginFromCurrentState, // 从当前值开始动画UIViewKeyframeAnimationOptionRepeat = UIViewAnimationOptionRepeat, // 无限重复UIViewKeyframeAnimationOptionAutoreverse = UIViewAnimationOptionAutoreverse, // 自动来回UIViewKeyframeAnimationOptionOverrideInheritedDuration = UIViewAnimationOptionOverrideInheritedDuration, // 忽略嵌套的动画的时间UIViewKeyframeAnimationOptionOverrideInheritedOptions = UIViewAnimationOptionOverrideInheritedOptions, // 不继承任何动画类型UIViewKeyframeAnimationOptionCalculationModeLinear = 0 &lt;&lt; 10, // defaultUIViewKeyframeAnimationOptionCalculationModeDiscrete = 1 &lt;&lt; 10,UIViewKeyframeAnimationOptionCalculationModePaced = 2 &lt;&lt; 10,UIViewKeyframeAnimationOptionCalculationModeCubic = 3 &lt;&lt; 10,UIViewKeyframeAnimationOptionCalculationModeCubicPaced = 4 &lt;&lt; 10&#125; NS_ENUM_AVAILABLE_IOS(7_0);typedef NS_ENUM(NSUInteger, UISystemAnimation) &#123;UISystemAnimationDelete, // 完成时从视图中删除&#125; NS_ENUM_AVAILABLE_IOS(7_0);// 色彩调整风格typedef NS_ENUM(NSInteger, UIViewTintAdjustmentMode) &#123;UIViewTintAdjustmentModeAutomatic, // 与父视图相同UIViewTintAdjustmentModeNormal, // 未经修改的UIViewTintAdjustmentModeDimmed, // 饱和、暗淡的原始色&#125; NS_ENUM_AVAILABLE_IOS(7_0);// 左右切换或左右布局typedef NS_ENUM(NSInteger, UISemanticContentAttribute) &#123;UISemanticContentAttributeUnspecified = 0, // 左右切换时视图翻转UISemanticContentAttributePlayback, // 音乐播放按钮设置，左右切换此视图不会翻转UISemanticContentAttributeSpatial, // 控件方向不能改变UISemanticContentAttributeForceLeftToRight, // 从左到右布局UISemanticContentAttributeForceRightToLeft // 从右到左布局&#125; NS_ENUM_AVAILABLE_IOS(9_0);// 约束布局中心线类型typedef NS_ENUM(NSInteger, UILayoutConstraintAxis) &#123;UILayoutConstraintAxisHorizontal = 0, // 以水平线为中心UILayoutConstraintAxisVertical = 1 // 以垂直线为中心&#125;;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UIApplication]]></title>
    <url>%2F2017%2F01%2F12%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIApplication%2F</url>
    <content type="text"><![CDATA[在iOS中UIApplication类提供一个集中点控制和协调应用程序的运行。每个APP都有一个UIApplication实例对象，当程序启动的时候通过调用UIApplicationMain方法，创建单例对象UIApplication。此后可以通过sharedApplication()可以得到方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349@protocol UIApplicationDelegate;@interface UIApplication : UIResponder#if UIKIT_DEFINE_AS_PROPERTIES@property(class, nonatomic, readonly) UIApplication *sharedApplication NS_EXTENSION_UNAVAILABLE_IOS("Use view controller based solutions where appropriate instead.");#else+ (UIApplication *)sharedApplication NS_EXTENSION_UNAVAILABLE_IOS("Use view controller based solutions where appropriate instead.");#endif@property(nullable, nonatomic, assign) id&lt;UIApplicationDelegate&gt; delegate;// 开始、结束响应事件- (void)beginIgnoringInteractionEvents NS_EXTENSION_UNAVAILABLE_IOS("");- (void)endIgnoringInteractionEvents NS_EXTENSION_UNAVAILABLE_IOS("");// 是否响应事件#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly, getter=isIgnoringInteractionEvents) BOOL ignoringInteractionEvents;#else- (BOOL)isIgnoringInteractionEvents;#endif// 屏幕长亮@property(nonatomic,getter=isIdleTimerDisabled) BOOL idleTimerDisabled; // default is NO// 打开URL资源- (BOOL)openURL:(NSURL*)url NS_DEPRECATED_IOS(2_0, 10_0, "Please use openURL:options:completionHandler: instead") NS_EXTENSION_UNAVAILABLE_IOS("");// 返回一个bool值， 是否从已经安装的 apps 中跳转- (BOOL)canOpenURL:(NSURL *)url NS_AVAILABLE_IOS(3_0);// 异步打开URL资源- (void)openURL:(NSURL*)url options:(NSDictionary&lt;NSString *, id&gt; *)options completionHandler:(void (^ __nullable)(BOOL success))completion NS_AVAILABLE_IOS(10_0) NS_EXTENSION_UNAVAILABLE_IOS("");// 发送事件给app内适用的响应者- (void)sendEvent:(UIEvent *)event;// app的主视图@property(nullable, nonatomic,readonly) UIWindow *keyWindow;// 隐藏和可见的所有window@property(nonatomic,readonly) NSArray&lt;__kindof UIWindow *&gt; *windows;// 发送一个含选择器的动作消息到指定的目标- (BOOL)sendAction:(SEL)action to:(nullable id)target from:(nullable id)sender forEvent:(nullable UIEvent *)event;// 是否在状态栏展示网络请求活动@property(nonatomic,getter=isNetworkActivityIndicatorVisible) BOOL networkActivityIndicatorVisible __TVOS_PROHIBITED; // default is NO// 获取状态栏的风格@property(readonly, nonatomic) UIStatusBarStyle statusBarStyle __TVOS_PROHIBITED;// 状态栏是否隐藏@property(readonly, nonatomic,getter=isStatusBarHidden) BOOL statusBarHidden __TVOS_PROHIBITED;// 当前状态栏的方向 @property(readonly, nonatomic) UIInterfaceOrientation statusBarOrientation __TVOS_PROHIBITED;// 实现代理设置屏幕支持的方向- (UIInterfaceOrientationMask)supportedInterfaceOrientationsForWindow:(nullable UIWindow *)window NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;// 获取旋转屏幕的时间@property(nonatomic,readonly) NSTimeInterval statusBarOrientationAnimationDuration __TVOS_PROHIBITED;// 获取状态栏的frame@property(nonatomic,readonly) CGRect statusBarFrame __TVOS_PROHIBITED;// 应用角标未读消息数字，设置0的时候隐藏，在iOS 8 必须注册后才能使用： -[UIApplication registerUserNotificationSettings:]@property(nonatomic) NSInteger applicationIconBadgeNumber;// 是否支持摇动手势@property(nonatomic) BOOL applicationSupportsShakeToEdit NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED;// 应用的运行状态@property(nonatomic,readonly) UIApplicationState applicationState NS_AVAILABLE_IOS(4_0);// 后台运行剩余时间@property(nonatomic,readonly) NSTimeInterval backgroundTimeRemaining NS_AVAILABLE_IOS(4_0);// 后台任务管理- (UIBackgroundTaskIdentifier)beginBackgroundTaskWithExpirationHandler:(void(^ __nullable)(void))handler NS_AVAILABLE_IOS(4_0) NS_REQUIRES_SUPER;- (UIBackgroundTaskIdentifier)beginBackgroundTaskWithName:(nullable NSString *)taskName expirationHandler:(void(^ __nullable)(void))handler NS_AVAILABLE_IOS(7_0) NS_REQUIRES_SUPER;- (void)endBackgroundTask:(UIBackgroundTaskIdentifier)identifier NS_AVAILABLE_IOS(4_0) NS_REQUIRES_SUPER;// 设置后台拉去数据的时间- (void)setMinimumBackgroundFetchInterval:(NSTimeInterval)minimumBackgroundFetchInterval NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED;// 获取后台刷新状态@property (nonatomic, readonly) UIBackgroundRefreshStatus backgroundRefreshStatus NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED;// 是否启用数据保护 YES：未启用@property(nonatomic,readonly,getter=isProtectedDataAvailable) BOOL protectedDataAvailable NS_AVAILABLE_IOS(4_0);// 返回界面的布局方向@property(nonatomic,readonly) UIUserInterfaceLayoutDirection userInterfaceLayoutDirection NS_AVAILABLE_IOS(5_0);// 返回字体大小@property(nonatomic,readonly) UIContentSizeCategory preferredContentSizeCategory NS_AVAILABLE_IOS(7_0);@end// 远程通知@interface UIApplication (UIRemoteNotifications)// 通过苹果推送通知注册接收远程通知服务- (void)registerForRemoteNotifications NS_AVAILABLE_IOS(8_0);// 注销远程通知服务- (void)unregisterForRemoteNotifications NS_AVAILABLE_IOS(3_0);// 应用是否注册了远程通知服务#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly, getter=isRegisteredForRemoteNotifications) BOOL registeredForRemoteNotifications NS_AVAILABLE_IOS(8_0);#else- (BOOL)isRegisteredForRemoteNotifications NS_AVAILABLE_IOS(8_0);#endif// 通过注册苹果的远程推送通知，接收指定类型的服务- (void)registerForRemoteNotificationTypes:(UIRemoteNotificationType)types NS_DEPRECATED_IOS(3_0, 8_0, "Use -[UIApplication registerForRemoteNotifications] and UserNotifications Framework's -[UNUserNotificationCenter requestAuthorizationWithOptions:completionHandler:]") __TVOS_PROHIBITED;// 返回应用通知的接收类型- (UIRemoteNotificationType)enabledRemoteNotificationTypes NS_DEPRECATED_IOS(3_0, 8_0, "Use -[UIApplication isRegisteredForRemoteNotifications] and UserNotifications Framework's -[UNUserNotificationCenter getNotificationSettingsWithCompletionHandler:] to retrieve user-enabled remote notification and user notification settings") __TVOS_PROHIBITED;@end// 本地通知@interface UIApplication (UILocalNotifications)// 立即呈现本地通知- (void)presentLocalNotificationNow:(UILocalNotification *)notification NS_DEPRECATED_IOS(4_0, 10_0, "Use UserNotifications Framework's -[UNUserNotificationCenter addNotificationRequest:withCompletionHandler:]") __TVOS_PROHIBITED;// 本地安排通知- (void)scheduleLocalNotification:(UILocalNotification *)notification NS_DEPRECATED_IOS(4_0, 10_0, "Use UserNotifications Framework's -[UNUserNotificationCenter addNotificationRequest:withCompletionHandler:]") __TVOS_PROHIBITED; // copies notification// 取消指定的本地通吃- (void)cancelLocalNotification:(UILocalNotification *)notification NS_DEPRECATED_IOS(4_0, 10_0, "Use UserNotifications Framework's -[UNUserNotificationCenter removePendingNotificationRequestsWithIdentifiers:]") __TVOS_PROHIBITED;// 取消所有的本地通知- (void)cancelAllLocalNotifications NS_DEPRECATED_IOS(4_0, 10_0, "Use UserNotifications Framework's -[UNUserNotificationCenter removeAllPendingNotificationRequests]") __TVOS_PROHIBITED;// 返回本地日程安排通知数组@property(nullable,nonatomic,copy) NSArray&lt;UILocalNotification *&gt; *scheduledLocalNotifications NS_DEPRECATED_IOS(4_0, 10_0, "Use UserNotifications Framework's -[UNUserNotificationCenter getPendingNotificationRequestsWithCompletionHandler:]") __TVOS_PROHIBITED;@end// 设置通知@class UIUserNotificationSettings;@interface UIApplication (UIUserNotificationSettings)// 注册通知- (void)registerUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings NS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;// 返回当前用户启用的通知#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly, nullable) UIUserNotificationSettings *currentUserNotificationSettings NS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;#else- (nullable UIUserNotificationSettings *)currentUserNotificationSettings NS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;#endif@end// 远程控制事件@interface UIApplication (UIRemoteControlEvents)// 开始接受远程遥控事件- (void)beginReceivingRemoteControlEvents NS_AVAILABLE_IOS(4_0);// 停止接受远程遥控事件- (void)endReceivingRemoteControlEvents NS_AVAILABLE_IOS(4_0);@end@interface UIApplication (UINewsstand)// 设置一个报摊的icon- (void)setNewsstandIconImage:(nullable UIImage *)image NS_DEPRECATED_IOS(5_0, 9_0, "Newsstand apps now behave like normal apps on SpringBoard") __TVOS_PROHIBITED;@end@class UIApplicationShortcutItem;// 管理3D Touch的快速操作@interface UIApplication (UIShortcutItems)// 主屏幕用户使用3D Touch功能的菜单数组@property (nullable, nonatomic, copy) NSArray&lt;UIApplicationShortcutItem *&gt; *shortcutItems NS_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED;@end// 管理恢复状态行为@protocol UIStateRestoring;@interface UIApplication (UIStateRestoration)// 正在恢复状态- (void)extendStateRestoration NS_AVAILABLE_IOS(6_0);// 恢复完成状态- (void)completeStateRestoration NS_AVAILABLE_IOS(6_0);// 防止应用在一个启动的声明周期使用最近的屏幕快照- (void)ignoreSnapshotOnNextApplicationLaunch NS_AVAILABLE_IOS(7_0);// 注册一个恢复状态对象的id+ (void)registerObjectForStateRestoration:(id&lt;UIStateRestoring&gt;)object restorationIdentifier:(NSString *)restorationIdentifier NS_AVAILABLE_IOS(7_0);@end#if UIKIT_STRING_ENUMStypedef NSString * UIApplicationLaunchOptionsKey NS_EXTENSIBLE_STRING_ENUM;#elsetypedef NSString * UIApplicationLaunchOptionsKey;#endif@protocol UIApplicationDelegate&lt;NSObject&gt;@optional// 应用生命周期// 应用启动完成执行- (void)applicationDidFinishLaunching:(UIApplication *)application;#if UIKIT_STRING_ENUMS// 应用启动进程已经开始，但部分状态没有完全恢复- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(nullable NSDictionary&lt;UIApplicationLaunchOptionsKey, id&gt; *)launchOptions NS_AVAILABLE_IOS(6_0);// 告诉代理启动基本完成程序准备开始运行（加载到窗口，可以看到）- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary&lt;UIApplicationLaunchOptionsKey, id&gt; *)launchOptions NS_AVAILABLE_IOS(3_0);#else- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions NS_AVAILABLE_IOS(6_0);- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions NS_AVAILABLE_IOS(3_0);#endif// 当应用程序回到激活状态执行 （回到窗口，可以看到)- (void)applicationDidBecomeActive:(UIApplication *)application;// 当应用程序将要进入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了- (void)applicationWillResignActive:(UIApplication *)application;// 请求委托打开由url标示的资源- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url NS_DEPRECATED_IOS(2_0, 9_0, "Please use application:openURL:options:") __TVOS_PROHIBITED;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(id)annotation NS_DEPRECATED_IOS(4_2, 9_0, "Please use application:openURL:options:") __TVOS_PROHIBITED;#if UIKIT_STRING_ENUMStypedef NSString * UIApplicationOpenURLOptionsKey NS_EXTENSIBLE_STRING_ENUM;#elsetypedef NSString * UIApplicationOpenURLOptionsKey;#endif// 请求委托打开由url标示的资源- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey, id&gt; *)options NS_AVAILABLE_IOS(9_0);// 接收来自系统内存警告- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application;// 当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要要设置- (void)applicationWillTerminate:(UIApplication *)application;// 重要时间的变化- (void)applicationSignificantTimeChange:(UIApplication *)application; // midnight, carrier time update, daylight savings time change// 当状态栏的方向即将要发生改变时执行- (void)application:(UIApplication *)application willChangeStatusBarOrientation:(UIInterfaceOrientation)newStatusBarOrientation duration:(NSTimeInterval)duration __TVOS_PROHIBITED;// 当状态栏的方向发生改变时执行- (void)application:(UIApplication *)application didChangeStatusBarOrientation:(UIInterfaceOrientation)oldStatusBarOrientation __TVOS_PROHIBITED;// 当状态栏的frame即将要发生改变时执行- (void)application:(UIApplication *)application willChangeStatusBarFrame:(CGRect)newStatusBarFrame __TVOS_PROHIBITED; // in screen coordinates// 当状态栏的frame发生改变时执行- (void)application:(UIApplication *)application didChangeStatusBarFrame:(CGRect)oldStatusBarFrame __TVOS_PROHIBITED;// 处理本地和远程通知// 注册本地或远程通知类型- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings NS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;// 远程推送通知注册成功回调- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken NS_AVAILABLE_IOS(3_0);// 无法成功注册推送通知服务回调- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error NS_AVAILABLE_IOS(3_0);// 收到远程推送通知执行- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo NS_DEPRECATED_IOS(3_0, 10_0, "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate willPresentNotification:withCompletionHandler:] or -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:] for user visible notifications and -[UIApplicationDelegate application:didReceiveRemoteNotification:fetchCompletionHandler:] for silent remote notifications");// 收到本地推送通知执行- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification NS_DEPRECATED_IOS(4_0, 10_0, "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate willPresentNotification:withCompletionHandler:] or -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]") __TVOS_PROHIBITED;// 当应用被激活时，处理用户从本地推送通知中选择操作的事件- (void)application:(UIApplication *)application handleActionWithIdentifier:(nullable NSString *)identifier forLocalNotification:(UILocalNotification *)notification completionHandler:(void(^)())completionHandler NS_DEPRECATED_IOS(8_0, 10_0, "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]") __TVOS_PROHIBITED;// 当应用被激活时，处理用户从远程推送通知中选择操作的事件- (void)application:(UIApplication *)application handleActionWithIdentifier:(nullable NSString *)identifier forRemoteNotification:(NSDictionary *)userInfo withResponseInfo:(NSDictionary *)responseInfo completionHandler:(void(^)())completionHandler NS_DEPRECATED_IOS(9_0, 10_0, "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]") __TVOS_PROHIBITED;- (void)application:(UIApplication *)application handleActionWithIdentifier:(nullable NSString *)identifier forRemoteNotification:(NSDictionary *)userInfo completionHandler:(void(^)())completionHandler NS_DEPRECATED_IOS(8_0, 10_0, "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]") __TVOS_PROHIBITED;- (void)application:(UIApplication *)application handleActionWithIdentifier:(nullable NSString *)identifier forLocalNotification:(UILocalNotification *)notification withResponseInfo:(NSDictionary *)responseInfo completionHandler:(void(^)())completionHandler NS_DEPRECATED_IOS(9_0, 10_0, "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]") __TVOS_PROHIBITED;// 一个远程通知到达，表明有数据要获取- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler NS_AVAILABLE_IOS(7_0);// 如果有有数据下载，它可以开始获取操作- (void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED;// 主屏幕3D Touch快捷选项操作启动应用执行- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void(^)(BOOL succeeded))completionHandler NS_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED;// 与URL有关的事件正等待处理- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler NS_AVAILABLE_IOS(7_0);// 相应Watch的配对请求- (void)application:(UIApplication *)application handleWatchKitExtensionRequest:(nullable NSDictionary *)userInfo reply:(void(^)(NSDictionary * __nullable replyInfo))reply NS_AVAILABLE_IOS(8_2);// 应用将要获取用户健康数据时调用- (void)applicationShouldRequestHealthAuthorization:(UIApplication *)application NS_AVAILABLE_IOS(9_0);// 当程序被推送到后台的时候调用- (void)applicationDidEnterBackground:(UIApplication *)application NS_AVAILABLE_IOS(4_0);// 当程序将要被推送到前台的时候调用- (void)applicationWillEnterForeground:(UIApplication *)application NS_AVAILABLE_IOS(4_0);// 保护文件不可用- (void)applicationProtectedDataWillBecomeUnavailable:(UIApplication *)application NS_AVAILABLE_IOS(4_0);// 保护文件可用- (void)applicationProtectedDataDidBecomeAvailable:(UIApplication *)application NS_AVAILABLE_IOS(4_0);// 呈现的故事版@property (nullable, nonatomic, strong) UIWindow *window NS_AVAILABLE_IOS(5_0);// 应用视图支持的方向- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(nullable UIWindow *)window NS_AVAILABLE_IOS(6_0) __TVOS_PROHIBITED;#if UIKIT_STRING_ENUMStypedef NSString * UIApplicationExtensionPointIdentifier NS_EXTENSIBLE_STRING_ENUM;#elsetypedef NSString * UIApplicationExtensionPointIdentifier;#endif// 将要扩展的指定标识符的应用- (BOOL)application:(UIApplication *)application shouldAllowExtensionPointIdentifier:(UIApplicationExtensionPointIdentifier)extensionPointIdentifier NS_AVAILABLE_IOS(8_0);#pragma mark -- State Restoration protocol adopted by UIApplication delegate --// 提供指定视图控制器- (nullable UIViewController *) application:(UIApplication *)application viewControllerWithRestorationIdentifierPath:(NSArray *)identifierComponents coder:(NSCoder *)coder NS_AVAILABLE_IOS(6_0);// 是否保存应用的状态信息 ↓- (BOOL) application:(UIApplication *)application shouldSaveApplicationState:(NSCoder *)coder NS_AVAILABLE_IOS(6_0);// 是否恢复应用保存的状态信息 ↑- (BOOL) application:(UIApplication *)application shouldRestoreApplicationState:(NSCoder *)coder NS_AVAILABLE_IOS(6_0);// 处理保存高级状态的信息- (void) application:(UIApplication *)application willEncodeRestorableStateWithCoder:(NSCoder *)coder NS_AVAILABLE_IOS(6_0);// 恢复一部分保存的高级状态的信息- (void) application:(UIApplication *)application didDecodeRestorableStateWithCoder:(NSCoder *)coder NS_AVAILABLE_IOS(6_0);#pragma mark -- User Activity Continuation protocol adopted by UIApplication delegate --// 当活动比预期时间长的时候，是否继续通知- (BOOL)application:(UIApplication *)application willContinueUserActivityWithType:(NSString *)userActivityType NS_AVAILABLE_IOS(8_0);// 告诉继续活动期间数据是否可用- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void(^)(NSArray * __nullable restorableObjects))restorationHandler NS_AVAILABLE_IOS(8_0);// 应用注册远程推送通知失败时激发该方法- (void)application:(UIApplication *)application didFailToContinueUserActivityWithType:(NSString *)userActivityType error:(NSError *)error NS_AVAILABLE_IOS(8_0);// 更新活动- (void)application:(UIApplication *)application didUpdateUserActivity:(NSUserActivity *)userActivity NS_AVAILABLE_IOS(8_0);#pragma mark -- CloudKit Sharing Invitation Handling --// 同意接受云共享请求- (void) application:(UIApplication *)application userDidAcceptCloudKitShareWithMetadata:(CKShareMetadata *)cloudKitShareMetadata NS_AVAILABLE_IOS(10_0);@end@interface UIApplication(UIApplicationDeprecated)// 获取状态栏的方向@property(readwrite, nonatomic) UIInterfaceOrientation statusBarOrientation NS_DEPRECATED_IOS(2_0, 9_0, "Explicit setting of the status bar orientation is more limited in iOS 6.0 and later") __TVOS_PROHIBITED;// 设置状态栏的方向- (void)setStatusBarOrientation:(UIInterfaceOrientation)interfaceOrientation animated:(BOOL)animated NS_DEPRECATED_IOS(2_0, 9_0, "Explicit setting of the status bar orientation is more limited in iOS 6.0 and later") __TVOS_PROHIBITED;// 当前状态栏的样式@property(readwrite, nonatomic) UIStatusBarStyle statusBarStyle NS_DEPRECATED_IOS(2_0, 9_0, "Use -[UIViewController preferredStatusBarStyle]") __TVOS_PROHIBITED;// 设置状态栏的样式- (void)setStatusBarStyle:(UIStatusBarStyle)statusBarStyle animated:(BOOL)animated NS_DEPRECATED_IOS(2_0, 9_0, "Use -[UIViewController preferredStatusBarStyle]") __TVOS_PROHIBITED;// 当前状态栏是否隐藏@property(readwrite, nonatomic,getter=isStatusBarHidden) BOOL statusBarHidden NS_DEPRECATED_IOS(2_0, 9_0, "Use -[UIViewController prefersStatusBarHidden]") __TVOS_PROHIBITED;// 隐藏状态栏- (void)setStatusBarHidden:(BOOL)hidden withAnimation:(UIStatusBarAnimation)animation NS_DEPRECATED_IOS(3_2, 9_0, "Use -[UIViewController prefersStatusBarHidden]") __TVOS_PROHIBITED;// 设置后台停留时间- (BOOL)setKeepAliveTimeout:(NSTimeInterval)timeout handler:(void(^ __nullable)(void))keepAliveHandler NS_DEPRECATED_IOS(4_0, 9_0, "Please use UIRemoteNotificationTypeVoIP remote notifications for VoIP applications") __TVOS_PROHIBITED;// 清除后台停留时间- (void)clearKeepAliveTimeout NS_DEPRECATED_IOS(4_0, 9_0, "Please use UIRemoteNotificationTypeVoIP remote notifications for VoIP applications") __TVOS_PROHIBITED;@end// 创建应用程序的主要入口UIKIT_EXTERN int UIApplicationMain(int argc, char *argv[], NSString * __nullable principalClassName, NSString * __nullable delegateClassName);// 省略一部分全局变量@end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 状态栏风格typedef NS_ENUM(NSInteger, UIStatusBarStyle) &#123;UIStatusBarStyleDefault = 0, // 黑色，用于亮的背景UIStatusBarStyleLightContent NS_ENUM_AVAILABLE_IOS(7_0) = 1, // 白色，用于深色背景UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, "Use UIStatusBarStyleLightContent") = 1,UIStatusBarStyleBlackOpaque NS_ENUM_DEPRECATED_IOS(2_0, 7_0, "Use UIStatusBarStyleLightContent") = 2,&#125; __TVOS_PROHIBITED;// 状态栏动画效果typedef NS_ENUM(NSInteger, UIStatusBarAnimation) &#123;UIStatusBarAnimationNone, // 无UIStatusBarAnimationFade NS_ENUM_AVAILABLE_IOS(3_2), // 褪去UIStatusBarAnimationSlide NS_ENUM_AVAILABLE_IOS(3_2), // 滑出&#125; __TVOS_PROHIBITED;// 支持屏幕旋转的方向// UIDeviceOrientation：是机器硬件的当前旋转方向，这个你只能取值，不能设置// UIInterfaceOrientation：是你程序界面的当前旋转方向，这个可以设置typedef NS_ENUM(NSInteger, UIInterfaceOrientation) &#123;UIInterfaceOrientationUnknown = UIDeviceOrientationUnknown, // 不支持屏幕旋转UIInterfaceOrientationPortrait = UIDeviceOrientationPortrait, // 支持旋转UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown, // 旋转180°UIInterfaceOrientationLandscapeLeft = UIDeviceOrientationLandscapeRight, // 顺时针 向右旋转90°UIInterfaceOrientationLandscapeRight = UIDeviceOrientationLandscapeLeft // 逆时针旋转 向左旋转90°&#125; __TVOS_PROHIBITED;// 设置屏幕支持旋转的方向typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) &#123;UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait),UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft), // 向左旋转90°UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight), // 向右旋转90°UIInterfaceOrientationMaskPortraitUpsideDown = (1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown), // 旋转180°UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), // 向左右旋转即横屏UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown), // 支持任意方向旋转UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), // 除旋转180°所有方向&#125; __TVOS_PROHIBITED;// 判断旋转是否有效#define UIDeviceOrientationIsValidInterfaceOrientation(orientation) ((UIDeviceOrientation)(orientation) == UIDeviceOrientationPortrait || (UIDeviceOrientation)(orientation) == UIDeviceOrientationPortraitUpsideDown || (UIDeviceOrientation)(orientation) == UIDeviceOrientationLandscapeLeft || (UIDeviceOrientation)(orientation) == UIDeviceOrientationLandscapeRight)// 屏幕是否横屏static inline BOOL UIInterfaceOrientationIsPortrait(UIInterfaceOrientation orientation) __TVOS_PROHIBITED &#123;return ((orientation) == UIInterfaceOrientationPortrait || (orientation) == UIInterfaceOrientationPortraitUpsideDown);&#125;// 屏幕是否竖屏static inline BOOL UIInterfaceOrientationIsLandscape(UIInterfaceOrientation orientation) __TVOS_PROHIBITED &#123;return ((orientation) == UIInterfaceOrientationLandscapeLeft || (orientation) == UIInterfaceOrientationLandscapeRight);&#125;// 注册远程通知 角标、声音、提示typedef NS_OPTIONS(NSUInteger, UIRemoteNotificationType) &#123;UIRemoteNotificationTypeNone = 0,UIRemoteNotificationTypeBadge = 1 &lt;&lt; 0,UIRemoteNotificationTypeSound = 1 &lt;&lt; 1,UIRemoteNotificationTypeAlert = 1 &lt;&lt; 2,UIRemoteNotificationTypeNewsstandContentAvailability = 1 &lt;&lt; 3,&#125; NS_ENUM_DEPRECATED_IOS(3_0, 8_0, "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead.") __TVOS_PROHIBITED;// 后台处理拉取数据结果类型typedef NS_ENUM(NSUInteger, UIBackgroundFetchResult) &#123;UIBackgroundFetchResultNewData, // 成功拉去数据UIBackgroundFetchResultNoData, // 没有数据UIBackgroundFetchResultFailed // 拉出数据失败或超时&#125; NS_ENUM_AVAILABLE_IOS(7_0);// 后台刷新状态typedef NS_ENUM(NSInteger, UIBackgroundRefreshStatus) &#123;UIBackgroundRefreshStatusRestricted, // 受限制UIBackgroundRefreshStatusDenied, // 被拒绝UIBackgroundRefreshStatusAvailable // 可用&#125; NS_ENUM_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED;// app 运行状态typedef NS_ENUM(NSInteger, UIApplicationState) &#123;UIApplicationStateActive, // 在前台运行UIApplicationStateInactive, // 待激活状态：锁屏、下拉看通知、任务管理UIApplicationStateBackground // 在后台运行：按下home键&#125; NS_ENUM_AVAILABLE_IOS(4_0);// 任务标示typedef NSUInteger UIBackgroundTaskIdentifier;// 设置无效的任务UIKIT_EXTERN const UIBackgroundTaskIdentifier UIBackgroundTaskInvalid NS_AVAILABLE_IOS(4_0);// 后台保持的最小时间UIKIT_EXTERN const NSTimeInterval UIMinimumKeepAliveTimeout NS_AVAILABLE_IOS(4_0);// 请求的最小间隔(刷新最频繁)UIKIT_EXTERN const NSTimeInterval UIApplicationBackgroundFetchIntervalMinimum NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED;// 请求的最大间隔，阻止请求(不刷新)UIKIT_EXTERN const NSTimeInterval UIApplicationBackgroundFetchIntervalNever NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—UIResponder]]></title>
    <url>%2F2017%2F01%2F11%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIResponder%2F</url>
    <content type="text"><![CDATA[在iOS中UIResponder类是专门用来响应用户的操作处理各种事件的，包括触摸事件(Touch Events)、运动事件(Motion Events)、远程控制事件(Remote Control Events,如插入耳机调节音量触发的事件)。我们知道UIApplication、UIView、UIViewController这几个类是直接继承自UIResponder,UIWindow是直接继承自UIView的一个特殊的View,所以这些类都可以响应事件。当然我们自定义的继承自UIView的View以及自定义的继承自UIViewController的控制器都可以响应事件。iOS里面通常将这些能响应事件的对象称之为响应者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157@protocol UIResponderStandardEditActions@optional// 剪切、拷贝、粘贴、选择、全选、删除事件- (void)cut:(nullable id)sender NS_AVAILABLE_IOS(3_0);- (void)copy:(nullable id)sender NS_AVAILABLE_IOS(3_0);- (void)paste:(nullable id)sender NS_AVAILABLE_IOS(3_0);- (void)select:(nullable id)sender NS_AVAILABLE_IOS(3_0);- (void)selectAll:(nullable id)sender NS_AVAILABLE_IOS(3_0);- (void)delete:(nullable id)sender NS_AVAILABLE_IOS(3_2);// 从左到右写入字符串(居左)- (void)makeTextWritingDirectionLeftToRight:(nullable id)sender NS_AVAILABLE_IOS(5_0);// 从右到左写入字符串(居右)- (void)makeTextWritingDirectionRightToLeft:(nullable id)sender NS_AVAILABLE_IOS(5_0);// 切换字体为黑体(粗体)- (void)toggleBoldface:(nullable id)sender NS_AVAILABLE_IOS(6_0);// 切换字体为斜体- (void)toggleItalics:(nullable id)sender NS_AVAILABLE_IOS(6_0);// 给文字添加下划线- (void)toggleUnderline:(nullable id)sender NS_AVAILABLE_IOS(6_0);// 增加字体大小- (void)increaseSize:(nullable id)sender NS_AVAILABLE_IOS(7_0);// 减小字体大小- (void)decreaseSize:(nullable id)sender NS_AVAILABLE_IOS(7_0);@endNS_CLASS_AVAILABLE_IOS(2_0) @interface UIResponder : NSObject &lt;UIResponderStandardEditActions&gt;// 返回接收者的下一个相应@property(nonatomic, readonly, nullable) UIResponder *nextResponder;// 判断一个对象是否可以成为第一响应者。默认返回NO@property(nonatomic, readonly) BOOL canBecomeFirstResponder; // default is NO// 接收者接受了第一响应者的状态就返回YES，拒绝了这个状态就返回NO。默认返回YES- (BOOL)becomeFirstResponder;// 对象是否可以放弃第一响应者。默认返回YES@property(nonatomic, readonly) BOOL canResignFirstResponder; // default is YES// 是否放弃第一响应者- (BOOL)resignFirstResponder;// 判断一个对象是否是第一响应者@property(nonatomic, readonly) BOOL isFirstResponder;// 通知接收者有触摸事件开始 （手指开始接触屏幕）- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;// 通知接收者有触摸事件位置移动 （手指移动）- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;// 通知接收者有触摸事件结束 （手指离开屏幕）- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;// 通知接收者意外中断触摸事件 (电话打扰)- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;// 通知接收者3D触摸事件- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);// 按压事件开始- (void)pressesBegan:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);// 按压事件的位置移动- (void)pressesChanged:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);// 结束按压事件- (void)pressesEnded:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);// 按压事件中断- (void)pressesCancelled:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);// 开始加速- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);// 结束加速- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);// 加速中断- (void)motionCancelled:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);// 远程控制事件- (void)remoteControlReceivedWithEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(4_0);// 可以执行的事件 （UIMenuController的操作事件）- (BOOL)canPerformAction:(SEL)action withSender:(nullable id)sender NS_AVAILABLE_IOS(3_0);// 返回响应的操作目标对象- (nullable id)targetForAction:(SEL)action withSender:(nullable id)sender NS_AVAILABLE_IOS(7_0);// 返回响应链就近共享撤消管理@property(nullable, nonatomic,readonly) NSUndoManager *undoManager NS_AVAILABLE_IOS(3_0);//响应者支持的快捷键typedef NS_OPTIONS(NSInteger,UIKeyModifierFlags) &#123;UIKeyModifierAlphaShift = 1 &lt;&lt;16, // Alppha+Shift键UIKeyModifierShift = 1 &lt;&lt;17, //Shift键UIKeyModifierControl = 1 &lt;&lt;18, //Control键UIKeyModifierAlternate = 1 &lt;&lt;19, //Alt键UIKeyModifierCommand = 1 &lt;&lt;20, //Command键UIKeyModifierNumericPad = 1 &lt;&lt;21, //Num键&#125;NS_ENUM_AVAILABLE_IOS(7_0);NS_CLASS_AVAILABLE_IOS(7_0) @interface UIKeyCommand : NSObject &lt;NSCopying, NSSecureCoding&gt;- (instancetype)init NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;// 输入字符串@property (nonatomic,readonly) NSString *input;// 按键调节器@property (nonatomic,readonly) UIKeyModifierFlags modifierFlags;// 按指定调节器键输入字符串并设置事件@property (nullable,nonatomic,copy) NSString *discoverabilityTitle NS_AVAILABLE_IOS(9_0);// The action for UIKeyCommands should accept a single (id)sender, as do the UIResponderStandardEditActions above// Creates an key command that will _not_ be discoverable in the UI.+ (UIKeyCommand *)keyCommandWithInput:(NSString *)input modifierFlags:(UIKeyModifierFlags)modifierFlags action:(SEL)action;// Key Commands with a discoverabilityTitle _will_ be discoverable in the UI.+ (UIKeyCommand *)keyCommandWithInput:(NSString *)input modifierFlags:(UIKeyModifierFlags)modifierFlags action:(SEL)action discoverabilityTitle:(NSString *)discoverabilityTitle NS_AVAILABLE_IOS(9_0);@end@interface UIResponder (UIResponderKeyCommands)// 组合快捷键命令(装有多个按键的数组)@property (nullable,nonatomic,readonly) NSArray&lt;UIKeyCommand *&gt; *keyCommands NS_AVAILABLE_IOS(7_0); // returns an array of UIKeyCommand objects&lt;@end@class UIInputViewController;@class UITextInputMode;@class UITextInputAssistantItem;@interface UIResponder (UIResponderInputViewAdditions)// 键盘输入视图(系统默认的,可以自定义)@property (nullable, nonatomic, readonly, strong) __kindof UIView *inputView NS_AVAILABLE_IOS(3_2);// 弹出键盘时附带的视图 第一响应者的附件View，在becomeFirstResponder时会在键盘的顶端显示自定义的inputAccessoryView@property (nullable, nonatomic, readonly, strong) __kindof UIView *inputAccessoryView NS_AVAILABLE_IOS(3_2);// 输入助手配置键盘的快捷方式栏时使用@property (nonnull, nonatomic, readonly, strong) UITextInputAssistantItem *inputAssistantItem NS_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED __WATCHOS_PROHIBITED;// 键盘输入视图控制器@property (nullable, nonatomic, readonly, strong) UIInputViewController *inputViewController NS_AVAILABLE_IOS(8_0);// 弹出键盘时附带的视图的视图控制器@property (nullable, nonatomic, readonly, strong) UIInputViewController *inputAccessoryViewController NS_AVAILABLE_IOS(8_0);// 文本输入响应的对象@property (nullable, nonatomic, readonly, strong) UITextInputMode *textInputMode NS_AVAILABLE_IOS(7_0);// 标识符表示该响应应保留其文本输入方式的信息@property (nullable, nonatomic, readonly, strong) NSString *textInputContextIdentifier NS_AVAILABLE_IOS(7_0);// 清除从应用程序的用户默认文本输入模式的信息+ (void)clearTextInputContextIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(7_0);// 如果成为第一响应者，将会重新加载inputView、inputAccesoryView和textInputMode，否则忽略- (void)reloadInputViews NS_AVAILABLE_IOS(3_2);@end// 这是一些预定义的UIKeyCommand对象使用的输入属性，按键输入箭头指向UIKIT_EXTERN NSString *const UIKeyInputUpArrow NS_AVAILABLE_IOS(7_0);UIKIT_EXTERN NSString *const UIKeyInputDownArrow NS_AVAILABLE_IOS(7_0);UIKIT_EXTERN NSString *const UIKeyInputLeftArrow NS_AVAILABLE_IOS(7_0);UIKIT_EXTERN NSString *const UIKeyInputRightArrow NS_AVAILABLE_IOS(7_0);UIKIT_EXTERN NSString *const UIKeyInputEscape NS_AVAILABLE_IOS(7_0);@interface UIResponder (ActivityContinuation)// 用户活动@property (nullable, nonatomic, strong) NSUserActivity *userActivity NS_AVAILABLE_IOS(8_0);// 更新用户活动- (void)updateUserActivityState:(NSUserActivity *)activity NS_AVAILABLE_IOS(8_0);// 恢复用户活动- (void)restoreUserActivityState:(NSUserActivity *)activity NS_AVAILABLE_IOS(8_0);@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习—NSObject]]></title>
    <url>%2F2017%2F01%2F11%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94NSObject%2F</url>
    <content type="text"><![CDATA[Objective-C中有两个NSObject，一个是NSObject类，另一个是NSObject协议。而其中NSObject类采用了NSObject协议。本文整理一下NSObject类的API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105@protocol NSObject// 比较两个对象的地址是否相等- (BOOL)isEqual:(id)object;// 如果isEqual判断两个对象相等，那么两个对象的hash返回值也一定相等。反之hsah值相等，isEqual未必认为两者一样@property (readonly) NSUInteger hash;// 父类类对象@property (readonly) Class superclass;// 本类类对象- (Class)class OBJC_SWIFT_UNAVAILABLE("use 'anObject.dynamicType' instead");// 对象本身- (instancetype)self;// 调用Selector方法（带参数和不带参数）- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;// 判断一个实例是否继承自NSObject，如果返回NO就是继承自NSObject，反之返回YES- (BOOL)isProxy;// 判断对象是否属于aClass及其子类- (BOOL)isKindOfClass:(Class)aClass;// 判断对象是否属于aClass类- (BOOL)isMemberOfClass:(Class)aClass;// 判断对象是否遵守了aProtocol协议- (BOOL)conformsToProtocol:(Protocol *)aProtocol;// 判断对象是否能响应aSelector方法- (BOOL)respondsToSelector:(SEL)aSelector;// 保留内存 内存引用个数加1- (instancetype)retain OBJC_ARC_UNAVAILABLE;// 释放内存 内存引用个数减1- (oneway void)release OBJC_ARC_UNAVAILABLE;// 自动释放内存- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;// 保留的内存计数个数- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;// 分配存储空间- (struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;// 对象的内容的字符串@property (readonly, copy) NSString *description;// debug下对象的内容的字符串@property (readonly, copy) NSString *debugDescription;@interface NSObject// 类的头文件被引入就会调用+ (void)load;// 类或其子类的第一个方法被调用之前调用+ (void)initialize;// 初始化- (instancetype)init;// 初始化并创建一个对象+ (instancetype)new OBJC_SWIFT_UNAVAILABLE("use object initializers instead");// alloc方法内部调用该方法，返回分配的存储空间zone+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE("use object initializers instead");// 分配存储空间+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE("use object initializers instead");// 对象销毁时执行- (void)dealloc OBJC_SWIFT_UNAVAILABLE("use 'deinit' to define a de-initializer");// 内存回收- (void)finalize OBJC_DEPRECATED("Objective-C garbage collection is no longer supported");// 拷贝对象方法 （不可变操作）- (id)copy;// 深拷贝对象方法 （可变操作）- (id)mutableCopy;// 拷贝类方法+ (id)copyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;// 深拷贝类方法+ (id)mutableCopyWithZone:(struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;// 判断类是否能响应aSelector方法+ (BOOL)instancesRespondToSelector:(SEL)aSelector;// 判断类是否遵守protocol协议+ (BOOL)conformsToProtocol:(Protocol *)protocol;// 根据一个SEL，得到该方法的IMP（函数指针）- (IMP)methodForSelector:(SEL)aSelector;// 根据一个SEL，返回类方法的IMP（函数指针）+ (IMP)instanceMethodForSelector:(SEL)aSelector;// 处理接收者无法识别的消息- (void)doesNotRecognizeSelector:(SEL)aSelector;// 当某个对象不能接受某个selector时，将对该selector的调用转发给另一个对象- (id)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0);// 重定向消息- (void)forwardInvocation:(NSInvocation *)anInvocation OBJC_SWIFT_UNAVAILABLE("");// 获取方法签名的信息 和forwardInvocation:方法配合使用- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE("");// 获取实例方法签名的信息+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector OBJC_SWIFT_UNAVAILABLE("");// 是否允许弱引用- (BOOL)allowsWeakReference UNAVAILABLE_ATTRIBUTE;// 是否保留弱引用- (BOOL)retainWeakReference UNAVAILABLE_ATTRIBUTE;// 查看一个类是否是另一个类的子类+ (BOOL)isSubclassOfClass:(Class)aClass;// 动态解析一个类方法+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0);// 动态解析一个实例方法+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0);// 返回类的hash值+ (NSUInteger)hash;// 获取接收者的父类+ (Class)superclass;// 返回类对象+ (Class)class OBJC_SWIFT_UNAVAILABLE("use 'aClass.self' instead");// 类的内容的字符串+ (NSString *)description;// debug类的内容的字符串+ (NSString *)debugDescription;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境搭建本地服务器]]></title>
    <url>%2F2017%2F01%2F11%2FMAC-%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言在工作中我有时候会用到本地搭建服务器测试环境，如果你是使用Mac的小伙伴，那么使用起来就非常简单了，因为Mac自带Apache和PHP环境，当然也可以不用系统自带的，下面将一一介绍： Mac自带Apache自带Apache常用命令如下：1234567891011// 查看 Apache 版本$ httpd -v// 启动 Apache$ sudo apachectl start// 停止 Apache$ sudo apachectl stop// 重启 Apachesudo $ sudo apachectl restart 使用步骤： 执行sudo apachectl start开启服务器 在浏览器中输入http://localhost看到It Works!说明启动成功 把自己网站的文件丢进/Library/WebServer/Documents就可以调试了 调试完毕后执行sudo apachectl stop关闭服务器 Mac自带PHP 编辑 /etc/apache2/httpd.conf文件，找到 LoadModule php5_module libexec/apache2/libphp5.so 并删除行前的注释符号 #。 接下来就和上面的操作相同了 Apache Tomcat安装使用 在http://tomcat.apache.org下载tomcat 9.X系列zip包 下载完成以后，本地解压缩完成以后，在该目录下的webapps目录下，新建movie目录 在movie目录下创建movies.xml文件 打开文件，写入内容 返还到上一级，将bin目录下的所有的文件的权限设置成775,执行chmod -R 775 ./bin命令 在终端进入bin目录下，运行./startup.sh文件开启服务器 在浏览器(非Safari)中,输入http://localhost:8080/movie/movies.xml,如果可以看到文件内容，则成功调试 注意事项：在使用完成以后，仍然需要在终端进入bin目录下，运行./shutdown.sh文件关闭服务器,否则内存会溢出，机器死机。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIKit框架学习]]></title>
    <url>%2F2017%2F01%2F11%2FiOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言一直想系统的学习UIKit框架，但总有种种借口没能开始。从今天开始将一步一步的学习UIKit框架。 目的 巩固基础知识 了解一些平时没有用到的方法和属性 以便日后使用时查阅 学习路线]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS ATS / 非HTTPS被禁问题]]></title>
    <url>%2F2017%2F01%2F11%2FiOS-ATS-%E9%9D%9EHTTPS%E8%A2%AB%E7%A6%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言自iOS 9起苹果就开始推荐使用HTTPS，在iOS 9中默认是禁止非HTTPS的协议来访问网络的，但是还是给我我们缓冲的机会，解决方法: 在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为YES。 2016年6月WWDC之后，便传出从2017年1月1日起苹果提出所有新提交的App不允许使用NSAllowsArbitraryLoads来绕过ATS的限制，也就是说强制我们用HTTPS，如果不这样的话提交App可能会被拒绝。在2016年即将结束之际，我们也网站和APP也开始支持HTTPS的工作，但是之前也有传言说2017年1月1日App Store不会强制支持HTTPS，事实确实如此，下面苹果官网的一条公告： Supporting App Transport SecurityApp Transport Security (ATS), introduced in iOS 9 and OS X v10.11, improves user security and privacy by requiring apps to use secure network connections over HTTPS. At WWDC 2016 we announced that apps submitted to the App Store will be required to support ATS at the end of the year. To give you additional time to prepare, this deadline has been extended and we will provide another update when a new deadline is confirmed. Learn more about ATS. 不管怎么说我们还是要支持HTTPS，原因三点： iOS客户端强制支持HTTPS以后是必然的趋势 HTTPS协议解决了很多客户端和服务端安全问题 领导们很关注，一直跟进服务端客户端的HTTPS的适配工作 问题描述 问题一：一些第三方的SDK并没有及时支持HTTPS我们怎么解决呢？ 问题二：如何知道哪些接口是非HTTPS的呢？ 解决办法问题一：把一些不支持HTTPS的第三方接口添加NSExceptionDomains白名单中，配置如下： 在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity中添加NSExceptionDomains类型Dictionary。 在NSExceptionDomains中添加要支持的域（也就是非HTTPS的接口地址），域作为Key，类型为Dictionary。 在每个域下面添加三个Boolean类型的属性，如下： 123456789101112131415&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt;&lt;key&gt;NSExceptionDomains&lt;/key&gt;&lt;dict&gt;&lt;key&gt;qq.com&lt;/key&gt;&lt;dict&gt;&lt;key&gt;NSIncludesSubdomains&lt;/key&gt;&lt;true/&gt;&lt;key&gt;NSExceptionRequiresForwardSecrecy&lt;/key&gt;&lt;false/&gt;&lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt;&lt;true/&gt;&lt;/dict&gt;&lt;/dict&gt;&lt;/dict&gt; 问题二： 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为YES，调试找到非HTTPS接口后记得改成NO。 使用Charles抓包，详细使用教程请查看：Charles 从入门到精通 把抓到的一些非HTTPS的接口添加到白名单中，添加方法请看问题一解决办法 注意事项 1、抓包的时候发现有些图片的地址是非HTTPS的，也会导致图片无法显示，把地址添加到白名单中即可或协调服务端进行修改。2、友盟统计、友盟分享、百度地图等SDK现已支持HTTPS记得更新哦。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础语法介绍]]></title>
    <url>%2F2016%2F01%2F17%2FMarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。 本文转自@younghz主要内容 Markdown是什么？谁发明了这么个东西？为什么要使用它？怎么使用？都谁在用？感觉有意思？不怕你看见，就怕你试试 正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。 2. 谁发明了这么个东西？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历： 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案居然被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 [图片上传失败…(image-df8c0f-1513321604812)] 天才都有早逝的归途（又是一位犹太人）。 3. 为什么要使用它？ 它是易读（看起开舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰的组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 4. 怎么使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。 废话太多，下面正文，Markdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。 4.1 标题两种形式：1）使用=和-标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 2）使用#，可表示1-6级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 4.3 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： > 区块引用>&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){ printf(“Hello, Markdown.”);} 代码区块： void main() { printf(&quot;Hello, Markdown.&quot;); } 注意:需要和普通段落之间存在空行。 4.5 强调在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，斜体粗体，粗体 4.6 列表使用·、+、或-标记无序列表，如： -（+*） 第一项-（+*） 第二项- （+*）第三项 注意：标记后面最少有一个空格或制表符。若不在引用区块中，必须和前方段落之间存在空行。 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项2 . 第二项3 . 第三项 效果： 第一项 第二项 第三项 4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 4.8 链接链接可以由两种形式生成：行内式和参考式。行内式： [younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。 效果： younghz的Markdown库。 参考式： [younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https:://github.com/younghz/Markdown “Markdown”[2]:https:://github.com/younghz/Markdown “Markdown” 效果： younghz的Markdown库1younghz的Markdown库2 注意：上述的[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;不出现在区块中。 4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 [站外图片上传中……(2)][站外图片上传中……(3)] 4.10 反斜杠\相当于反转义作用。使符号成为普通符号。 4.11 符号’`’起到标记作用。如： `ctrl+a` 效果： ctrl+a 4.12 页内跳转写了一篇很长的文章，要是没有目录的话，查找起来很麻烦，这个时候有个页内跳转功能就方便了许多：（简书不支持此语法） [返回顶部](#1) 返回顶部 效果： 返回顶部 5. 都谁在用？Markdown的使用者： GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 6. 感觉有意思？趁热打铁，推荐几个工具。 Chrome下的stackedit插件可以离线使用，很爽。也不用担心平台受限。在线的dillinger.io算是评价好的了，可是不能离线使用。 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。推荐。 Linux下的ReText不错。 其实在对语法了如于心的话，直接用编辑器就可以了，脑子里满满的都是格式化好的文本啊。我现在使用马克飞象 + Markdown-here，先编辑好，然后一键格式化，挺方便。 注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/)。 以上基本是所有traditonal markdown的语法。 其它：列表的使用(非traditonal markdown)： 用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。 代码库 链接 MarkDown https://github.com/younghz/Markdown moos-young https://github.com/younghz/moos-young 关于其它扩展语法可参见具体工具的使用说明。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
