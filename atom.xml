<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wynter</title>
  
  <subtitle>不甘平庸，就别懒惰</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wynter.wang/"/>
  <updated>2018-07-26T00:58:11.786Z</updated>
  <id>https://wynter.wang/</id>
  
  <author>
    <name>Wynter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac 制作一个可执行脚本</title>
    <link href="https://wynter.wang/2018/07/25/Mac%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
    <id>https://wynter.wang/2018/07/25/Mac制作一个可执行脚本/</id>
    <published>2018-07-25T11:13:16.000Z</published>
    <updated>2018-07-26T00:58:11.786Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中我们经常会用到一些命令来完成指定工作，最常用的还是Git和SVN一些更新、提交操作，虽然命令不是很复杂，但是肯定会有三个步骤：</p><p>1、打开终端；<br>2、cd到指定目录下；<br>3、执行一系列相关操作命令。</p><p>一些常用的操作我们就可以制作一个脚本来简化步骤。</p><a id="more"></a><h3 id="制作一个可执行脚本，分为以下步骤："><a href="#制作一个可执行脚本，分为以下步骤：" class="headerlink" title="制作一个可执行脚本，分为以下步骤："></a>制作一个可执行脚本，分为以下步骤：</h3><ul><li><p>创建脚本文件，在终端中执行（文件想要保存在哪里在那个目录下执行命令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch fileName.sh</div></pre></td></tr></table></figure></li><li><p>给脚本添加可执行权限，具体可以参考<a href="https://www.jianshu.com/p/40ae805472bc" target="_blank" rel="noopener">Mac 修改文件读写权限</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 755 fileName.sh</div></pre></td></tr></table></figure></li><li><p>使用终端cd到脚本所在目录执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./fileName.sh</div></pre></td></tr></table></figure></li></ul><h3 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h3><p>以下是我正在使用一个简易脚本，可以用它来实现：</p><p>1、将写好的博客生成静态文件并部署<br>2、备份博客所有文件到git，防止本地文件丢失</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">！ /bin/bash</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> dirname <span class="variable">$0</span>，取得当前执行的脚本文件的父目录</span></div><div class="line">basepath=$(cd `dirname $0`; pwd)</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash">进入到hexo所在的目录</span></div><div class="line">cd $&#123;basepath&#125;/Wynter.github.io</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 打印当前路径</span></div><div class="line">currentPath=$(pwd)</div><div class="line">echo "当前文件夹路径: $currentPath"</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 生成静态文件并部署</span></div><div class="line">echo "start update hexo"</div><div class="line">hexo d -g</div><div class="line">echo "end hexo"</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 返回到上级目录</span></div><div class="line">cd ..</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 拉去git上最新数据</span></div><div class="line">git pull</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 备份博客所有文件到git</span></div><div class="line">echo "start update git"</div><div class="line">git add .</div><div class="line">git commit -m "update blog"</div><div class="line">git push origin master</div><div class="line">date=$(date +%Y%m%d%H%M)</div></pre></td></tr></table></figure><p>在iOS应用开发完成后，经常要使用Xcode打包给测试人员，不仅编译时间长，期间还不能敲代码，编译完成后还需要手动导入，发给测试人员等一系列操作，这完全可以使用脚本来实现来提升工作效率。</p><p>附上一个<a href="https://github.com/stackhou/AutoPacking-iOS" target="_blank" rel="noopener">iOS自动打包脚本传送门</a>。</p><h3 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h3><p><strong>既然都是脚本，为什么还要在终端里<code>./fileName.sh</code>才能执行，这so不智能了吧！为什么不能双击执行呢？</strong></p><p>它的确是可执行脚本，因为脚本的后缀是.sh，而我们的mac中刚好有应用能识别并打开.sh结尾的文件，如果删除电脑上所有能识别.sh的应用，再次双击脚本就直接执行脚本了。<br><br>显然删除这么多应用是不现实的，我们可以在创建的时候不给文件添加后缀来实现双击执行脚本的目的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以说没有什么操作是一个脚本解决不了的，如果解决不了那就再来一个。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在工作中我们经常会用到一些命令来完成指定工作，最常用的还是Git和SVN一些更新、提交操作，虽然命令不是很复杂，但是肯定会有三个步骤：&lt;/p&gt;
&lt;p&gt;1、打开终端；&lt;br&gt;2、cd到指定目录下；&lt;br&gt;3、执行一系列相关操作命令。&lt;/p&gt;
&lt;p&gt;一些常用的操作我们就可以制作一个脚本来简化步骤。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://wynter.wang/categories/blog/"/>
    
    
      <category term="Linux" scheme="https://wynter.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>iOS 自定义-苹方字体的使用</title>
    <link href="https://wynter.wang/2018/05/11/iOS%20%E8%87%AA%E5%AE%9A%E4%B9%89-%E8%8B%B9%E6%96%B9%E5%AD%97%E4%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://wynter.wang/2018/05/11/iOS 自定义-苹方字体的使用/</id>
    <published>2018-05-11T06:13:02.000Z</published>
    <updated>2018-06-08T07:44:22.097Z</updated>
    
    <content type="html"><![CDATA[<p>不是系统已经自带苹方字体了为什么还要自定义呢？因为苹方字体是在iOS 9引入的，所以如果要支持iOS 9以下都要手动引入苹方字体。<br><a id="more"></a></p><h2 id="添加苹方字体到项目中"><a href="#添加苹方字体到项目中" class="headerlink" title="添加苹方字体到项目中"></a>添加苹方字体到项目中</h2><ul><li><p>获取苹方字体，Command+G输入<code>/System/Library/Fonts/PingFang.ttc</code></p></li><li><p>直接拖到将PingFang.ttc文件拖到项目中</p></li><li><p>在 info.plist文件中添加<code>Fonts provided by application</code>，并设置字体包名称<br><img src="https://upload-images.jianshu.io/upload_images/937490-b46bb7fd12d74358.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加设置字体"></p></li></ul><blockquote><p>我在iOS 8系统的模拟器中没有在Info.plist中添加<code>Fonts provided by application</code>，也已经可以正常使用苹方字体了</p></blockquote><h2 id="获取当前系统支持的字体"><a href="#获取当前系统支持的字体" class="headerlink" title="获取当前系统支持的字体"></a>获取当前系统支持的字体</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *fontFamilyName <span class="keyword">in</span> <span class="built_in">UIFont</span>.familyNames) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"familyName:%@"</span>, fontFamilyName);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *fontName <span class="keyword">in</span> [<span class="built_in">UIFont</span> fontNamesForFamilyName:fontFamilyName]) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"fontName:%@"</span>, fontName);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">打印结果省略了苹方字体以外的字体</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> ……</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.217401+0800 QYLY[5900:238352] familyName:PingFang TC</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.218150+0800 QYLY[5900:238352] fontName:PingFangTC-Regular</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.218609+0800 QYLY[5900:238352] fontName:PingFangTC-Thin</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.219340+0800 QYLY[5900:238352] fontName:PingFangTC-Medium</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.220841+0800 QYLY[5900:238352] fontName:PingFangTC-Semibold</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.222403+0800 QYLY[5900:238352] fontName:PingFangTC-Light</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.223328+0800 QYLY[5900:238352] fontName:PingFangTC-Ultralight</span></div><div class="line"><span class="comment"> ……</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.299506+0800 QYLY[5900:238352] familyName:PingFang HK</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.300103+0800 QYLY[5900:238352] fontName:PingFangHK-Medium</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.300944+0800 QYLY[5900:238352] fontName:PingFangHK-Thin</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.301597+0800 QYLY[5900:238352] fontName:PingFangHK-Regular</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.302162+0800 QYLY[5900:238352] fontName:PingFangHK-Ultralight</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.302652+0800 QYLY[5900:238352] fontName:PingFangHK-Semibold</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.303029+0800 QYLY[5900:238352] fontName:PingFangHK-Light</span></div><div class="line"><span class="comment"> ……</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.423305+0800 QYLY[5900:238352] familyName:PingFang SC</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.423714+0800 QYLY[5900:238352] fontName:PingFangSC-Medium</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.424151+0800 QYLY[5900:238352] fontName:PingFangSC-Semibold</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.424397+0800 QYLY[5900:238352] fontName:PingFangSC-Light</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.424621+0800 QYLY[5900:238352] fontName:PingFangSC-Ultralight</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.424934+0800 QYLY[5900:238352] fontName:PingFangSC-Regular</span></div><div class="line"><span class="comment"> 2018-04-28 11:07:52.425314+0800 QYLY[5900:238352] fontName:PingFangSC-Thin</span></div><div class="line"><span class="comment"> ……</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><p>苹方字体怎么会有PingFang SC、PingFang TC、PingFang HK三种呢？对应的是苹方-简、苹方-繁、苹方-港，而且都有六种字重，具体可以在字体册中查看。</p><blockquote><p>苹方-简 中黑体 PingFangSC-Medium<br>苹方-简 中粗体 PingFangSC-Semibold<br>苹方-简 细体 PingFangSC-Light<br>苹方-简 极细体 PingFangSC-Ultralight<br>苹方-简 常规体 PingFangSC-Regular<br>苹方-简 纤细体 PingFangSC-Thin<br><img src="https://upload-images.jianshu.io/upload_images/937490-5afaf5974290fddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字体册-苹方"></p></blockquote><h2 id="设置苹方字体"><a href="#设置苹方字体" class="headerlink" title="设置苹方字体"></a>设置苹方字体</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 苹方字体，默认为PingFangSC-Regular</span></div><div class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"PingFangSC-Regular"</span> size:<span class="number">14</span>];</div><div class="line"><span class="built_in">NSString</span> *familyName = font.familyName;</div><div class="line"><span class="built_in">NSString</span> *fontName = font.fontName;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"familyName:%@\nfontName:%@"</span>, familyName, fontName);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> familyName:PingFang SC</span></div><div class="line"><span class="comment"> fontName:PingFangSC-Regular</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>每次都要输入字体名称比较麻烦，并且还要支持iOS 9以下，使用分类方法比较好。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, FontWeightStyle) &#123;</div><div class="line">    FontWeightStyleMedium, <span class="comment">// 中黑体</span></div><div class="line">    FontWeightStyleSemibold, <span class="comment">// 中粗体</span></div><div class="line">    FontWeightStyleLight, <span class="comment">// 细体</span></div><div class="line">    FontWeightStyleUltralight, <span class="comment">// 极细体</span></div><div class="line">    FontWeightStyleRegular, <span class="comment">// 常规体</span></div><div class="line">    FontWeightStyleThin, <span class="comment">// 纤细体</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIFont</span> (<span class="title">Ex</span>)</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> 苹方字体</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> @param fontWeight 字体粗细（字重)</span></div><div class="line"><span class="comment"> @param fontSize 字体大小</span></div><div class="line"><span class="comment"> @return 返回指定字重大小的苹方字体</span></div><div class="line"><span class="comment"> */</span></div><div class="line">+ (<span class="built_in">UIFont</span> *)pingFangSCWithWeight:(FontWeightStyle)fontWeight size:(<span class="built_in">CGFloat</span>)fontSize;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIFont+Ex.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIFont</span> (<span class="title">Ex</span>)</span></div><div class="line"></div><div class="line">+ (<span class="built_in">UIFont</span> *)pingFangSCWithWeight:(FontWeightStyle)fontWeight size:(<span class="built_in">CGFloat</span>)fontSize &#123;</div><div class="line">    <span class="keyword">if</span> (fontWeight &lt; FontWeightStyleMedium || fontWeight &gt; FontWeightStyleThin) &#123;</div><div class="line">        fontWeight = FontWeightStyleRegular;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *fontName = <span class="string">@"PingFangSC-Regular"</span>;</div><div class="line">    <span class="keyword">switch</span> (fontWeight) &#123;</div><div class="line">        <span class="keyword">case</span> FontWeightStyleMedium:</div><div class="line">            fontName = <span class="string">@"PingFangSC-Medium"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> FontWeightStyleSemibold:</div><div class="line">            fontName = <span class="string">@"PingFangSC-Semibold"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> FontWeightStyleLight:</div><div class="line">            fontName = <span class="string">@"PingFangSC-Light"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> FontWeightStyleUltralight:</div><div class="line">            fontName = <span class="string">@"PingFangSC-Ultralight"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> FontWeightStyleRegular:</div><div class="line">            fontName = <span class="string">@"PingFangSC-Regular"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> FontWeightStyleThin:</div><div class="line">            fontName = <span class="string">@"PingFangSC-Thin"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> fontWithName:fontName size:fontSize];</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> font ?: [<span class="built_in">UIFont</span> systemFontOfSize:fontSize];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不是系统已经自带苹方字体了为什么还要自定义呢？因为苹方字体是在iOS 9引入的，所以如果要支持iOS 9以下都要手动引入苹方字体。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="blog" scheme="https://wynter.wang/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>SVN命令使用汇总</title>
    <link href="https://wynter.wang/2018/05/11/SVN%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%B1%87%E6%80%BB/"/>
    <id>https://wynter.wang/2018/05/11/SVN命令使用汇总/</id>
    <published>2018-05-11T06:13:02.000Z</published>
    <updated>2018-06-08T07:46:21.880Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下SVN使用中一些常用命令及示例。<br><a id="more"></a></p><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn import 本地文件路径 http://server/项目路径 --username=用户名 --password=密码 -m "批注"</div></pre></td></tr></table></figure><p>例如：<br>svn import /Users/Wynter/Desktop/项目目录 <a href="http://server/项目路径" target="_blank" rel="noopener">http://server/项目路径</a> –username=Wynter –password=Wynter -m “import”</p><h3 id="下载项目到本地"><a href="#下载项目到本地" class="headerlink" title="下载项目到本地"></a>下载项目到本地</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn checkout 服务器项目路径 -username=用户名 --password=密码 本地项目路径</div><div class="line">svn co</div></pre></td></tr></table></figure><p>例如：<br>svn checkout <a href="http://server/项目路径" target="_blank" rel="noopener">http://server/项目路径</a> –username=Wynter –password=Wynter /Users/Wynter/Desktop/本地项目路径</p><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn add  file </div><div class="line">svn add .</div></pre></td></tr></table></figure><p>例如：<br>svn add test.txt(添加test.txt)<br>svn add *.php(添加当前目录下所有的php文件)<br>svn add . （添加当前目录下所有文件)</p><h3 id="提交添加的文件，或者本地做的修改提交到版本库"><a href="#提交添加的文件，或者本地做的修改提交到版本库" class="headerlink" title="提交添加的文件，或者本地做的修改提交到版本库"></a>提交添加的文件，或者本地做的修改提交到版本库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn commit -m "批注" [-N] [--no-unlock] path(如果选择了保持锁，就使用–no-unlock开关) </div><div class="line">svn ci -m "批注"</div></pre></td></tr></table></figure><p>例如：<br>svn ci -m “add test.txt by test”</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn delete path -m "批注" </div><div class="line">svn (del, remove, rm)  path -m "批注"</div></pre></td></tr></table></figure><p>例如：<br>svn delete <a href="https://server/项目目录/test.text" target="_blank" rel="noopener">https://server/项目目录/test.text</a> -m “删除test.text 文件”<br>svn delete /Users/Wynter/本地项目目录 -m “删除目录”</p><h3 id="更新最新版本或指定版本"><a href="#更新最新版本或指定版本" class="headerlink" title="更新最新版本或指定版本"></a>更新最新版本或指定版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">svn update</div><div class="line">svn update -r 回滚到的版本号</div><div class="line">svn up</div></pre></td></tr></table></figure><p>例如：<br>svn update  （如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本）<br>svn update -r 200 test.txt    (更新指定的版本)</p><blockquote><p>注意：<br>如果在提交的时候提示过期的话，是因为冲突，需要先 svn update，修改文件，然后清除svn resolved，最后再提交 svn ci -m “”</p></blockquote><h3 id="查看本地修改的文件状态"><a href="#查看本地修改的文件状态" class="headerlink" title="查看本地修改的文件状态"></a>查看本地修改的文件状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn status</div><div class="line">svn st</div></pre></td></tr></table></figure><p>例如：<br>svn status path（目录下的文件和子目录的状态，正常状态不显示）<br>【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】</p><p>svn status -v path(显示文件和子目录状态)<br>第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。</p><h3 id="下载不带版本控制的项目到本地（没有svn隐藏记录信息）"><a href="#下载不带版本控制的项目到本地（没有svn隐藏记录信息）" class="headerlink" title="下载不带版本控制的项目到本地（没有svn隐藏记录信息）"></a>下载不带版本控制的项目到本地（没有svn隐藏记录信息）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn export 服务器项目路径 -username=用户名 --password=密码 本地项目路径</div></pre></td></tr></table></figure><p>例如：<br>svn export <a href="http://server/项目路径" target="_blank" rel="noopener">http://server/项目路径</a> –username=Wynter –password=Wynter /Users/Wynter/Desktop/本地项目目录</p><h3 id="加锁-解锁"><a href="#加锁-解锁" class="headerlink" title="加锁/解锁"></a>加锁/解锁</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn lock path </div><div class="line">svn unlock path</div></pre></td></tr></table></figure><p>例如：<br>svn lock /Users/Wynter/Desktop/本地项目目录（或文件名）－m “批注”<br>svn unlock /Users/Wynter/Desktop/本地项目目录（或文件名）</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn log path</div></pre></td></tr></table></figure><p>例如：<br>svn log /Users/Wynter/Desktop/本地项目目录/test.txt </p><h3 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">svn diff path(将修改的文件与基础版本比较) </div><div class="line">svn diff -r m:n path (对版本m和版本n比较差异)</div><div class="line">svn di</div></pre></td></tr></table></figure><p>例如：<br>svn diff text.txt<br>svn diff -r 200:201 text.txt  </p><h3 id="合并两个版本"><a href="#合并两个版本" class="headerlink" title="合并两个版本"></a>合并两个版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn merge -r m:n path</div></pre></td></tr></table></figure><p>例如：<br>svn merge -r 12:14 text.txt  (把版本12和14之间的差异合并到当前的文件中)</p><h3 id="冲突合并"><a href="#冲突合并" class="headerlink" title="冲突合并"></a>冲突合并</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn resolved path  （移除工作副本的目录或文件的"冲突"状态）</div></pre></td></tr></table></figure><p>例如：<br>svn resolve test.txt</p><h3 id="恢复本地修改"><a href="#恢复本地修改" class="headerlink" title="恢复本地修改"></a>恢复本地修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn revert  file path</div><div class="line">svn revert -R path</div></pre></td></tr></table></figure><p>例如：<br>svn revert test.text<br>svn revert -r /Users/Wynter/Desktop/本地项目目录</p><h3 id="复制一个项目（打标签-打分支）"><a href="#复制一个项目（打标签-打分支）" class="headerlink" title="复制一个项目（打标签/打分支）"></a>复制一个项目（打标签/打分支）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">svn copy 原地址URL 目标地址URL -m "批注"</div><div class="line">svn copy . 目标地址 -m "批注" (必须要原地址目录下)</div><div class="line">svn cp</div></pre></td></tr></table></figure><p>例如：<br>svn copy <a href="http://server/项目路径/branch/IPM" target="_blank" rel="noopener">http://server/项目路径/branch/IPM</a>  <a href="http://server/项目路径/tag/IPM_V1" target="_blank" rel="noopener">http://server/项目路径/tag/IPM_V1</a> -m “在分支中打个tag”<br>svn copy . <a href="http://server/项目路径/tag/tag目录目录" target="_blank" rel="noopener">http://server/项目路径/tag/tag目录目录</a> -m “在分支中打个tag”</p><h3 id="合并代码"><a href="#合并代码" class="headerlink" title="合并代码"></a>合并代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn merge -r m:n path</div></pre></td></tr></table></figure><p>例如：<br>合并文件：<br>svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件）</p><p>主干合并到分支<br>cd branch<br>svn merge <a href="http://server/trunk" target="_blank" rel="noopener">http://server/trunk</a> </p><p>分支合并到主干<br>cd trunk<br>svn merge –reintegrate <a href="http://server/branchs/IPM_V1_1" target="_blank" rel="noopener">http://server/branchs/IPM_V1_1</a> </p><p>合并版本并将合并后的结果应用到现有的分支上<br>svn merge -r 200:205 <a href="http://server/trunk" target="_blank" rel="noopener">http://server/trunk</a></p><h3 id="代码库URL变更"><a href="#代码库URL变更" class="headerlink" title="代码库URL变更"></a>代码库URL变更</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">svn switch &lt;branch_full_url&gt;   (切换分支)</div><div class="line">svn switch --relocate &lt;from_url&gt; &lt;to_url&gt; [path]  (切换资源库)</div><div class="line">svn sw</div></pre></td></tr></table></figure><p>例如：<br>svn switch <a href="http://server/branchs/IPM_V1_1" target="_blank" rel="noopener">http://server/branchs/IPM_V1_1</a><br>svn sw –relocate <a href="http://old_server/项目目录" target="_blank" rel="noopener">http://old_server/项目目录</a> <a href="http://new_server/项目目录" target="_blank" rel="noopener">http://new_server/项目目录</a></p><h3 id="svn帮助"><a href="#svn帮助" class="headerlink" title="svn帮助"></a>svn帮助</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn help</div><div class="line">svn help commit</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下SVN使用中一些常用命令及示例。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="API" scheme="https://wynter.wang/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>iOS 模型数组深拷贝</title>
    <link href="https://wynter.wang/2018/05/11/iOS%20%E6%A8%A1%E5%9E%8B%E6%95%B0%E7%BB%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://wynter.wang/2018/05/11/iOS 模型数组深拷贝/</id>
    <published>2018-05-11T06:13:02.000Z</published>
    <updated>2018-06-08T07:43:26.389Z</updated>
    
    <content type="html"><![CDATA[<p>通常需要实现对模型的拷贝都需要先实现<code>NSCopying、 NSMutableCopying</code>协议，在这里我一直有个误区，以为实现了copy协议，数组使用拷贝操作都会对数组内实现copy协议的对象进行拷贝。<br><a id="more"></a></p><h3 id="创建两个model并实现copying协议"><a href="#创建两个model并实现copying协议" class="headerlink" title="创建两个model并实现copying协议"></a>创建两个model并实现copying协议</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dog.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// Dog.m</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone &#123;</div><div class="line">    Dog *<span class="keyword">copy</span> = [[Dog allocWithZone:zone]init];</div><div class="line">    <span class="keyword">copy</span>.name = <span class="keyword">self</span>.name;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">copy</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</div><div class="line">    Dog *<span class="keyword">copy</span> = [[Dog allocWithZone:zone]init];</div><div class="line">    <span class="keyword">copy</span>.name = <span class="keyword">self</span>.name;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">copy</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Person.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"Dog.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) Dog *dog;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// Person.m</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone &#123;</div><div class="line">    Person *<span class="keyword">copy</span> = [[Person allocWithZone:zone]init];</div><div class="line">    <span class="keyword">copy</span>.name = <span class="keyword">self</span>.name;</div><div class="line">    <span class="keyword">copy</span>.age = <span class="keyword">self</span>.age;</div><div class="line">    <span class="keyword">copy</span>.dog = [<span class="keyword">self</span>.dog <span class="keyword">copy</span>];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">copy</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</div><div class="line">    Person *<span class="keyword">copy</span> = [[Person allocWithZone:zone]init];</div><div class="line">    <span class="keyword">copy</span>.name = <span class="keyword">self</span>.name;</div><div class="line">    <span class="keyword">copy</span>.age = <span class="keyword">self</span>.age;</div><div class="line">    <span class="keyword">copy</span>.dog = [<span class="keyword">self</span>.dog <span class="keyword">copy</span>];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">copy</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><h3 id="对模型数组使用mutablCopy操作并不是深拷贝"><a href="#对模型数组使用mutablCopy操作并不是深拷贝" class="headerlink" title="对模型数组使用mutablCopy操作并不是深拷贝"></a>对模型数组使用mutablCopy操作并不是深拷贝</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> &lt;Person *&gt;*dataSourceAry = [<span class="built_in">NSMutableArray</span> new];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">    Dog *dog = [[Dog alloc]init];</div><div class="line">    dog.name = <span class="string">@"拉不拉多不多就拉倒"</span>;</div><div class="line">    </div><div class="line">    Person *item = [[Person alloc]init];</div><div class="line">    item.name = <span class="string">@"杰克"</span>;</div><div class="line">    item.age = <span class="number">18</span>;</div><div class="line">    item.dog = [dog <span class="keyword">copy</span>];</div><div class="line">    [dataSourceAry addObject:item];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> &lt;Person *&gt;*array = [dataSourceAry mutableCopy];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"&lt;dataSourceAry: %@&gt;"</span>, dataSourceAry);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"&lt;array: %@&gt;"</span>, array);</div><div class="line"></div><div class="line"></div><div class="line">[array enumerateObjectsUsingBlock:^(Person *obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">    obj.name = <span class="string">@"肉丝"</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"dataSourceAry[0].name = %@"</span>, dataSourceAry[<span class="number">0</span>].name);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"array[0].name = %@"</span>, array[<span class="number">0</span>].name);</div><div class="line"></div><div class="line"><span class="comment">/** 打印结果</span></div><div class="line"><span class="comment"> &lt;dataSourceAry: ("&lt;Person: 0x60000043ec00&gt;", "&lt;Person: 0x60000043e9c0&gt;")&gt;</span></div><div class="line"><span class="comment"> &lt;array: ("&lt;Person: 0x60000043ec00&gt;","&lt;Person: 0x60000043e9c0&gt;")&gt;</span></div><div class="line"><span class="comment"> dataSourceAry[0].name = 肉丝</span></div><div class="line"><span class="comment"> array[0].name = 肉丝</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><p>可以从打印的结果看出，数组内元素的内存地址是相同的，所以出现了修改拷贝后数组的第一个元素，导致原数组的第一个元素也发生了同样的改变。虽然两个数组的内存地址不一样，但是内部元素内存地址还是同一地址，不是我们想要的结果。</p><h3 id="实现模型数组深拷贝的方法"><a href="#实现模型数组深拷贝的方法" class="headerlink" title="实现模型数组深拷贝的方法"></a>实现模型数组深拷贝的方法</h3><p>1、最笨的方法就是通过遍历逐个拷贝元素<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">for</span> (Person *person <span class="keyword">in</span> dataSourceAry) &#123;</div><div class="line">    [array addObject:[person <span class="keyword">copy</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2、也有人使用归档解档实现数组内部元素拷贝</p><p>3、这么好用的一个方法现在才发现（推荐）</p><p>flag=YES当模型数组内元素对象遵守了copy协议，数组元素对象才能进行深拷贝。数组元素对象没有遵守copy协议或者flag=NO，则会进行浅拷贝<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithArray:(<span class="built_in">NSArray</span>&lt;ObjectType&gt; *)array copyItems:(<span class="built_in">BOOL</span>)flag</div></pre></td></tr></table></figure></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> &lt;Person *&gt;*deepCopyAry = [[<span class="built_in">NSArray</span> alloc]initWithArray:dataSourceAry copyItems:<span class="literal">YES</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"&lt;dataSourceAry: %@&gt;"</span>, dataSourceAry);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"&lt;deepCopyAry: %@&gt;"</span>, deepCopyAry);</div><div class="line">    </div><div class="line">[deepCopyAry enumerateObjectsUsingBlock:^(Person *obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">    obj.name = <span class="string">@"弗兰克"</span>;</div><div class="line">    obj.dog.name = <span class="string">@"弗兰克的dog"</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"dataSourceAry[0].name = %@"</span>, dataSourceAry[<span class="number">0</span>].name);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"deepCopyAry[0].name = %@"</span>, deepCopyAry[<span class="number">0</span>].name);</div><div class="line">    </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"dataSourceAry[0].dog.name = %@"</span>, dataSourceAry[<span class="number">0</span>].dog.name);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"deepCopyAry[0].dog.name = %@"</span>, deepCopyAry[<span class="number">0</span>].dog.name);</div><div class="line">    </div><div class="line"><span class="comment">/** 打印结果</span></div><div class="line"><span class="comment">&lt;dataSourceAry: ("&lt;Person: 0x604000427680&gt;", "&lt;Person: 0x604000425220&gt;")&gt;</span></div><div class="line"><span class="comment">&lt;deepCopyAry: ("&lt;Person: 0x60000042cb80&gt;", "&lt;Person: 0x60000042cae0&gt;")&gt;</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">dataSourceAry[0].name = 肉丝</span></div><div class="line"><span class="comment">deepCopyAry[0].name = 弗兰克</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">dataSourceAry[0].dog.name = 拉不拉多不多就拉倒</span></div><div class="line"><span class="comment">deepCopyAry[0].dog.name = 弗兰克的dog</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、模型数组内元素中模型必须要实现copy协议，模型内如果有嵌套模型，也需要实现copy协议，否则执行对对象拷贝操作会出现崩溃；<br>2、使用<code>- (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array copyItems:(BOOL)flag</code>实现模型数组拷贝；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常需要实现对模型的拷贝都需要先实现&lt;code&gt;NSCopying、 NSMutableCopying&lt;/code&gt;协议，在这里我一直有个误区，以为实现了copy协议，数组使用拷贝操作都会对数组内实现copy协议的对象进行拷贝。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="blog" scheme="https://wynter.wang/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>iOS 使用AFNetworking传输字符串</title>
    <link href="https://wynter.wang/2018/05/11/iOS%20%E4%BD%BF%E7%94%A8AFNetworking%E4%BC%A0%E8%BE%93%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://wynter.wang/2018/05/11/iOS 使用AFNetworking传输字符串/</id>
    <published>2018-05-11T06:13:02.000Z</published>
    <updated>2018-06-08T07:43:57.873Z</updated>
    
    <content type="html"><![CDATA[<p>通常网络请求使用AFNetworking我们都会将字典作为参数传给服务端，如果应用对数据的安全级别要求较高，这时肯定会将参数加密后再传输，那么上传的参数就变成一串看不懂的字符串，我们只需要设置<code>AFHTTPSessionManager</code>中几个类型即可直接上传字符。<br><a id="more"></a></p><h3 id="配置参数请求和接收类型"><a href="#配置参数请求和接收类型" class="headerlink" title="配置参数请求和接收类型"></a>配置参数请求和接收类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (AFHTTPSessionManager *)getRequstManager &#123;</div><div class="line">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line">    manager.requestSerializer.timeoutInterval = 30;</div><div class="line">    manager.requestSerializer.stringEncoding = NSUTF8StringEncoding;</div><div class="line">    manager.requestSerializer = [AFHTTPRequestSerializer serializer];</div><div class="line">    manager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">    [manager.requestSerializer setValue:@&quot;text/html&quot; forHTTPHeaderField:@&quot;Accept&quot;];</div><div class="line">    [manager.requestSerializer setValue:@&quot;text/html&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">    return manager;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>配置完成后发送请求，可能会发现服务端接收的字符串前面莫名的多出’=’符号，查看源码发现<code>AFURLRequestSerialization</code>文件中下面的方法引起的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSString *)URLEncodedStringValue &#123;</div><div class="line">    if (!self.value || [self.value isEqual:[NSNull null]]) &#123;</div><div class="line">        return AFPercentEscapedStringFromString([self.field description]);</div><div class="line">    &#125; else &#123;</div><div class="line">        return [NSString stringWithFormat:@&quot;%@=%@&quot;, AFPercentEscapedStringFromString([self.field description]), AFPercentEscapedStringFromString([self.value description])];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>顺藤摸瓜发现<code>AFQueryStringFromParameters</code>函数中使用到了<code>- URLEncodedStringValue</code>方法。发现如下代码使用到了<code>AFQueryStringFromParameters</code>函数，如果实现<code>self.queryStringSerialization</code>属性就可以解决’=’问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">if (self.queryStringSerialization) &#123;</div><div class="line">    NSError *serializationError;</div><div class="line">    query = self.queryStringSerialization(request, parameters, &amp;serializationError);</div><div class="line">    </div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            *error = serializationError;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">&#125; else &#123;</div><div class="line">    switch (self.queryStringSerializationStyle) &#123;</div><div class="line">        case AFHTTPRequestQueryStringDefaultStyle:</div><div class="line">            query = AFQueryStringFromParameters(parameters);</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="解决’-’方法"><a href="#解决’-’方法" class="headerlink" title="解决’=’方法"></a>解决’=’方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *manager = [self sessionManager];</div><div class="line">[manager.requestSerializer setQueryStringSerializationWithBlock:^NSString *(NSURLRequest *request, NSDictionary *parameters, NSError *__autoreleasing *error) &#123;</div><div class="line">    return paramsStr;</div><div class="line">&#125;];</div><div class="line">[manager POST:urlStr parameters:paramsStr progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line">    </div><div class="line">&#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line">    </div><div class="line">&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">    </div><div class="line">&#125;];</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>不建议修改直接源码达到去掉’=’目的，通常可能因为源码版本更新而遗忘。</li><li>如果使用原生网络请求可以直接通过<code>[request setHTTPBody:data]</code>来实现字符串或其他数据传输。  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常网络请求使用AFNetworking我们都会将字典作为参数传给服务端，如果应用对数据的安全级别要求较高，这时肯定会将参数加密后再传输，那么上传的参数就变成一串看不懂的字符串，我们只需要设置&lt;code&gt;AFHTTPSessionManager&lt;/code&gt;中几个类型即可直接上传字符。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="blog" scheme="https://wynter.wang/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>iOS-GCD系列之dispatch_group_t</title>
    <link href="https://wynter.wang/2017/12/15/iOS-GCD%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BB%BB%E5%8A%A1%E7%BB%84dispatch_group_t/"/>
    <id>https://wynter.wang/2017/12/15/iOS-GCD系列之任务组dispatch_group_t/</id>
    <published>2017-12-15T11:14:26.000Z</published>
    <updated>2018-01-16T01:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇主要将对<code>dispatch_group_t</code>进行梳理应用，其主要用于监听管理任务组中任务完成情况，在任务完成后做一些操作处理。</p><a id="more"></a><h3 id="最常见的几个方法"><a href="#最常见的几个方法" class="headerlink" title="最常见的几个方法"></a>最常见的几个方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 创建一个任务组</div><div class="line">dispatch_group_create();</div><div class="line"></div><div class="line">// 将任务异步提交到任务组里</div><div class="line">dispatch_group_async(group, queue, block);</div><div class="line"></div><div class="line">// 不使用dispatch_group_async来提交任务</div><div class="line">// 任务组中任务数+1</div><div class="line">dispatch_group_enter(group);</div><div class="line"></div><div class="line">// 任务组中任务数-1与dispatch_group_enter必须成对出现</div><div class="line">dispatch_group_leave(group);</div><div class="line"></div><div class="line">// 等待之前任务执行完成后才继续执行</div><div class="line">dispatch_group_wait(group1, DISPATCH_TIME_FOREVER);</div><div class="line"></div><div class="line">// 当任务组中任务完成，会出发出发此方法的block</div><div class="line">dispatch_group_notify(group1, queue1,block);</div></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建任务组</span></div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"><span class="comment">// 创建串行队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.wynter.serial"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="comment">// 创建并发队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.wynter.concurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">    sleep(<span class="number">3</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"并发队列任务1，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_async(group, serialQueue, ^&#123;</div><div class="line">    sleep(<span class="number">2</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"串行队列任务1，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_async(group, serialQueue, ^&#123;</div><div class="line">     sleep(<span class="number">2</span>);</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"串行队列任务2，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 在任务组中并发执行，等同与dispatch_group_async(group, concurrentQueue, block)</span></div><div class="line">dispatch_group_enter(group);</div><div class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</div><div class="line">    sleep(<span class="number">2</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"并发队列任务2（enter/leave），当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 开始等待阻塞全部线程，直到任务中之前任务执行完成</span></div><div class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"结束任务组中已执行任务的等待，继续向下执行任务"</span>);</div><div class="line">    </div><div class="line">dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"并发队列任务3，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line">    </div><div class="line"><span class="comment">// 同一线程中通知任务组中队列中任务已经完成，故顺序打印通知结果</span></div><div class="line">dispatch_group_notify(group, concurrentQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"并发队列任务执行完毕，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line">    </div><div class="line">dispatch_group_notify(group, serialQueue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"串行队列任务执行完毕，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line">    </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> 2017-12-15 11:11:46.761678+0800 GCD[32253:17053663] 并发队列任务2（enter/leave），当前线程&lt;NSThread: 0x60400026d0c0&gt;&#123;number = 4, name = (null)&#125;</span></div><div class="line"><span class="comment"> 2017-12-15 11:11:46.761678+0800 GCD[32253:17053661] 串行队列任务1，当前线程：&lt;NSThread: 0x60000026c280&gt;&#123;number = 3, name = (null)&#125;</span></div><div class="line"><span class="comment"> 2017-12-15 11:11:47.761193+0800 GCD[32253:17053660] 并发队列任务1，当前线程：&lt;NSThread: 0x60000026c540&gt;&#123;number = 5, name = (null)&#125;</span></div><div class="line"><span class="comment"> 2017-12-15 11:11:48.762938+0800 GCD[32253:17053661] 串行队列任务2，当前线程：&lt;NSThread: 0x60000026c280&gt;&#123;number = 3, name = (null)&#125;</span></div><div class="line"><span class="comment"> 2017-12-15 11:11:48.762940+0800 GCD[32356:17074006] 结束任务组中已执行任务的等待，继续向下执行任务</span></div><div class="line"><span class="comment"> 2017-12-15 11:11:49.767551+0800 GCD[32253:17053661] 并发队列任务3，当前线程：&lt;NSThread: 0x60000026c280&gt;&#123;number = 3, name = (null)&#125;</span></div><div class="line"><span class="comment"> 2017-12-15 11:11:49.768026+0800 GCD[33057:17230402] 并发队列任务执行完毕，当前线程：&lt;NSThread: 0x60000026c480&gt;&#123;number = 3, name = (null)&#125;</span></div><div class="line"><span class="comment"> 2017-12-15 11:11:49.768248+0800 GCD[33057:17230226] 串行队列任务执行完毕，当前线程：&lt;NSThread: 0x60400027e300&gt;&#123;number = 5, name = (null)&#125;</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><p>1、创建串行、并发队列各一个<br>2、向任务组的并发队列中添加了 3秒后执行<em>并发队列任务1</em>、2秒后<em>并发队列任务2（enter/leave）</em>、1秒后执行<em>任务3</em><br>3、向任务组的串行队列中添加了 2秒后执行<em>串行队列任务1</em>、2秒后执行<em>串行队列任务2</em><br>4、在<em>并发队列任务2（enter/leave）</em>后添加了任务等待<br>5、通知任务完成</p><p>2个并发队列任务开辟两条新线程，并发执行耗时3秒，同时串行队列中的2个任务在同一线程中执行耗时4秒。因为在并发任务后添加任务组等待方法，所以并发队列任务3要等前面4个任务执行完毕才能执行，任务组总共耗时5秒，如果去掉任务等待耗时为4秒。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>使用<code>dispatch_sync/dispatch_async</code>来处理同步或异步，其实完没有必要，串行并发队列完全可以满足需求，并且使用<code>dispatch_async</code>会导致任务组提前通知完成；</li><li>任务组通知不区分串还是并行队列，任务组中所有任务执行完成才会收到通知。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇主要将对&lt;code&gt;dispatch_group_t&lt;/code&gt;进行梳理应用，其主要用于监听管理任务组中任务完成情况，在任务完成后做一些操作处理。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="GCD" scheme="https://wynter.wang/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>iOS-GCD系列之dispatch_queue_t</title>
    <link href="https://wynter.wang/2017/12/11/iOS-GCD%E7%B3%BB%E5%88%97%E4%B9%8Bdispatch_queue_t/"/>
    <id>https://wynter.wang/2017/12/11/iOS-GCD系列之dispatch_queue_t/</id>
    <published>2017-12-11T06:14:26.000Z</published>
    <updated>2018-01-16T01:53:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一个即时聊天项目中创建一个同步任务来执行数据库操作，在获取数据时忽略了这一点，获取数据时又将同步任务添加到队列中，导致应用启动后事件无响应，甚至导致了死锁，使用应用crash。找了半天发现原来是对GCD的使用不当，引起的死锁。主要还是没有对GCD深入了解，对有些方法也是现学现用，才会引起这样的问题，因此准备用此系列文章记录GCD的学习使用过程。<br><a id="more"></a></p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>GCD：全称是Grand Central Dispatch，中文名字大脑中枢派发，基于C语言的是苹果公司为解决多核并行问题研发，线程及生命周期都有系统自动管理。</p><p>任务：执行什么操作<br>队列：用来存放任务，将需要执行的任务添加到队列中，队列会遵循FIFO原则（先进先出、后进后出），将队列中的任务取出，放到对应的线程中执行</p><p>同步：不创建新的线程，只在当前线程中执行任务<br>异步：创建多条线程执行任务</p><p>串行：同一时间每次只能执行一个任务，当前任务未完成下一个任务只能在队列中等候<br>并发：同一时间可以执行多个任务</p><p>死锁：两个或多个任务互相等待形成死循环阻塞了线程，甚至导致应用无响应</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">串行</th><th style="text-align:center">并行</th><th style="text-align:center">主队列</th></tr></thead><tbody><tr><td style="text-align:center">同步</td><td style="text-align:center">没有开启新线程<br><br>串行执行任务</td><td style="text-align:center">没有开启新线程<br><br>串行执行任务</td><td style="text-align:center">发生死锁</td></tr><tr><td style="text-align:center">异步</td><td style="text-align:center">开启新线程<br><br>串行执行任务</td><td style="text-align:center">开启新线程<br><br>并发执行任务</td><td style="text-align:center">没有开启新线程<br><br>串行执行任务</td></tr></tbody></table><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>创建队列使用<code>dispatch_queue_create</code>，有两个参数，第一个参数是队列的名称，第二个参数是队列类型，通常创建串行队列都传<code>NULL</code>，我们也可以使用<code>dispatch_queue_attr_t</code>定义好的常量创建同步/并发队列</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">dispatch_queue_attr_t</span></div><div class="line"><span class="comment">DISPATCH_QUEUE_SERIAL: 同步队列</span></div><div class="line"><span class="comment">DISPATCH_QUEUE_CONCURRENT：并发队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> dispatch_queue_create ( <span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr );</div></pre></td></tr></table></figure><h4 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h4><ul><li><p>手动创建串行队列，当任务需要按特定的顺序执行时，就需要使用串行调度队列，串行调度队列每次只能执行一个任务</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.wynter.customQueue"</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></li><li><p>获取串行主队列，应用程序创建时系统自带串行队列，主队列中的任务都会在主线程中执行，一般会用于更新UI</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div></pre></td></tr></table></figure></li></ul><h4 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h4><p>全局并发队列由系统提供，供整个应用使用，不需要我们手动创建可以同时并行执行多个任务，同样也遵循FIFO原则</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">队列优先级</span></div><div class="line"><span class="comment">DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高</span></div><div class="line"><span class="comment">DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）</span></div><div class="line"><span class="comment">DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低</span></div><div class="line"><span class="comment">DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>); </div><div class="line"><span class="comment">// dispatch_queue_t queue = dispatch_queue_create("com.wynter.customQueue", DISPATCH_QUEUE_CONCURRENT);</span></div></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="同步-异步串行队列"><a href="#同步-异步串行队列" class="headerlink" title="同步/异步串行队列"></a>同步/异步串行队列</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  创建串行队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.wynter.customQueue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Begin"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 异步串行队列</span></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    sleep(<span class="number">3</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务1，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"队列外1，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    sleep(<span class="number">2</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务2，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"队列外2，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line"></div><div class="line"><span class="comment">// 同步串行队列</span></div><div class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"同步任务1，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"队列外3，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line"></div><div class="line"><span class="comment">// 异步串行队列</span></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务3，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"End"</span>);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> 2017-12-11 10:25:44.915490+0800 GCD[24560:5161766] Begin</span></div><div class="line"><span class="comment"> 2017-12-11 10:25:44.915783+0800 GCD[24560:5161766] 队列外1，当前线程：&lt;NSThread: 0x604000067800&gt;&#123;number = 1, name = main&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:25:44.915957+0800 GCD[24560:5161766] 队列外2，当前线程：&lt;NSThread: 0x604000067800&gt;&#123;number = 1, name = main&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:25:47.920174+0800 GCD[24560:5162003] 异步任务1，当前线程：&lt;NSThread: 0x60000027d6c0&gt;&#123;number = 3, name = (null)&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:25:49.920629+0800 GCD[24560:5162003] 异步任务2，当前线程：&lt;NSThread: 0x60000027d6c0&gt;&#123;number = 3, name = (null)&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:25:49.920987+0800 GCD[24560:5161766] 同步任务1，当前线程：&lt;NSThread: 0x604000067800&gt;&#123;number = 1, name = main&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:25:49.921231+0800 GCD[24560:5161766] 队列外3，当前线程：&lt;NSThread: 0x604000067800&gt;&#123;number = 1, name = main&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:25:49.921389+0800 GCD[24560:5161766] End</span></div><div class="line"><span class="comment"> 2017-12-11 10:25:50.926144+0800 GCD[24560:5162003] 异步任务3，当前线程：&lt;NSThread: 0x60000027d6c0&gt;&#123;number = 3, name = (null)&#125;</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><p>小结：</p><ul><li>同步串行队列使用主线程顺序执行任务，如果当前任务没有完成，不会继续执行同步块以外的其它代码</li><li>异步串行队列会创建一条新的线程，在当前线程中顺序执行任务，队列外的代码会在主线程中顺序执行，不受队列中任务的干扰</li></ul><h4 id="同步-异步并发队列"><a href="#同步-异步并发队列" class="headerlink" title="同步/异步并发队列"></a>同步/异步并发队列</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取全局并发队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue =  dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="comment">// 手动创建并发队列</span></div><div class="line"><span class="comment">//dispatch_queue_t queue =  dispatch_queue_create("com.wynter.customQueue", DISPATCH_QUEUE_CONCURRENT);</span></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Begin"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 异步并发队列</span></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    sleep(<span class="number">3</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务1，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"队列外1，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    sleep(<span class="number">2</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务2，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"队列外2，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line"></div><div class="line"><span class="comment">// 同步并发队列</span></div><div class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"同步任务1，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"队列外3，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line"></div><div class="line"><span class="comment">// 异步串行队列</span></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务3，当前线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"End"</span>);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> 2017-12-11 10:23:58.493818+0800 GCD[24510:5157656] Begin</span></div><div class="line"><span class="comment"> 2017-12-11 10:23:58.494137+0800 GCD[24510:5157656] 队列外1，当前线程：&lt;NSThread: 0x604000263000&gt;&#123;number = 1, name = main&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:23:58.494333+0800 GCD[24510:5157656] 队列外2，当前线程：&lt;NSThread: 0x604000263000&gt;&#123;number = 1, name = main&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:23:58.494488+0800 GCD[24510:5157656] 同步任务1，当前线程：&lt;NSThread: 0x604000263000&gt;&#123;number = 1, name = main&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:23:58.494919+0800 GCD[24510:5157656] 队列外3，当前线程：&lt;NSThread: 0x604000263000&gt;&#123;number = 1, name = main&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:23:58.495081+0800 GCD[24510:5157656] End</span></div><div class="line"><span class="comment"> 2017-12-11 10:23:59.498625+0800 GCD[24510:5158018] 异步任务3，当前线程：&lt;NSThread: 0x600000669080&gt;&#123;number = 3, name = (null)&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:24:00.495907+0800 GCD[24510:5158020] 异步任务2，当前线程：&lt;NSThread: 0x600000662980&gt;&#123;number = 4, name = (null)&#125;</span></div><div class="line"><span class="comment"> 2017-12-11 10:24:01.499261+0800 GCD[24510:5158016] 异步任务1，当前线程：&lt;NSThread: 0x6000006692c0&gt;&#123;number = 5, name = (null)&#125;</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><p>小结：</p><ul><li>同步并发队列任务不会创新线程，依然在主线程中执行，与同步串行队列效果相同</li><li>异步并发队列会依据并发任务量，创建对应的线程数量，实际开发中异步并发任务顺序是不确定的。</li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="合理并发"><a href="#合理并发" class="headerlink" title="合理并发"></a>合理并发</h4><p>在开发中并不是并发线程越多越好，线程多往往对也会以牺牲性能为代价，并发线程过多，并且不能很好的控制线程也有可能因为一个线程的阻塞或者死锁导致整个应用崩溃。</p><p>那么开多少个线程较为合理呢，这个没有确切的答案。最早了解到的是<code>CPU核数*2</code>，现在CPU性能已经提升了N个档位，所以具体要根据业务而定了，非必要情况还是控制在6个线程以内为好。我们可以使用<code>dispatch_semaphore</code>(信号量)来控制并发线程数量，之后会有详细介绍<code>dispatch_semaphore</code>的使用。</p><h4 id="设置队列优先级"><a href="#设置队列优先级" class="headerlink" title="设置队列优先级"></a>设置队列优先级</h4><p>在使用<code>dispatch_queue_create</code>创建队列的时候会发现，并没有设置队列优先级的选项，而全局队列则有高、中、低、后台四个等级可供选择，但是我们可以使用、<code>dispatch_queue_attr_make_with_qos_class</code>或者<code>dispatch_set_target_queue</code>方法来设置队列的优先级，<code>dispatch_queue_create</code>创建队列的优先级跟全局队列的默认优先级一样。</p><ul><li><p>通过<code>dispatch_queue_attr_make_with_qos_class</code>方法设置队列的优先级</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> *  QOS和全局并发队列优先级的映射关系</span></div><div class="line"><span class="comment"> *  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span></div><div class="line"><span class="comment"> *  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span></div><div class="line"><span class="comment"> *  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span></div><div class="line"><span class="comment"> *  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span></div><div class="line"><span class="comment">*/</span></div><div class="line">dispatch_queue_attr_t queue_attr = dispatch_queue_attr_make_with_qos_class (DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY,<span class="number">-1</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.wynter.customQueue"</span>, queue_attr);</div></pre></td></tr></table></figure></li><li><p>通过<code>dispatch_set_target_queue</code>方法设置队列的优先级</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.wynter.customQueue"</span>,<span class="literal">NULL</span>);  </div><div class="line"><span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW,<span class="number">0</span>);  </div><div class="line"> </div><div class="line"><span class="comment">// serialQueue队列参照globalQueue队列的优先级（DISPATCH_QUEUE_PRIORITY_LOW）</span></div><div class="line">dispatch_set_target_queue(serialQueue, globalQueue);</div></pre></td></tr></table></figure></li></ul><h3 id="使用栅栏控制并发队列中个别任务执行"><a href="#使用栅栏控制并发队列中个别任务执行" class="headerlink" title="使用栅栏控制并发队列中个别任务执行"></a>使用栅栏控制并发队列中个别任务执行</h3><p><code>dispatch_barrier_async</code>异步栅栏用于等待控制队列中前面的任务执行完毕后自己才执行，而它后面的任务需等待它完成之后才执行。异步栅栏不影响主线程中的任务执行顺序，但队列中的任务必须上面的规则。<code>dispatch_barrier_sync</code>同步栅栏则会阻塞主线程等待当前任务完成后才能按照原队列的规则执行。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.wynter.customQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"async_1"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_barrier_async(queue, ^&#123;</div><div class="line">    sleep(<span class="number">2</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hi,barrier"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"async_2"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h5 id="异步并发迭代任务"><a href="#异步并发迭代任务" class="headerlink" title="异步并发迭代任务"></a>异步并发迭代任务</h5><p>当我们需要执行循环异步处理任务时，可以考虑使用<code>dispatch_apply</code>来替换掉for循环，来并发地循环迭代任务。需要注意的是<code>dispatch_apply</code>的block内部异步并发，从下面代码打印<code>End</code>可以看出，<code>dispatch_apply</code>是等待其所有的循环运行完毕才往下执行。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">size_t count = <span class="number">10</span>;</div><div class="line">dispatch_apply(count, queue, ^(size_t i) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zu"</span>, i);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"End"</span>);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> 2017-12-11 10:30:07.152514+0800 GCD[25447:5470863] 0</span></div><div class="line"><span class="comment"> 2017-12-11 10:30:07.152514+0800 GCD[25447:5471097] 1</span></div><div class="line"><span class="comment"> 2017-12-11 10:30:07.152527+0800 GCD[25447:5471095] 2</span></div><div class="line"><span class="comment"> 2017-12-11 10:30:07.152558+0800 GCD[25447:5471099] 3</span></div><div class="line"><span class="comment"> 2017-12-11 10:30:07.152731+0800 GCD[25447:5471097] 4</span></div><div class="line"><span class="comment"> 2017-12-11 10:30:07.152731+0800 GCD[25447:5470863] 5</span></div><div class="line"><span class="comment"> 2017-12-11 10:30:07.152849+0800 GCD[25447:5471095] 6</span></div><div class="line"><span class="comment"> 2017-12-11 10:30:07.152988+0800 GCD[25447:5471099] 7</span></div><div class="line"><span class="comment"> 2017-12-11 10:30:07.153095+0800 GCD[25447:5471097] 8</span></div><div class="line"><span class="comment"> 2017-12-11 10:30:07.153108+0800 GCD[25447:5470863] 9</span></div><div class="line"><span class="comment"> 2017-12-11 10:30:07.154095+0800 GCD[25447:5470863] End</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p><h5 id="暂停-恢复队列"><a href="#暂停-恢复队列" class="headerlink" title="暂停/恢复队列"></a>暂停/恢复队列</h5><p><code>dispatch_suspend</code>不能保证可以立即停止队列上正在运行的block任务，而是在当前block任务执行完成后，暂停后续队列中的任务执行。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.wynter.customQueue"</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="comment">// 暂停指定队列</span></div><div class="line">dispatch_suspend(queue);</div><div class="line"><span class="comment">// 恢复指定队列</span></div><div class="line">dispatchp_resume(queue);</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>为避免发生死锁，少用<code>dispatch_sync</code>，建议尽量不要是使用同步串行队列处理任务</li><li>不建议创建多个串行队列来执行任务，应该在全局并发队列中完成任务</li><li>避免多级嵌套使用GCD</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个即时聊天项目中创建一个同步任务来执行数据库操作，在获取数据时忽略了这一点，获取数据时又将同步任务添加到队列中，导致应用启动后事件无响应，甚至导致了死锁，使用应用crash。找了半天发现原来是对GCD的使用不当，引起的死锁。主要还是没有对GCD深入了解，对有些方法也是现学现用，才会引起这样的问题，因此准备用此系列文章记录GCD的学习使用过程。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="GCD" scheme="https://wynter.wang/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>Mac 修改文件读写权限</title>
    <link href="https://wynter.wang/2017/11/17/Mac%20%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%9D%83%E9%99%90/"/>
    <id>https://wynter.wang/2017/11/17/Mac 修改文件读写权限/</id>
    <published>2017-11-17T11:13:16.000Z</published>
    <updated>2017-11-17T09:48:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用到系统中Framework，已经正确添加了，无论如何都报错，尝试了各种方法，还是报错。</p><p> 猜想可能是在Xcode中查看系统的Framework时，不小心删除了部分API，但是当时有没又没有发现。</p><p>讲道理啊，一般系统API文件右上角都会有个黑色的小锁，这种情况是不可以编辑文件，即使不小心编辑后也会弹出提示框询问。</p><p>于是我随便进到一个API头文件中，居然可以编辑。那么可能就找到原因了，重新下载了个Xcode替换当前的，问题解决了。</p><a id="more"></a><p>为了防止这样的事再次发生，在Xcode中随意找个系统Framework，右键Show in Finder，然后将Frameworks目录下文件修改为只读权限：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod -R a-w *</div></pre></td></tr></table></figure></p><p>再打开文件时，发现右上的小黑锁又回来。如何又后悔了，添加上读写权限即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod -R 775 *</div></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>具体权限：</p><blockquote><p>r(read):表示可读取权限,用数字4表示<br>w(write):表示可写入权限,用数字2表示<br>x(excute):表示可执行权限,用数字1表示</p></blockquote><p>权限范围：</p><blockquote><p>u(user):文件所有者<br>g(group):文件所有者所在群组<br>o(other):文件所有者及群组以外的用户<br>a(all):即全部的用户，包含拥有者，所属群组以及其他用户</p></blockquote><p>操作符号：</p><blockquote><p><code>+</code> 添加某个权限。<br><code>-</code> 取消某个权限。<br><code>=</code> 赋予给定权限并取消其他所有权限</p></blockquote><p>修改权限的命令格式:</p><blockquote><p>chmod [&lt;权限范围&gt;&lt;权限操作&gt;&lt;具体权限&gt;] [文件或目录…]</p></blockquote><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod 775 file</div><div class="line">chmod u=rwx,g=rwx,o=rx file</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>合理的使用文件读写操作权限，可以降低我们在工作中因为误操作引起的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用到系统中Framework，已经正确添加了，无论如何都报错，尝试了各种方法，还是报错。&lt;/p&gt;
&lt;p&gt; 猜想可能是在Xcode中查看系统的Framework时，不小心删除了部分API，但是当时有没又没有发现。&lt;/p&gt;
&lt;p&gt;讲道理啊，一般系统API文件右上角都会有个黑色的小锁，这种情况是不可以编辑文件，即使不小心编辑后也会弹出提示框询问。&lt;/p&gt;
&lt;p&gt;于是我随便进到一个API头文件中，居然可以编辑。那么可能就找到原因了，重新下载了个Xcode替换当前的，问题解决了。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://wynter.wang/categories/blog/"/>
    
    
      <category term="Linux" scheme="https://wynter.wang/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>iOS CGGeometry</title>
    <link href="https://wynter.wang/2017/10/11/iOS--CGGeometry/"/>
    <id>https://wynter.wang/2017/10/11/iOS--CGGeometry/</id>
    <published>2017-10-11T06:14:26.000Z</published>
    <updated>2017-12-18T02:55:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>CGGeometry是用C语言实现的一个封装了许多常用几何方法的文件<br><a id="more"></a></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 结构体</span></div><div class="line"></div><div class="line"><span class="comment">/* 定义一个点，设置x坐标和y坐标 */</span></div><div class="line"><span class="keyword">struct</span></div><div class="line"><span class="built_in">CGPoint</span> &#123;</div><div class="line">    <span class="built_in">CGFloat</span> x;</div><div class="line">    <span class="built_in">CGFloat</span> y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* 定义一个尺寸，设置宽度和高度 */</span></div><div class="line"><span class="keyword">struct</span> <span class="built_in">CGSize</span> &#123;</div><div class="line">    <span class="built_in">CGFloat</span> width;</div><div class="line">    <span class="built_in">CGFloat</span> height;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* 定义一个二维矢量 */</span></div><div class="line"><span class="keyword">struct</span> <span class="built_in">CGVector</span> &#123;</div><div class="line">    <span class="built_in">CGFloat</span> dx;</div><div class="line">    <span class="built_in">CGFloat</span> dy;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* 定义一个矩形*/</span></div><div class="line"><span class="keyword">struct</span> <span class="built_in">CGRect</span> &#123;</div><div class="line">    <span class="built_in">CGPoint</span> origin;</div><div class="line">    <span class="built_in">CGSize</span> size;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 全局常量</span></div><div class="line"></div><div class="line"><span class="comment">/*零点，与CGPointMake(0, 0)等效 */</span> </div><div class="line"><span class="keyword">const</span> <span class="built_in">CGPoint</span> <span class="built_in">CGPointZero</span></div><div class="line"></div><div class="line"><span class="comment">/*零尺寸，与CGSizeMake(0, 0)等效*/</span> </div><div class="line"> <span class="keyword">const</span> <span class="built_in">CGSize</span> <span class="built_in">CGSizeZero</span></div><div class="line"></div><div class="line"><span class="comment">/*零矩形，与CGRectMake(0, 0, 0, 0)等效*/</span> </div><div class="line"> <span class="keyword">const</span> <span class="built_in">CGRect</span> <span class="built_in">CGRectZero</span></div><div class="line"></div><div class="line"><span class="comment">/*空矩形，这个和零矩形并不相同，当我们返回两个不相交矩形的交集时，会返回空矩形 */</span></div><div class="line"> <span class="keyword">const</span> <span class="built_in">CGRect</span> <span class="built_in">CGRectNull</span></div><div class="line"></div><div class="line"><span class="comment">/* 无限的矩形 */</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">CGRect</span> <span class="built_in">CGRectInfinite</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - 创建几何</span></div><div class="line"></div><div class="line"><span class="comment">/* 根据`(x, y)`创建一个点 */</span></div><div class="line"> <span class="built_in">CGPoint</span> <span class="built_in">CGPointMake</span>(<span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y);</div><div class="line"></div><div class="line"><span class="comment">/* 根据 `(width, height)'创建一个尺寸*/</span></div><div class="line"><span class="built_in">CGSize</span> <span class="built_in">CGSizeMake</span>(<span class="built_in">CGFloat</span> width, <span class="built_in">CGFloat</span> height);</div><div class="line"></div><div class="line"><span class="comment">/* 根据 `(dx, dy)'创建一个矢量 */</span></div><div class="line"><span class="built_in">CGVector</span> <span class="built_in">CGVectorMake</span>(<span class="built_in">CGFloat</span> dx, <span class="built_in">CGFloat</span> dy);</div><div class="line"></div><div class="line"><span class="comment">/* 根据 `(x, y; width, height)'创建一个矩形*/</span></div><div class="line"> <span class="built_in">CGRect</span> <span class="built_in">CGRectMake</span>(<span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y, <span class="built_in">CGFloat</span> width,</div><div class="line">  <span class="built_in">CGFloat</span> height);</div></pre></td></tr></table></figure><h2 id="获取几何参数"><a href="#获取几何参数" class="headerlink" title="获取几何参数"></a>获取几何参数</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 获取几何参数</span></div><div class="line"></div><div class="line"><span class="comment">/* 根据 `rect'参数，获得矩形最左边的x值 */</span></div><div class="line"><span class="built_in">CGFloat</span> <span class="built_in">CGRectGetMinX</span>(<span class="built_in">CGRect</span> rect)</div><div class="line"></div><div class="line"><span class="comment">/* 根据 `rect'参数，获得矩形x轴中心点的值*/</span></div><div class="line"><span class="built_in">CGFloat</span> <span class="built_in">CGRectGetMidX</span>(<span class="built_in">CGRect</span> rect)</div><div class="line"></div><div class="line"><span class="comment">/*根据 `rect'参数， 获取矩形最右端的x值*/</span></div><div class="line"><span class="built_in">CGFloat</span> <span class="built_in">CGRectGetMaxX</span>(<span class="built_in">CGRect</span> rect)</div><div class="line"></div><div class="line"><span class="comment">/*根据 `rect'参数， 获取矩形最顶端的y值*/</span></div><div class="line"><span class="built_in">CGFloat</span> <span class="built_in">CGRectGetMinY</span>(<span class="built_in">CGRect</span> rect)</div><div class="line"></div><div class="line"><span class="comment">/* 根据 `rect'参数，获得矩形y轴中心点的值*/</span></div><div class="line"><span class="built_in">CGFloat</span> <span class="built_in">CGRectGetMidY</span>(<span class="built_in">CGRect</span> rect)</div><div class="line"></div><div class="line"><span class="comment">/*根据 `rect'参数， 获取矩形最底端的y值*/</span></div><div class="line"><span class="built_in">CGFloat</span> <span class="built_in">CGRectGetMaxY</span>(<span class="built_in">CGRect</span> rect)</div><div class="line"></div><div class="line"><span class="comment">/*根据 `rect'参数， 获取矩形宽度*/</span></div><div class="line"><span class="built_in">CGFloat</span> <span class="built_in">CGRectGetWidth</span>(<span class="built_in">CGRect</span> rect)</div><div class="line"></div><div class="line"><span class="comment">/*根据 `rect'参数， 获取矩形高度*/</span></div><div class="line"><span class="built_in">CGFloat</span> <span class="built_in">CGRectGetHeight</span>(<span class="built_in">CGRect</span> rect)</div><div class="line"></div><div class="line"><span class="comment">/*根据一个矩形创建一个标准的矩形*/</span></div><div class="line"> <span class="built_in">CGRect</span> <span class="built_in">CGRectStandardize</span>(<span class="built_in">CGRect</span> rect)</div><div class="line"></div><div class="line"><span class="comment">/* 创建一个内嵌的矩形，中心和rect参数的中心一样，将 rect 的坐标（origin）按照(dx,dy) 进行平移，然后将 rect 的大小（size） 宽度缩小2倍的 dx，高度缩小2倍的 dy. */</span></div><div class="line"><span class="built_in">CGRect</span> <span class="built_in">CGRectInset</span>(<span class="built_in">CGRect</span> rect, <span class="built_in">CGFloat</span> dx, <span class="built_in">CGFloat</span> dy)</div><div class="line"></div><div class="line"><span class="comment">/* 根据`rect' 参数，返回四个参数都是整数的矩形 */</span></div><div class="line"><span class="built_in">CGRect</span> <span class="built_in">CGRectIntegral</span>(<span class="built_in">CGRect</span> rect)</div><div class="line"></div><div class="line"><span class="comment">/* 返回 `r1' 和 `r2'并集*/</span></div><div class="line"><span class="built_in">CGRect</span> <span class="built_in">CGRectUnion</span>(<span class="built_in">CGRect</span> r1, <span class="built_in">CGRect</span> r2)</div><div class="line"></div><div class="line"><span class="comment">/* 返回 `r1' 和 `r2'交集，如果没有交集返回CGRectNull */</span></div><div class="line"><span class="built_in">CGRect</span> <span class="built_in">CGRectIntersection</span>(<span class="built_in">CGRect</span> r1, <span class="built_in">CGRect</span> r2)</div><div class="line"></div><div class="line"><span class="comment">/* 返回一个矩形，偏移量相对于rect，根据进行平移 */</span></div><div class="line"><span class="built_in">CGRect</span> <span class="built_in">CGRectOffset</span>(<span class="built_in">CGRect</span> rect, <span class="built_in">CGFloat</span> dx, <span class="built_in">CGFloat</span> dy)</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> 将一个 CGRect 切割成两个 CGRect</span></div><div class="line"><span class="comment"> @param rect 原矩形</span></div><div class="line"><span class="comment"> @param slice 切割的 CGRect 的指针</span></div><div class="line"><span class="comment"> @param remainder 切割后剩下的 CGRect 的指针</span></div><div class="line"><span class="comment"> @param amount 切割的大小，是edge开始计算的方向</span></div><div class="line"><span class="comment"> @param edge   CGRectMinXEdge(从x的最小处进行垂直分割)、  CGRectMinYEdge(从y的最小处进行水平分割)、CGRectMaxXEdge(从x最大处进行垂直分割)、 CGRectMaxYEdge(从y最大处进行水平分割)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">void</span> <span class="built_in">CGRectDivide</span>(<span class="built_in">CGRect</span> rect, <span class="built_in">CGRect</span> *  slice,</div><div class="line">    <span class="built_in">CGRect</span> *  remainder, <span class="built_in">CGFloat</span> amount, <span class="built_in">CGRectEdge</span> edge)</div></pre></td></tr></table></figure><h2 id="判断几何"><a href="#判断几何" class="headerlink" title="判断几何"></a>判断几何</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 判断几何</span></div><div class="line"><span class="comment">/* 如果 `point1' 和`point2' 相等返回YES, 否则返回NO*/</span></div><div class="line"><span class="keyword">bool</span> <span class="built_in">CGPointEqualToPoint</span>(<span class="built_in">CGPoint</span> point1, <span class="built_in">CGPoint</span> point2)</div><div class="line"></div><div class="line"><span class="comment">/* 如果`size1' 和 `size2' 相等返回YES, 否则返回NO */</span></div><div class="line"><span class="keyword">bool</span> <span class="built_in">CGSizeEqualToSize</span>(<span class="built_in">CGSize</span> size1, <span class="built_in">CGSize</span> size2)</div><div class="line"></div><div class="line"><span class="comment">/* 如果`rect1' 和 `rect2'  相等返回YES, 否则返回NO */</span></div><div class="line"><span class="keyword">bool</span> <span class="built_in">CGRectEqualToRect</span>(<span class="built_in">CGRect</span> rect1, <span class="built_in">CGRect</span> rect2)</div><div class="line"></div><div class="line"><span class="comment">/* 如果`rect'为空返回YES, 否则返回NO */</span></div><div class="line"> <span class="keyword">bool</span> <span class="built_in">CGRectIsEmpty</span>(<span class="built_in">CGRect</span> rect);</div><div class="line"></div><div class="line"><span class="comment">/* 如果 `rect' 为null返回YES, 否则返回NO */</span></div><div class="line"><span class="keyword">bool</span> <span class="built_in">CGRectIsNull</span>(<span class="built_in">CGRect</span> rect)</div><div class="line"></div><div class="line"><span class="comment">/* 如果 `rect' 是无限矩形返回YES, 否则返回NO */</span></div><div class="line"><span class="keyword">bool</span> <span class="built_in">CGRectIsInfinite</span>(<span class="built_in">CGRect</span> rect);</div><div class="line"></div><div class="line"><span class="comment">/* 判断点是否在矩形内*/</span></div><div class="line"><span class="keyword">bool</span> <span class="built_in">CGRectContainsPoint</span>(<span class="built_in">CGRect</span> rect, <span class="built_in">CGPoint</span> point)</div><div class="line"></div><div class="line"><span class="comment">/* 判断矩形1是否包含矩形2*/</span></div><div class="line"><span class="keyword">bool</span> <span class="built_in">CGRectContainsRect</span>(<span class="built_in">CGRect</span> rect1, <span class="built_in">CGRect</span> rect2)</div><div class="line"></div><div class="line"><span class="comment">/* 判断矩形1和矩形2是否相交*/</span></div><div class="line"><span class="keyword">bool</span> <span class="built_in">CGRectIntersectsRect</span>(<span class="built_in">CGRect</span> rect1, <span class="built_in">CGRect</span> rect2)</div></pre></td></tr></table></figure><h2 id="CGRectInset-与-CGRectOffset的区别"><a href="#CGRectInset-与-CGRectOffset的区别" class="headerlink" title="CGRectInset 与 CGRectOffset的区别"></a>CGRectInset 与 CGRectOffset的区别</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>CGRectInset：对矩形进行平移和缩放两个操作</p><p>CGRectOffset：只对矩形进行平移，不会改变其大小</p><h3 id="计算过程-伪代码"><a href="#计算过程-伪代码" class="headerlink" title="计算过程(伪代码)"></a>计算过程(伪代码)</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRectInset</span>：</div><div class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(x, y, width, height);</div><div class="line"><span class="built_in">CGRect</span> rectInset = <span class="built_in">CGRectInset</span>(rect, dx, dy);</div><div class="line">rectInset = <span class="built_in">CGRectMake</span>(dx, dy, (width - ( dx * <span class="number">2</span>)), (height - ( dy * <span class="number">2</span>)) );</div><div class="line"></div><div class="line"><span class="built_in">CGRectOffset</span>: </div><div class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(x, y, width, height);</div><div class="line"><span class="built_in">CGRect</span> rectOffset = <span class="built_in">CGRectOffset</span>(rect, dx, dy);</div><div class="line">rectOffset = <span class="built_in">CGRectMake</span>((x + dx), (y + dy), width, height );</div></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>CGRectInset：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">30</span>);</div><div class="line"><span class="built_in">CGRect</span> rectInset = <span class="built_in">CGRectInset</span>(rect, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line"><span class="built_in">CGRect</span> bigRectInset = <span class="built_in">CGRectInset</span>(rect, <span class="number">-10</span>, <span class="number">-10</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"rectInset:%@ \n bigRectInset:%@"</span>, <span class="built_in">NSStringFromCGRect</span>(rectInset), <span class="built_in">NSStringFromCGRect</span>(bigRectInset));</div><div class="line"></div><div class="line"><span class="comment">// rectInset:&#123;&#123;10, 10&#125;, &#123;10, 10&#125;&#125;</span></div><div class="line"><span class="comment">// bigRectInset:&#123;&#123;-10, -10&#125;, &#123;50, 50&#125;&#125;</span></div></pre></td></tr></table></figure></p><p>CGRectOffset:<br> <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">30</span>);</div><div class="line"><span class="built_in">CGRect</span> rectOffset = <span class="built_in">CGRectOffset</span>(rect, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line"><span class="built_in">CGRect</span> leftRectOffset = <span class="built_in">CGRectOffset</span>(rect, <span class="number">-10</span>, <span class="number">-10</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"rectOffset:%@ \n leftRectOffset:%@"</span>, <span class="built_in">NSStringFromCGRect</span>(rectOffset), <span class="built_in">NSStringFromCGRect</span>(leftRectOffset));</div><div class="line"></div><div class="line"><span class="comment">// rectOffset:&#123;&#123;20, 20&#125;, &#123;30, 30&#125;&#125;</span></div><div class="line"><span class="comment">// leftRectOffset:&#123;&#123;0, 0&#125;, &#123;30, 30&#125;&#125;</span></div></pre></td></tr></table></figure></p><h2 id="CGRectDivide"><a href="#CGRectDivide" class="headerlink" title="CGRectDivide"></a>CGRectDivide</h2><p>用来分割矩形，参数rect是源矩形，slice和remainder是分割后的两部分矩形，amount是分割线，edge是分割选项。</p><h3 id="edge分割方式"><a href="#edge分割方式" class="headerlink" title="edge分割方式"></a>edge分割方式</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">CF_ENUM</span>(uint32_t, <span class="built_in">CGRectEdge</span>) &#123;</div><div class="line">  <span class="comment">//从x的最小处进行垂直分割</span></div><div class="line">  <span class="built_in">CGRectMinXEdge</span>, </div><div class="line">  <span class="comment">//从y的最小处进行水平分割</span></div><div class="line">  <span class="built_in">CGRectMinYEdge</span>, </div><div class="line">  <span class="comment">//从x最大处进行垂直分割</span></div><div class="line">  <span class="built_in">CGRectMaxXEdge</span>,</div><div class="line">  <span class="comment">//从y最大处进行水平分割</span></div><div class="line">  <span class="built_in">CGRectMaxYEdge</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="计算过程-伪代码-1"><a href="#计算过程-伪代码-1" class="headerlink" title="计算过程(伪代码)"></a>计算过程(伪代码)</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(x, y, width, height);</div><div class="line"><span class="built_in">CGRectDivide</span>(rect, &amp;slice,</div><div class="line">             &amp;remainder, amount, edge);</div><div class="line"><span class="keyword">switch</span> (edge) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="built_in">CGRectMinXEdge</span>: &#123;</div><div class="line">        *slice = <span class="built_in">CGRectMake</span>(x, y, amount, height);</div><div class="line">        *remainder = <span class="built_in">CGRectMake</span>(x + amount, y, width - amount, height);</div><div class="line">    &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="built_in">CGRectMaxXEdge</span>: &#123;</div><div class="line">        *slice = <span class="built_in">CGRectMake</span>(width - amount, y, amount, height);</div><div class="line">        *remainder = <span class="built_in">CGRectMake</span>(x, y, width - amount, height);</div><div class="line">    &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="built_in">CGRectMinYEdge</span>: &#123;</div><div class="line">        *slice = <span class="built_in">CGRectMake</span>(x, y, width, amount);</div><div class="line">        *remainder = <span class="built_in">CGRectMake</span>(x, y + amount, width, height - amount);</div><div class="line">    &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="built_in">CGRectMaxYEdge</span>: &#123;</div><div class="line">        *slice = <span class="built_in">CGRectMake</span>(width, y - amount, width, amount);</div><div class="line">        *remainder = <span class="built_in">CGRectMake</span>(x, y, width, height - amount);</div><div class="line">    &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> slice;</div><div class="line"><span class="built_in">CGRect</span> remainder;</div><div class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</div><div class="line"><span class="built_in">CGRectDivide</span>(rect, &amp;slice, &amp;remainder, <span class="number">50</span>, <span class="built_in">CGRectMinXEdge</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"slice:%@ \n remainder:%@"</span>, <span class="built_in">NSStringFromCGRect</span>(slice), <span class="built_in">NSStringFromCGRect</span>(remainder));</div><div class="line"></div><div class="line"><span class="comment">// CGRectMinXEdge</span></div><div class="line"><span class="comment">// slice:&#123;&#123;0, 0&#125;, &#123;50, 200&#125;&#125;</span></div><div class="line"><span class="comment">// remainder:&#123;&#123;50, 0&#125;, &#123;150, 200&#125;&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// CGRectMaxXEdge</span></div><div class="line"><span class="comment">// slice:&#123;&#123;150, 0&#125;, &#123;50, 200&#125;&#125;</span></div><div class="line"><span class="comment">// remainder:&#123;&#123;0, 0&#125;, &#123;150, 200&#125;&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// CGRectMinYEdge</span></div><div class="line"><span class="comment">// slice:&#123;&#123;0, 0&#125;, &#123;200, 50&#125;&#125;</span></div><div class="line"><span class="comment">// remainder:&#123;&#123;0, 50&#125;, &#123;200, 150&#125;&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// CGRectMaxYEdge</span></div><div class="line"><span class="comment">// slice:&#123;&#123;0, 150&#125;, &#123;200, 50&#125;&#125;</span></div><div class="line"><span class="comment">// remainder:&#123;&#123;0, 0&#125;, &#123;200, 150&#125;&#125;</span></div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在没有对CGGeometry进行深入的了解时，只会用到平时常用的几个方法，可是深入了解后还是会发现有很多实用而自己却一直不知道的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CGGeometry是用C语言实现的一个封装了许多常用几何方法的文件&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="API" scheme="https://wynter.wang/tags/API/"/>
    
      <category term="iOS" scheme="https://wynter.wang/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 拉伸图片</title>
    <link href="https://wynter.wang/2017/09/20/iOS%20%E6%8B%89%E4%BC%B8%E5%9B%BE%E7%89%87/"/>
    <id>https://wynter.wang/2017/09/20/iOS 拉伸图片/</id>
    <published>2017-09-20T10:13:16.000Z</published>
    <updated>2017-11-01T07:42:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中总会遇到背景图片和控件大小一致的困扰，通常就是两种方法：<br>1、找美工切大小合适的图片<br>2、通过使用代码处理或可视化设置图片拉伸</p><a id="more"></a><h2 id="如何使用Slicing"><a href="#如何使用Slicing" class="headerlink" title="如何使用Slicing"></a>如何使用Slicing</h2><p>Slicing功能要在.xcassets结尾的图片资源管理器中才可以使用</p><p>1、通过以下Show Slicing按钮和右边栏Slicing属性打开效果相同，点击后可以看到有三种图片拉伸方式：水平、垂直、水平垂直方向；</p><p>Slicing 中有个Center属性用来指定图片的拉伸方式(Stretches、Tile)和可拉伸矩形范围</p><p><img src="http://upload-images.jianshu.io/upload_images/937490-748714a21bcecd9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第一步把冰箱门打开.png"></p><p>2、根据需要选择图片拉伸方式，这里选择十字图标或右侧选择 Horizontal And Vertical来演示效果，如下图蓝色区域为可拉伸区域 <code>CGSizeMake(5, 5)</code>，绿色区域为不可拉伸区域 <code>UIEdgeInsetsMake(8, 8, 8, 8)</code>，可以通过过拖拉虚线来改变它们的作用区域或右侧属性来修改</p><p><img src="http://upload-images.jianshu.io/upload_images/937490-4d68fd21dd695344.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二步大象装进冰箱.png"></p><p>水平拉伸方式更直观：<br><img src="http://upload-images.jianshu.io/upload_images/937490-1d84ae9ed856d8b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拿一个水桶.png"></p><p>3、拉伸前图片大小52*52，通过设置后的效果<br><img src="http://upload-images.jianshu.io/upload_images/937490-cf0cfeac1f06b268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第三步把大象拉出来溜溜.png"></p><h2 id="在可视化编程中设置UIImageView的Stretching为-0-5-0-5-0-0-来处理拉伸"><a href="#在可视化编程中设置UIImageView的Stretching为-0-5-0-5-0-0-来处理拉伸" class="headerlink" title="在可视化编程中设置UIImageView的Stretching为(0.5, 0.5, 0, 0)来处理拉伸"></a>在可视化编程中设置UIImageView的Stretching为(0.5, 0.5, 0, 0)来处理拉伸</h2><p><img src="http://upload-images.jianshu.io/upload_images/937490-3735334a98177484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="stretching.png"></p><h2 id="通过使用UIImage方法处理图片拉伸"><a href="#通过使用UIImage方法处理图片拉伸" class="headerlink" title="通过使用UIImage方法处理图片拉伸"></a>通过使用UIImage方法处理图片拉伸</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)resizableImageWithCapInsets:(<span class="built_in">UIEdgeInsets</span>)capInsets;</div><div class="line">- (<span class="built_in">UIImage</span> *)resizableImageWithCapInsets:(<span class="built_in">UIEdgeInsets</span>)capInsets resizingMode:(<span class="built_in">UIImageResizingMode</span>)resizingMode;</div></pre></td></tr></table></figure><p>参数<br>capInsets：用来设置图片的顶、左、底、右的端盖高度<br>resizingMode：指定图片的拉伸方式</p><blockquote><p>UIImageResizingModeStretch：延伸模式，通过拉伸UIEdgeInsets指定的矩形区域来填充图片图片<br>UIImageResizingModeTile：平铺模式，通过复制显示UIEdgeInsets指定的矩形区域来填充图片</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Stretching属性设置拉伸只对UIImageView有效，按钮图片拉伸需要使用其他两种方式处理；<br>UIImage中方法处理图片拉伸，适用于代码设置；<br>Slicing功能最为方便有效，推荐使用；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中总会遇到背景图片和控件大小一致的困扰，通常就是两种方法：&lt;br&gt;1、找美工切大小合适的图片&lt;br&gt;2、通过使用代码处理或可视化设置图片拉伸&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://wynter.wang/categories/blog/"/>
    
    
      <category term="iOS" scheme="https://wynter.wang/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>由UITableView缓存机制引起的崩溃问题</title>
    <link href="https://wynter.wang/2017/09/17/%E7%94%B1UITableView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%BC%95%E8%B5%B7%E7%9A%84%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/"/>
    <id>https://wynter.wang/2017/09/17/由UITableView缓存机制引起的崩溃问题/</id>
    <published>2017-09-17T10:13:16.000Z</published>
    <updated>2017-11-01T07:43:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直没有更新文章，没有别的理由就是自己懒，回头想想这几天忙着撕逼几天下来扣字过万，怎么会没有写一篇总结文章的功夫呢？</p><p>这里说说我在开发中遇到的2个由于缓存机制引起的崩溃问题：<br>一、在二级页面发送通知更新一级页面数据列表并执行返回一级页面时引起崩溃；<br>二、使用UISearchController搜索，全部数据和搜索结果公用一个UITableView，在开始搜索的时候引起崩溃。</p><a id="more"></a><h2 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter]postNotificationName:FINISHARRIVALEQUIP object:<span class="literal">nil</span>];</div><div class="line">[<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</div></pre></td></tr></table></figure><p>起初猜测是发送通知又多个页面刷新，数据导致主线程堵塞引起崩溃呢，运行代码后，直接发现是数组越界引起崩溃，因为在发送通知后，直接请求数据会先清空数据源，网络请求还没有返回数据，此时刚好执行pop返回到当前页面，UITableView会直接从缓存中拿去数据，但是数据源为空。</p><p>解决方法：<br>1、在返回会网络请求返回数据的时候再清空数据源重新赋值<br>2、清空数据源后，先执行 [self.tableView reloadData]刷新列表，再执行网络请求</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">   DataSourceItem *item;</div><div class="line">    <span class="keyword">if</span> (!_searchController.active) &#123;</div><div class="line">        item = _dataArray[indexPath.row];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        item = _searchArray[indexPath.row];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *cellIdentifier = <span class="string">@"cell"</span>;</div><div class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];</div><div class="line">    <span class="keyword">return</span> cell; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>点击搜索的时候数据源切换为_searchArray，但是tableView依然按照_dataArray缓存拿去数据，从而导致崩溃。</p><p>解决方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)updateSearchResultsForSearchController:(<span class="built_in">UISearchController</span> *)searchController &#123;</div><div class="line">    [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="数组越界问题"><a href="#数组越界问题" class="headerlink" title="数组越界问题"></a>数组越界问题</h2><p>上面两种问题最终都是由于数组越界引起的崩溃，可以使用一下方法判断是否越界：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (indexPath.row &lt; _dataArray.count) &#123;</div><div class="line">       item = [_dataArray objectAtIndex:indexPath.row];</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>不是每次都能记得加数组越界判断，我们可以使用数组的分类，在其中内部判断：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> (<span class="title">Util</span>)</span></div><div class="line"> </div><div class="line"><span class="comment">/*!</span></div><div class="line"><span class="comment"> @method objectAtIndexCheck:</span></div><div class="line"><span class="comment"> @abstract 检查是否越界和NSNull如果是返回nil</span></div><div class="line"><span class="comment"> @result 返回对象</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">id</span>)objectAtIndexCheck:(<span class="built_in">NSUInteger</span>)index;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div><div class="line"> </div><div class="line"><span class="meta">#import <span class="meta-string">"NSArray+Util.h"</span></span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> (<span class="title">Util</span>)</span></div><div class="line"> </div><div class="line">- (<span class="keyword">id</span>)objectAtIndexCheck:(<span class="built_in">NSUInteger</span>)index</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (index &gt;= [<span class="keyword">self</span> count]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="keyword">id</span> value = [<span class="keyword">self</span> objectAtIndex:index];</div><div class="line">    <span class="keyword">if</span> (value == [<span class="built_in">NSNull</span> null]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>引起的崩溃两种情况都是数据源改变，UITableView并不知道数据源改变，还在缓存中通过IndexPath.row拿取对应数组中数据， 但此时数据源已改变，就可能会因为数组越界Carsh，以上两种情况都可以通过在改变数据源后及时刷新UITableView来解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直没有更新文章，没有别的理由就是自己懒，回头想想这几天忙着撕逼几天下来扣字过万，怎么会没有写一篇总结文章的功夫呢？&lt;/p&gt;
&lt;p&gt;这里说说我在开发中遇到的2个由于缓存机制引起的崩溃问题：&lt;br&gt;一、在二级页面发送通知更新一级页面数据列表并执行返回一级页面时引起崩溃；&lt;br&gt;二、使用UISearchController搜索，全部数据和搜索结果公用一个UITableView，在开始搜索的时候引起崩溃。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://wynter.wang/categories/blog/"/>
    
    
      <category term="iOS" scheme="https://wynter.wang/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UISaerchBar偏移问题</title>
    <link href="https://wynter.wang/2017/07/12/UISaerchBar%E5%81%8F%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
    <id>https://wynter.wang/2017/07/12/UISaerchBar偏移问题/</id>
    <published>2017-07-12T11:13:16.000Z</published>
    <updated>2017-11-01T07:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多朋友都在使用<code>UISearchController</code>总会遇到一些莫名其妙的问题，当然我也遇到了，下面就记录下使用<code>UISearchController</code>中遇到问题部分问题。</p><a id="more"></a><p>初始代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">UITableViewController *searchResultsController = [[UITableViewController alloc]init];</div><div class="line">searchResultsController.tableView.delegate = self;</div><div class="line">searchResultsController.tableView.dataSource = self;</div><div class="line">searchResultsController.tableView.estimatedRowHeight = 80;</div><div class="line">searchResultsController.tableView.rowHeight = UITableViewAutomaticDimension;</div><div class="line">self.searchController = [[UISearchController alloc] initWithSearchResultsController:searchResultsController];</div><div class="line">self.searchController.view.backgroundColor = [[UIColor whiteColor] colorWithAlphaComponent:0.95];</div><div class="line">self.searchController.searchResultsUpdater = self;</div><div class="line"></div><div class="line">UISearchBar *bar = self.searchController.searchBar;</div><div class="line">bar.barTintColor = [UIColor colorWithRed:239.0/255.0 green:239.0/255.0 blue:244.0/255.0 alpha:1.0];</div><div class="line">bar.tintColor = [UIColor blackColor];</div><div class="line">bar.showsBookmarkButton = YES;</div><div class="line">bar.translucent = YES;</div><div class="line"></div><div class="line">UIImageView *view = [[[bar.subviews objectAtIndex:0] subviews] firstObject];</div><div class="line">view.layer.borderColor = [UIColor colorWithRed:239.0/255.0 green:239.0/255.0 blue:244.0/255.0 alpha:1.0].CGColor;</div><div class="line">view.layer.borderWidth = 1;</div><div class="line"></div><div class="line">self.tableView.tableHeaderView = bar;</div></pre></td></tr></table></figure></p><h3 id="问题1：点击搜索框时searchResultsController和searchBar间隔44pt，并且点击跳转无响应，如下图："><a href="#问题1：点击搜索框时searchResultsController和searchBar间隔44pt，并且点击跳转无响应，如下图：" class="headerlink" title="问题1：点击搜索框时searchResultsController和searchBar间隔44pt，并且点击跳转无响应，如下图："></a>问题1：点击搜索框时searchResultsController和searchBar间隔44pt，并且点击跳转无响应，如下图：</h3><p><img src="http://upload-images.jianshu.io/upload_images/937490-9a01655d2ac2e824.gif?imageMogr2/auto-orient/strip" alt="问题1.gif"></p><p>解决办法，添加代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.definesPresentationContext = YES;</div></pre></td></tr></table></figure></p><p>效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/937490-20109807de97bcef.gif?imageMogr2/auto-orient/strip" alt="问题1解决方法.gif"></p><h3 id="问题2：在设置导航栏为不透明时，点击搜索时searchBar偏移出屏幕"><a href="#问题2：在设置导航栏为不透明时，点击搜索时searchBar偏移出屏幕" class="headerlink" title="问题2：在设置导航栏为不透明时，点击搜索时searchBar偏移出屏幕"></a>问题2：在设置导航栏为不透明时，点击搜索时searchBar偏移出屏幕</h3><p>解决办法同上</p><h3 id="问题3：在设置导航栏为不透明时，点击搜索框出现如下情况："><a href="#问题3：在设置导航栏为不透明时，点击搜索框出现如下情况：" class="headerlink" title="问题3：在设置导航栏为不透明时，点击搜索框出现如下情况："></a>问题3：在设置导航栏为不透明时，点击搜索框出现如下情况：</h3><p><img src="http://upload-images.jianshu.io/upload_images/937490-799753f433a621eb.gif?imageMogr2/auto-orient/strip" alt="问题3.gif"></p><p>解决办法，添加代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.extendedLayoutIncludesOpaqueBars = YES;</div></pre></td></tr></table></figure></p><p>效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/937490-d6a8c588ffdf91e7.gif?imageMogr2/auto-orient/strip" alt="问题3解决办法.gif"></p><h3 id="属性介绍："><a href="#属性介绍：" class="headerlink" title="属性介绍："></a>属性介绍：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 导航栏是否为半透明</div><div class="line">self.navigationController.navigationBar.translucent = YES;</div><div class="line">// 如果在当前控制器中该属性为YES时，则将设置新的视图控制器。如果当前控制器中该属性为NO，则控制器为跟视图控制</div><div class="line">self.definesPresentationContext = NO;</div><div class="line">// 是否隐藏navigationBar</div><div class="line">self.searchController.hidesNavigationBarDuringPresentation = YES;</div><div class="line">// 延伸视图包是否含不透明的bar</div><div class="line">self.extendedLayoutIncludesOpaqueBars = NO;</div></pre></td></tr></table></figure><h3 id="引起问题的原因："><a href="#引起问题的原因：" class="headerlink" title="引起问题的原因："></a>引起问题的原因：</h3><ul><li>出现searchResultsController和searchBar间隔44pt的原因就在于，UISearchController有个<code>hidesNavigationBarDuringPresentation</code>属性，其默认值为YES，就是在点击searchBar时进行搜索时会将导航栏隐藏，并将searchBar移动到navigationBar的位置处，而tableView并不知道searchBar已经移动到navigationBar的位置所以就多出了44pt；</li><li>在searchResultsController中点击cell无法跳转是因为searchResultsController并不是主视图，而在设置<code>self.definesPresentationContext = YES</code>后，系统会将searchResultsController设置为新的主视图；</li><li>在设置导航栏为不透明时（<code>self.navigationController.navigationBar.translucent = NO</code>），点击搜索时searchBar偏移出屏幕，导航栏不透明时，self.view的原点是从导航栏的底部，那么相对self.view而言navigationBar的x=-64，所以搜searchBar弹出时获取<code>self.navigationController.navigationBar.x = searchBar.x;</code>,此navigationBar已经隐藏，searchBar.x = -64这个时候就会偏移出屏幕。</li><li>那么到searchBar向下偏移64pt原理同上。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>可能有些地方解释的不到位，欢迎大家指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信很多朋友都在使用&lt;code&gt;UISearchController&lt;/code&gt;总会遇到一些莫名其妙的问题，当然我也遇到了，下面就记录下使用&lt;code&gt;UISearchController&lt;/code&gt;中遇到问题部分问题。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://wynter.wang/categories/blog/"/>
    
    
      <category term="iOS" scheme="https://wynter.wang/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>StoryBoard使用之页面传值</title>
    <link href="https://wynter.wang/2017/05/21/StoryBoard%E4%BD%BF%E7%94%A8%E4%B9%8B%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC/"/>
    <id>https://wynter.wang/2017/05/21/StoryBoard使用之页面传值/</id>
    <published>2017-05-21T12:13:16.000Z</published>
    <updated>2017-11-01T07:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近接手一个半成品的项目，由于前期另一位iOS开发的同事使用的StoryBoard(简称SB)搭建的框架，接手后就继续使用SB开发。之前项目一直使用纯代码和xib来做UI，对于SB用起来还觉得挺麻烦，虽然可视化界使层次结构更加清晰，但是对于一个UI简单和大量页面复用的项目，使用SB反而降低了效率。刚好这个项目就是UI简单和大量页面复用，SB对这个项目来说只是展示结构的作用，由于很多复用界面导致SB看起来像蜘蛛网一样混乱，完全掩盖了SB的设计初衷吧，并且SB上大部分ViewController只是展示作用并没有发挥提高界面绘制的优势，反而在创建页面、跳转页面的时候降低开发效率。既然项目利用到了，下面就说说使用segue跳转界面传值的几种方法。</p><a id="more"></a><h2 id="方法一：-设置一个局部变量保存要传数据"><a href="#方法一：-设置一个局部变量保存要传数据" class="headerlink" title="方法一： 设置一个局部变量保存要传数据"></a>方法一： 设置一个局部变量保存要传数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</div><div class="line">    ProjectItem *item = dataAry[indexPath.row];</div><div class="line">    projectId = item.projectId;</div><div class="line">    [self performSegueWithIdentifier:@&quot;detailSegue&quot; sender:self];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</div><div class="line">    if ([segue.destinationViewController isKindOfClass:[ViewController class]]) &#123;</div><div class="line">        ViewController *controller = segue.destinationViewController;</div><div class="line">        controller.projectId = projectId;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="方法二：-在prepareForSegue-sender-使用indexPathForSelectedRow获取目标控页面所需参数"><a href="#方法二：-在prepareForSegue-sender-使用indexPathForSelectedRow获取目标控页面所需参数" class="headerlink" title="方法二： 在prepareForSegue:sender:使用indexPathForSelectedRow获取目标控页面所需参数"></a>方法二： 在<code>prepareForSegue:sender:</code>使用<code>indexPathForSelectedRow</code>获取目标控页面所需参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    [self performSegueWithIdentifier:@&quot;detailSegue&quot; sender:self];</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</div><div class="line">    if ([segue.destinationViewController isKindOfClass:[ViewController class]]) &#123;</div><div class="line">        NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];</div><div class="line">        ProjectItem *item = dataAry[indexPath.row];</div><div class="line">        ViewController *controller = segue.destinationViewController;</div><div class="line">        controller.projectId = item.projectId;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="方法三：-使用performSegueWithIdentifier-sender-方法的sender传递目标页面所需数据"><a href="#方法三：-使用performSegueWithIdentifier-sender-方法的sender传递目标页面所需数据" class="headerlink" title="方法三： 使用performSegueWithIdentifier:sender:方法的sender传递目标页面所需数据"></a>方法三： 使用<code>performSegueWithIdentifier:sender:</code>方法的sender传递目标页面所需数据</h2><p>推荐使用此方法，其他UI控件事件也同样适用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; </div><div class="line">    [self performSegueWithIdentifier:@&quot;detailSegue&quot; sender:indexPath];</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</div><div class="line">    if ([segue.destinationViewController isKindOfClass:[ViewController class]]) &#123;</div><div class="line">        NSIndexPath *indexPath = (NSIndexPath *)sender;</div><div class="line">        ProjectItem *item = dataAry[indexPath.row];</div><div class="line">        ViewController *controller = segue.destinationViewController;</div><div class="line">        controller.projectId = item.projectId;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不推荐使用此方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</div><div class="line">    ProjectItem *item = dataAry[indexPath.row];</div><div class="line">    [self performSegueWithIdentifier:@&quot;detailSegue&quot; sender:item.projectId];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</div><div class="line">    if ([segue.destinationViewController isKindOfClass:[ViewController class]]) &#123;</div><div class="line">        ViewController *controller = segue.destinationViewController;</div><div class="line">        controller.projectId = sender;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>方法一使用起来比较麻烦，需要额外的创建一个成员变量来存值，但是可以应用到任何具有点击事件的方法中；</li><li>方法二局限于<code>UITableView</code>，若同时使用<code>deselectRowAtIndexPath:indexPath animated:</code>也将会使使用此方法后<code>indexPathForSelectedRow</code>方法无法获取indexPath；</li><li>方法三中<code>sender</code>就是发送器的意思，也就是用于接收存储发送器。<code>id</code>类型是不确定类型，虽然可以用于传各种参数，但是根据<code>sender</code>的意思最好设置为发送器。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近接手一个半成品的项目，由于前期另一位iOS开发的同事使用的StoryBoard(简称SB)搭建的框架，接手后就继续使用SB开发。之前项目一直使用纯代码和xib来做UI，对于SB用起来还觉得挺麻烦，虽然可视化界使层次结构更加清晰，但是对于一个UI简单和大量页面复用的项目，使用SB反而降低了效率。刚好这个项目就是UI简单和大量页面复用，SB对这个项目来说只是展示结构的作用，由于很多复用界面导致SB看起来像蜘蛛网一样混乱，完全掩盖了SB的设计初衷吧，并且SB上大部分ViewController只是展示作用并没有发挥提高界面绘制的优势，反而在创建页面、跳转页面的时候降低开发效率。既然项目利用到了，下面就说说使用segue跳转界面传值的几种方法。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://wynter.wang/categories/blog/"/>
    
    
      <category term="iOS" scheme="https://wynter.wang/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-UIKit框架学习—UITextView</title>
    <link href="https://wynter.wang/2017/05/12/iOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UITextView/"/>
    <id>https://wynter.wang/2017/05/12/iOS-UIKit框架学习—UITextView/</id>
    <published>2017-05-12T12:26:34.000Z</published>
    <updated>2017-05-12T12:29:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>UITextView的类实现一个滚动的，多行文本区域的行为。类支持使用自定义字体，颜色，和对齐的文本的显示，同时还支持文本编辑。通常可以使用一个文本视图，显示多行文本。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">@protocol UITextViewDelegate &lt;NSObject, UIScrollViewDelegate&gt;</div><div class="line"></div><div class="line">@optional</div><div class="line"></div><div class="line">// 是否开始编辑</div><div class="line">- (BOOL)textViewShouldBeginEditing:(UITextView *)textView;</div><div class="line">// 是否完成编辑</div><div class="line">- (BOOL)textViewShouldEndEditing:(UITextView *)textView;</div><div class="line">// 开始编辑</div><div class="line">- (void)textViewDidBeginEditing:(UITextView *)textView;</div><div class="line">// 完成编辑</div><div class="line">- (void)textViewDidEndEditing:(UITextView *)textView;</div><div class="line">// 文本发生改变，是否替换成指定的文本</div><div class="line">- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text;</div><div class="line">// 文本内容发生改变</div><div class="line">- (void)textViewDidChange:(UITextView *)textView;</div><div class="line">// 更改选中的文本</div><div class="line">- (void)textViewDidChangeSelection:(UITextView *)textView;</div><div class="line">// 是否允许指定的用户使用指定范围的URL进行交互</div><div class="line">- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange interaction:(UITextItemInteraction)interaction NS_AVAILABLE_IOS(10_0);</div><div class="line">// 是否允许指定文本附件与文本进行交互</div><div class="line">- (BOOL)textView:(UITextView *)textView shouldInteractWithTextAttachment:(NSTextAttachment *)textAttachment inRange:(NSRange)characterRange interaction:(UITextItemInteraction)interaction NS_AVAILABLE_IOS(10_0);</div><div class="line">- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange NS_DEPRECATED_IOS(7_0, 10_0, &quot;Use textView:shouldInteractWithURL:inRange:forInteractionType: instead&quot;);</div><div class="line">- (BOOL)textView:(UITextView *)textView shouldInteractWithTextAttachment:(NSTextAttachment *)textAttachment inRange:(NSRange)characterRange NS_DEPRECATED_IOS(7_0, 10_0, &quot;Use textView:shouldInteractWithTextAttachment:inRange:forInteractionType: instead&quot;);</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UITextView : UIScrollView &lt;UITextInput, UIContentSizeCategoryAdjusting&gt;</div><div class="line">// 代理</div><div class="line">@property(nullable,nonatomic,weak) id&lt;UITextViewDelegate&gt; delegate;</div><div class="line">// 文本内容</div><div class="line">@property(null_resettable,nonatomic,copy) NSString *text;</div><div class="line">// 字体</div><div class="line">@property(nullable,nonatomic,strong) UIFont *font;</div><div class="line">// 字体颜色</div><div class="line">@property(nullable,nonatomic,strong) UIColor *textColor;</div><div class="line">// 对齐方式</div><div class="line">@property(nonatomic) NSTextAlignment textAlignment;</div><div class="line">// 选择的范围</div><div class="line">@property(nonatomic) NSRange selectedRange;</div><div class="line">// 是否可编辑</div><div class="line">@property(nonatomic,getter=isEditable) BOOL editable __TVOS_PROHIBITED;</div><div class="line">// 是否可选</div><div class="line">@property(nonatomic,getter=isSelectable) BOOL selectable NS_AVAILABLE_IOS(7_0);</div><div class="line">// 自动检测文本类型，如电话号码、邮箱、网址等</div><div class="line">@property(nonatomic) UIDataDetectorTypes dataDetectorTypes NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED;</div><div class="line">// 是否允许设置文本属性 默认为NO</div><div class="line">@property(nonatomic) BOOL allowsEditingTextAttributes NS_AVAILABLE_IOS(6_0);</div><div class="line">// 文本属性</div><div class="line">@property(null_resettable,copy) NSAttributedString *attributedText NS_AVAILABLE_IOS(6_0);</div><div class="line">// 属性字典</div><div class="line">@property(nonatomic,copy) NSDictionary&lt;NSString *, id&gt; *typingAttributes NS_AVAILABLE_IOS(6_0);</div><div class="line">// 设置指定可见的的滚动范围</div><div class="line">- (void)scrollRangeToVisible:(NSRange)range;</div><div class="line">// 自定义输入框</div><div class="line">@property (nullable, readwrite, strong) UIView *inputView;</div><div class="line">// 输入框的辅助视图</div><div class="line">@property (nullable, readwrite, strong) UIView *inputAccessoryView;</div><div class="line">// 再次编辑是否清楚文本 默认为NO</div><div class="line">@property(nonatomic) BOOL clearsOnInsertion NS_AVAILABLE_IOS(6_0);</div><div class="line"></div><div class="line">// 创建文本视图</div><div class="line">- (instancetype)initWithFrame:(CGRect)frame textContainer:(nullable NSTextContainer *)textContainer NS_AVAILABLE_IOS(7_0) NS_DESIGNATED_INITIALIZER;</div><div class="line">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</div><div class="line"></div><div class="line">// 获取文本视图的文本容器</div><div class="line">@property(nonatomic,readonly) NSTextContainer *textContainer NS_AVAILABLE_IOS(7_0);</div><div class="line">// 设置文本容器内间距</div><div class="line">@property(nonatomic, assign) UIEdgeInsets textContainerInset NS_AVAILABLE_IOS(7_0);</div><div class="line">// 获取布局管理器</div><div class="line">@property(nonatomic,readonly) NSLayoutManager *layoutManager NS_AVAILABLE_IOS(7_0);</div><div class="line">// 获取文本存储对象中的文本</div><div class="line">@property(nonatomic,readonly,strong) NSTextStorage *textStorage NS_AVAILABLE_IOS(7_0);</div><div class="line"></div><div class="line">// link的样式属性</div><div class="line">@property(null_resettable, nonatomic, copy) NSDictionary&lt;NSString *, id&gt; *linkTextAttributes NS_AVAILABLE_IOS(7_0);</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/ 开始编辑时发送通知</div><div class="line">UIKIT_EXTERN NSNotificationName const UITextViewTextDidBeginEditingNotification;</div><div class="line">// 文本发生变化发送通知</div><div class="line">UIKIT_EXTERN NSNotificationName const UITextViewTextDidChangeNotification;</div><div class="line">// 编辑完成发送通知</div><div class="line">UIKIT_EXTERN NSNotificationName const UITextViewTextDidEndEditingNotification;</div></pre></td></tr></table></figure><p>e.g.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">UITextView *textView = [[UITextView alloc]initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, 100)];</div><div class="line">textView.font = [UIFont systemFontOfSize:12.f];</div><div class="line">textView.text = @&quot;iOS-UIKit框架学习—UITextView&quot;;</div><div class="line">textView.textColor = UIColorFromRGB(0xababab);</div><div class="line">// UITextView在上下左右分别有一个8px的padding,设置为0后可以正常计算文本高度，否则要宽度-16</div><div class="line">[textView setContentOffset:CGPointZero];</div><div class="line">[self.view addSubview:textView];</div><div class="line"></div><div class="line">// 用此方法计算高度不需要设置内容边距</div><div class="line">CGSize sizeToFit = [textView sizeThatFits:CGSizeMake(SCREEN_WIDTH, MAXFLOAT)];</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UITextView的类实现一个滚动的，多行文本区域的行为。类支持使用自定义字体，颜色，和对齐的文本的显示，同时还支持文本编辑。通常可以使用一个文本视图，显示多行文本。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="API" scheme="https://wynter.wang/tags/API/"/>
    
      <category term="iOS" scheme="https://wynter.wang/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 百度地图SDK-配置开发环境</title>
    <link href="https://wynter.wang/2017/05/01/iOS-%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BESDK-%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://wynter.wang/2017/05/01/iOS-百度地图SDK-配置开发环境/</id>
    <published>2017-05-01T08:13:16.000Z</published>
    <updated>2017-05-15T10:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然百度地图应经用了很多次了，但是每次都浪费很长时间来配置，所以今天把配置<a href="http://lbsyun.baidu.com/index.php?title=iossdk" target="_blank" rel="noopener">百度地图SDK</a>的过程记录下来，也方便日后查看。<br><a id="more"></a></p><h2 id="第一步、导入百度SDK"><a href="#第一步、导入百度SDK" class="headerlink" title="第一步、导入百度SDK"></a>第一步、导入百度SDK</h2><p>百度地图SDK支持手动和使用<code>CocoaPods</code>自动配置</p><h3 id="自动配置-framework形式开发包（使用CocoaPods）"><a href="#自动配置-framework形式开发包（使用CocoaPods）" class="headerlink" title="自动配置.framework形式开发包（使用CocoaPods）"></a>自动配置.framework形式开发包（使用CocoaPods）</h3><p> 1、进入工程所在根目录执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod init   // 初始化后，会自动创建`Podfile`文件</div></pre></td></tr></table></figure></p><p> 2、搜索百度地图SDK在CocoaPods的版本号：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod search  BaiduMapKit</div></pre></td></tr></table></figure></p><p>3、编辑Podfile内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod <span class="string">'BaiduMapKit'</span>, <span class="string">'3.3.0'</span>   // 3.3.0是当前最新的版本号</div></pre></td></tr></table></figure></p><p>4.在Podfile所在的文件夹下输入命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod install</div></pre></td></tr></table></figure></p><p>成功以后，会出现如下记录：</p><blockquote><p>Analyzing dependencies<br>Downloading dependencies<br>Installing BaiduMapKit (3.3.0)<br>Generating Pods project<br>Integrating client project<br>[!] Please close any current Xcode sessions and use <code>BaiDuPoiSearch.xcworkspace</code> for this project from now on</p></blockquote><h3 id="手动配置-framework形式开发包"><a href="#手动配置-framework形式开发包" class="headerlink" title="手动配置.framework形式开发包"></a>手动配置.framework形式开发包</h3><p>1、根据需要导入 .framework包，将所需要的<code>BaiduMapAPI_**.framework</code>拷贝到工程所在文件夹下，BaiduMapAPI_Base.framework为基础包，使用SDK任何功能都需导入，其他分包可按需导入</p><p>2、在<code>TARGETS</code>-&gt;<code>Build Phases</code>-&gt;<code>Link Binary With Libaries</code>中点击“+”按钮，在弹出的窗口中点击<code>Add Other</code>按钮，选择<code>BaiduMapAPI_**.framework</code>添加到工程中</p><blockquote><p>注意:静态库中采用Objective-C++实现，因此需要您保证您工程中至少有一个.mm后缀的源文件(您可以将任意一个.m后缀的文件改名为.mm)，或者在工程属性中指定编译方式，即在Xcode的<code>Project</code> -&gt; <code>Edit Active Target</code>-&gt;<code>Build Setting</code> 中找到 <code>Compile Sources As</code>，并将其设置为<code>Objective-C++</code></p></blockquote><h2 id="第二步、引入所需的系统依赖库"><a href="#第二步、引入所需的系统依赖库" class="headerlink" title="第二步、引入所需的系统依赖库"></a>第二步、引入所需的系统依赖库</h2><p>百度地图SDK中提供了定位功能和动画效果，v2.0.0版本开始使用OpenGL渲染因此您需要在您的Xcode工程中引入：<br><code>CoreLocation.framework</code>、<code>QuartzCore.framework</code>、<code>OpenGLES.framework</code>、<code>SystemConfiguration.framework</code>、<code>CoreGraphics.framework</code>、<code>Security.framework</code>、<code>libsqlite3.0.tbd</code>、<code>CoreTelephony.framework</code> 、<code>libstdc++.6.0.9.tbd</code></p><p><strong>添加方法：</strong>在Xcode的<code>Project</code> -&gt; <code>Active Target</code> -&gt;<code>Build Phases</code> -&gt;<code>Link Binary With Libraries</code>，添加这几个系统库即可</p><h2 id="第三步、引入所需的第三方openssl库"><a href="#第三步、引入所需的第三方openssl库" class="headerlink" title="第三步、引入所需的第三方openssl库"></a>第三步、引入所需的第三方openssl库</h2><p>添加支持HTTPS所需的penssl静态库：<code>libssl.a</code>和<code>libcrypto.a</code>（SDK打好的包存放于thirdlib目录下</p><p><strong>添加方法：</strong> 在 <code>TARGETS</code>-&gt;<code>Build Phases</code>-&gt;<code>Link Binary With Libaries</code>中点击“+”按钮，在弹出的窗口中点击<code>Add Other</code>按钮，选择libssl.a和libcrypto.a添加到工程中</p><h2 id="第四步、环境配置"><a href="#第四步、环境配置" class="headerlink" title="第四步、环境配置"></a>第四步、环境配置</h2><p>在<code>TARGETS</code>-&gt;<code>Build Settings</code>-&gt;<code>Other Linker Flags</code> 中添加<code>-ObjC</code>。</p><h2 id="第五步、引入mapapi-bundle资源文件"><a href="#第五步、引入mapapi-bundle资源文件" class="headerlink" title="第五步、引入mapapi.bundle资源文件"></a>第五步、引入mapapi.bundle资源文件</h2><p>如果使用了基础地图功能，需要添加该资源，否则地图不能正常显示<code>mapapi.bundle</code>中存储了定位、默认大头针标注View及路线关键点的资源图片，还存储了矢量地图绘制必需的资源文件。如果您不需要使用内置的图片显示功能，则可以删除<code>bundle</code>文件中的<code>image</code>文件夹。您也可以根据具体需求任意替换或删除该<code>bundle</code>中<code>image</code>文件夹的图片文件。</p><p><strong>添加方法：</strong>选中工程名，在右键菜单中选择<code>Add Files to …</code>，从<code>BaiduMapAPI_Map.framework</code>||<code>Resources</code>文件中选择<code>mapapi.bundle</code>文件，并勾选<code>Copy items if needed</code>复选框，单击<code>Add</code>按钮，将资源文件添加到工程中。</p><h2 id="第六步、引入头文件"><a href="#第六步、引入头文件" class="headerlink" title="第六步、引入头文件"></a>第六步、引入头文件</h2><p>在使用SDK的类 按需 引入下边的头文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;BaiduMapAPI_Base/BMKBaseComponent.h&gt;</span>//引入base相关所有的头文件</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;BaiduMapAPI_Map/BMKMapComponent.h&gt;</span>//引入地图功能所有的头文件</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;BaiduMapAPI_Search/BMKSearchComponent.h&gt;</span>//引入检索功能所有的头文件</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;BaiduMapAPI_Cloud/BMKCloudSearchComponent.h&gt;</span>//引入云检索功能所有的头文件</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;BaiduMapAPI_Location/BMKLocationComponent.h&gt;</span>//引入定位功能所有的头文件</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;BaiduMapAPI_Utils/BMKUtilsComponent.h&gt;</span>//引入计算工具所有的头文件</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;BaiduMapAPI_Radar/BMKRadarComponent.h&gt;</span>//引入周边雷达功能所有的头文件</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;BaiduMapAPI_Map/BMKMapView.h&gt;</span>//只引入所需的单个头文件</span></div></pre></td></tr></table></figure></p><h2 id="第七步、调用客户端"><a href="#第七步、调用客户端" class="headerlink" title="第七步、调用客户端"></a>第七步、调用客户端</h2><p>如果在iOS9中使用了调起百度地图客户端功能，必须在<code>Info.plist</code>中进行如下配置，否则不能调起百度地图客户端。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>LSApplicationQueriesSchemes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>baidumap<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></div></pre></td></tr></table></figure></p><h2 id="第八步、开启定位提醒"><a href="#第八步、开启定位提醒" class="headerlink" title="第八步、开启定位提醒"></a>第八步、开启定位提醒</h2><p>自iOS SDK v2.5.0起，为了对iOS8的定位能力做兼容，做了相应的修改，开发者在使用过程中注意事项如下：</p><p>需要在info.plist里添加（以下二选一，两个都添加默认使用<code>NSLocationWhenInUseUsageDescription</code>）：</p><ul><li><p><code>NSLocationWhenInUseUsageDescription</code>  // 允许在前台使用时获取GPS的描述</p></li><li><p><code>NSLocationAlwaysUsageDescription</code> // 允许永久使用GPS的描述</p></li></ul><h2 id="第九步、验证key和应用名称是否相符"><a href="#第九步、验证key和应用名称是否相符" class="headerlink" title="第九步、验证key和应用名称是否相符"></a>第九步、验证key和应用名称是否相符</h2><p>在使用Xcode6进行SDK开发过程中，需要在info.plist中添加：<code>Bundle display name</code> ，且其值不能为空（Xcode6新建的项目没有此配置，若没有会造成manager start failed）</p><h2 id="第十步、APPDelegate配置"><a href="#第十步、APPDelegate配置" class="headerlink" title="第十步、APPDelegate配置"></a>第十步、APPDelegate配置</h2><p>.h文件<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;BaiduMapAPI_Base/BMKBaseComponent.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>,<span class="title">BMKGeneralDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) BMKMapManager* mapManager;</div></pre></td></tr></table></figure></p><p>.m文件<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)setUpBaiMap &#123;</div><div class="line">    <span class="comment">//百度地图</span></div><div class="line">    <span class="keyword">if</span> ([[<span class="built_in">UIDevice</span> currentDevice].systemVersion floatValue] &gt;= <span class="number">8</span>) &#123;</div><div class="line">        <span class="comment">//由于IOS8中定位的授权机制改变 需要进行手动授权</span></div><div class="line">        <span class="built_in">CLLocationManager</span>  *locationManager = [[<span class="built_in">CLLocationManager</span> alloc] init];</div><div class="line">        <span class="comment">//获取授权认证</span></div><div class="line">        [locationManager requestAlwaysAuthorization];</div><div class="line">        [locationManager requestWhenInUseAuthorization];</div><div class="line">        [locationManager startUpdatingLocation];</div><div class="line">    &#125;</div><div class="line">    _mapManager = [[BMKMapManager alloc]init];</div><div class="line">    <span class="comment">// 如果要关注网络及授权验证事件，请设定     generalDelegate参数</span></div><div class="line">    <span class="built_in">BOOL</span> ret = [_mapManager start:BaiDu_MapKey  generalDelegate:<span class="keyword">self</span>];</div><div class="line">    <span class="keyword">if</span> (!ret) &#123;</div><div class="line">        DLog(<span class="string">@"manager start failed!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - 百度地图</span></div><div class="line">- (<span class="keyword">void</span>)onGetNetworkState:(<span class="keyword">int</span>)iError &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == iError) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"联网成功"</span>);</div><div class="line">    &#125; <span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"onGetNetworkState %d"</span>,iError);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)onGetPermissionState:(<span class="keyword">int</span>)iError &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == iError) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"授权成功"</span>);</div><div class="line">        <span class="keyword">self</span>.isMapPermission = <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"onGetPermissionState %d"</span>,iError);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="第十一步、管理地图的生命周期"><a href="#第十一步、管理地图的生命周期" class="headerlink" title="第十一步、管理地图的生命周期"></a>第十一步、管理地图的生命周期</h2><p>自2.0.0起，BMKMapView新增viewWillAppear、viewWillDisappear方法来控制BMKMapView的生命周期，并且在一个时刻只能有一个`BMKMapView接受回调消息，因此在使用BMKMapView的viewController中需要在viewWillAppear、viewWillDisappear方法中调用BMKMapView的对应的方法，并处理delegate，代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">    [_mapView viewWillAppear];</div><div class="line">    _mapView.delegate = <span class="keyword">self</span>; <span class="comment">// 此处记得不用的时候需要置nil，否则影响内存的释放</span></div><div class="line">&#125;</div><div class="line">-(<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</div><div class="line">&#123;</div><div class="line">      [_mapView viewWillDisappear];</div><div class="line">      _mapView.delegate = <span class="literal">nil</span>; <span class="comment">// 不用时，置nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文借鉴<a href="http://lbsyun.baidu.com/index.php?title=iossdk/guide/buildproject" target="_blank" rel="noopener">百度地图SDK-配置开发环境</a>，只是对百度地图的配置进行了一下总结，仅供开发百度地图参考使用，如有侵权行为，请联系我并及时删除。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然百度地图应经用了很多次了，但是每次都浪费很长时间来配置，所以今天把配置&lt;a href=&quot;http://lbsyun.baidu.com/index.php?title=iossdk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度地图SDK&lt;/a&gt;的过程记录下来，也方便日后查看。&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="https://wynter.wang/categories/blog/"/>
    
    
      <category term="SDK" scheme="https://wynter.wang/tags/SDK/"/>
    
  </entry>
  
  <entry>
    <title>iOS-UIKit框架学习—UISwitch</title>
    <link href="https://wynter.wang/2017/04/14/iOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UISwitch/"/>
    <id>https://wynter.wang/2017/04/14/iOS-UIKit框架学习—UISwitch/</id>
    <published>2017-04-14T09:14:11.000Z</published>
    <updated>2017-04-14T09:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>您可以使用UISwitch类来创建和管理ON/ OFF按钮，您会看到，例如在飞行模式等服务的偏好设定（设定）。这些对象被称为开关。<br><a id="more"></a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NS_CLASS_AVAILABLE_IOS</span>(<span class="number">2</span>_0) __TVOS_PROHIBITED <span class="class"><span class="keyword">@interface</span> <span class="title">UISwitch</span> : <span class="title">UIControl</span> &lt;<span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 开关开启时的颜色 On</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *onTintColor <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 背景边框颜色</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">null_resettable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *tintColor <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"><span class="comment">// 开关关闭时的颜色 Off</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *thumbTintColor <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 打开时的状态图片</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *onImage <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 关闭时的状态图片</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *offImage <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"></div><div class="line"><span class="comment">// 开关</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">getter</span>=isOn) <span class="built_in">BOOL</span> on;</div><div class="line"></div><div class="line"><span class="comment">// 初始化</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line"><span class="comment">// 设置开关并有动画效果</span></div><div class="line">- (<span class="keyword">void</span>)setOn:(<span class="built_in">BOOL</span>)on animated:(<span class="built_in">BOOL</span>)animated; </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>e.g.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UISwitch</span> *switch1 = [[<span class="built_in">UISwitch</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>)];</div><div class="line">switch1.onTintColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">switch1.thumbTintColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">switch1.tintColor = [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">[switch1 setOn:<span class="literal">YES</span> animated:<span class="literal">YES</span>];</div><div class="line">[<span class="keyword">self</span>.view addSubview:switch1];</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;您可以使用UISwitch类来创建和管理ON/ OFF按钮，您会看到，例如在飞行模式等服务的偏好设定（设定）。这些对象被称为开关。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="API" scheme="https://wynter.wang/tags/API/"/>
    
      <category term="iOS" scheme="https://wynter.wang/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-UIKit框架学习—UISlider</title>
    <link href="https://wynter.wang/2017/04/14/iOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UISlider/"/>
    <id>https://wynter.wang/2017/04/14/iOS-UIKit框架学习—UISlider/</id>
    <published>2017-04-14T09:13:35.000Z</published>
    <updated>2017-04-14T09:28:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个UISlider对象是一个可视化的控制，用来选择一个连续值范围从单一的值。滑块始终显示为单杠。拇指，注意到滑块的当前值，并更改设置的用户可以通过移动。<br><a id="more"></a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NS_CLASS_AVAILABLE_IOS</span>(<span class="number">2</span>_0) __TVOS_PROHIBITED <span class="class"><span class="keyword">@interface</span> <span class="title">UISlider</span> : <span class="title">UIControl</span> &lt;<span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 当前的值</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="keyword">float</span> value;</div><div class="line"><span class="comment">// 滑动器的最小值</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="keyword">float</span> minimumValue;</div><div class="line"><span class="comment">// 滑动器的最大值</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="keyword">float</span> maximumValue;</div><div class="line"><span class="comment">// 左侧最小值图片 如🔊</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIImage</span> *minimumValueImage;</div><div class="line"><span class="comment">// 右侧最大值图片 如🔊</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIImage</span> *maximumValueImage;</div><div class="line"><span class="comment">// 是否拖动值改变后连续 默认YES</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">getter</span>=isContinuous) <span class="built_in">BOOL</span> continuous;</div><div class="line"></div><div class="line"><span class="comment">// 最小的值的填充色</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span> *minimumTrackTintColor <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 最大的值的填充色</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span> *maximumTrackTintColor <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 滑块的填充色</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span> *thumbTintColor <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"></div><div class="line"><span class="comment">// 设置值并有动画效果</span></div><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">float</span>)value animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"></div><div class="line"><span class="comment">// 设置不同状态下滑块图片</span></div><div class="line">- (<span class="keyword">void</span>)setThumbImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image forState:(<span class="built_in">UIControlState</span>)state;</div><div class="line"><span class="comment">// 设置不同状态下最小值图片</span></div><div class="line">- (<span class="keyword">void</span>)setMinimumTrackImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image forState:(<span class="built_in">UIControlState</span>)state;</div><div class="line"><span class="comment">// 设置不同状态下最大值图片</span></div><div class="line">- (<span class="keyword">void</span>)setMaximumTrackImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image forState:(<span class="built_in">UIControlState</span>)state;</div><div class="line"></div><div class="line"><span class="comment">// 获取不同状态下滑块的图片</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)thumbImageForState:(<span class="built_in">UIControlState</span>)state;</div><div class="line"><span class="comment">// 获取不同状态下最小值的图片</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)minimumTrackImageForState:(<span class="built_in">UIControlState</span>)state;</div><div class="line"><span class="comment">// 获取不同状态下最大值的图片</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)maximumTrackImageForState:(<span class="built_in">UIControlState</span>)state;</div><div class="line"></div><div class="line"><span class="comment">// 获取当前滑块的图片</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIImage</span> *currentThumbImage;</div><div class="line"><span class="comment">// 获取当前最小值图片</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIImage</span> *currentMinimumTrackImage;</div><div class="line"><span class="comment">// 获取当前最大值图片</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIImage</span> *currentMaximumTrackImage;</div><div class="line"></div><div class="line"><span class="comment">// 返回最小值图片绘制的矩形</span></div><div class="line">- (<span class="built_in">CGRect</span>)minimumValueImageRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line"><span class="comment">// 返回最大值图片绘制的矩形</span></div><div class="line">- (<span class="built_in">CGRect</span>)maximumValueImageRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line"><span class="comment">// 返回为滑块轨道绘制的矩形</span></div><div class="line">- (<span class="built_in">CGRect</span>)trackRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line"><span class="comment">// 返回为拇指滑块轨道绘制的矩形</span></div><div class="line">- (<span class="built_in">CGRect</span>)thumbRectForBounds:(<span class="built_in">CGRect</span>)bounds trackRect:(<span class="built_in">CGRect</span>)rect value:(<span class="keyword">float</span>)value;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>e.g.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UISlider</span> *slider = [[<span class="built_in">UISlider</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">100</span>, SCREEN_WIDTH, <span class="number">10</span>)];</div><div class="line">slider.minimumValue = <span class="number">0.</span>f;</div><div class="line">slider.maximumValue = <span class="number">100.</span>f;</div><div class="line">slider.thumbTintColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">slider.minimumTrackTintColor = [<span class="built_in">UIColor</span> yellowColor];</div><div class="line">slider.maximumTrackTintColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">[slider setValue:<span class="number">50</span> animated:<span class="literal">YES</span>];</div><div class="line">[<span class="keyword">self</span>.view addSubview:slider];</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个UISlider对象是一个可视化的控制，用来选择一个连续值范围从单一的值。滑块始终显示为单杠。拇指，注意到滑块的当前值，并更改设置的用户可以通过移动。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="API" scheme="https://wynter.wang/tags/API/"/>
    
      <category term="iOS" scheme="https://wynter.wang/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-UIKit框架学习—UITextField</title>
    <link href="https://wynter.wang/2017/04/14/iOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UITextField/"/>
    <id>https://wynter.wang/2017/04/14/iOS-UIKit框架学习—UITextField/</id>
    <published>2017-04-14T09:10:52.000Z</published>
    <updated>2017-04-14T09:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>UITextField对象是一个显示可编辑的文字和动作消息发送到目标对象，当用户按下返回按钮控制。通常可以使用这个类从用户收集少量的文字，并执行一些立即采取行动，如搜索操作，根据该文本。<br><a id="more"></a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NS_CLASS_AVAILABLE_IOS</span>(<span class="number">2</span>_0) <span class="class"><span class="keyword">@interface</span> <span class="title">UITextField</span> : <span class="title">UIControl</span> &lt;<span class="title">UITextInput</span>, <span class="title">NSCoding</span>, <span class="title">UIContentSizeCategoryAdjusting</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 文本</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)   <span class="built_in">NSString</span>               *text;</div><div class="line"><span class="comment">// 富文本</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)   <span class="built_in">NSAttributedString</span>     *attributedText <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"><span class="comment">// 字体颜色</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span>                *textColor;</div><div class="line"><span class="comment">// 字体 默认系统12号</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIFont</span>                 *font;</div><div class="line"><span class="comment">// 对齐方式</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)        <span class="built_in">NSTextAlignment</span>         textAlignment;</div><div class="line"><span class="comment">// 文本边缘风格</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)        <span class="built_in">UITextBorderStyle</span>       borderStyle;</div><div class="line"><span class="comment">// 默认富文本属性</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)   <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt;           *defaultTextAttributes <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</div><div class="line"><span class="comment">// 占位符</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)   <span class="built_in">NSString</span>               *placeholder;</div><div class="line"><span class="comment">// 占位符富文本属性</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)   <span class="built_in">NSAttributedString</span>     *attributedPlaceholder <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"><span class="comment">// 在文本开始编辑的时候是否移除旧文本</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)        <span class="built_in">BOOL</span>                    clearsOnBeginEditing;</div><div class="line"><span class="comment">// 是否根据文本框宽度自动调节字体大小</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)        <span class="built_in">BOOL</span>                    adjustsFontSizeToFitWidth;</div><div class="line"><span class="comment">// 允许最小的字号</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)        <span class="built_in">CGFloat</span>                 minimumFontSize;</div><div class="line"><span class="comment">// 代理</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">weak</span>)   <span class="keyword">id</span>&lt;<span class="built_in">UITextFieldDelegate</span>&gt; delegate;</div><div class="line"><span class="comment">// 表示启用时文本字段的背景外观的图像</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIImage</span>                *background;</div><div class="line"><span class="comment">// 表示禁用时文本字段的背景外观的图像</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIImage</span>                *disabledBackground;</div><div class="line"><span class="comment">// 文本是否处于编辑状态</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">getter</span>=isEditing) <span class="built_in">BOOL</span> editing;</div><div class="line"><span class="comment">// 是否可以编辑文本中的属性</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> allowsEditingTextAttributes <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"><span class="comment">// 用户输入的新文本属性</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *typingAttributes <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"><span class="comment">// 清除按钮类型</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)        <span class="built_in">UITextFieldViewMode</span>  clearButtonMode;</div><div class="line"><span class="comment">// 左侧view</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIView</span>              *leftView;</div><div class="line"><span class="comment">// 左侧视图的类型</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)        <span class="built_in">UITextFieldViewMode</span>  leftViewMode;</div><div class="line"><span class="comment">// 右侧view</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIView</span>              *rightView;</div><div class="line"><span class="comment">// 右侧视图的类型</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>)        <span class="built_in">UITextFieldViewMode</span>  rightViewMode;</div><div class="line"></div><div class="line"><span class="comment">// 返回接收者的CGRect</span></div><div class="line">- (<span class="built_in">CGRect</span>)borderRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)textRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)placeholderRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)editingRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)clearButtonRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)leftViewRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line">- (<span class="built_in">CGRect</span>)rightViewRectForBounds:(<span class="built_in">CGRect</span>)bounds;</div><div class="line"></div><div class="line"><span class="comment">// 绘制文本</span></div><div class="line">- (<span class="keyword">void</span>)drawTextInRect:(<span class="built_in">CGRect</span>)rect;</div><div class="line"><span class="comment">// 绘制占位符文本</span></div><div class="line">- (<span class="keyword">void</span>)drawPlaceholderInRect:(<span class="built_in">CGRect</span>)rect;</div><div class="line"></div><div class="line"><span class="comment">// 输入框成为第一响应显示自定义输入视图</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *inputView;</div><div class="line"><span class="comment">// 输入框成为第一响应显示自定义附件输入视图</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *inputAccessoryView;</div><div class="line"><span class="comment">// 插入文本之前是否替换前一个文本</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> clearsOnInsertion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">UITextField</span>)</span></div><div class="line"><span class="comment">// 是否结束编辑</span></div><div class="line">- (<span class="built_in">BOOL</span>)endEditing:(<span class="built_in">BOOL</span>)force;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITextFieldDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line"><span class="comment">// 是否可以在指定文本中编辑</span></div><div class="line">- (<span class="built_in">BOOL</span>)textFieldShouldBeginEditing:(<span class="built_in">UITextField</span> *)textField;</div><div class="line"><span class="comment">// 开始编辑</span></div><div class="line">- (<span class="keyword">void</span>)textFieldDidBeginEditing:(<span class="built_in">UITextField</span> *)textField;</div><div class="line"><span class="comment">// 是否可以在指定文本中停止</span></div><div class="line">- (<span class="built_in">BOOL</span>)textFieldShouldEndEditing:(<span class="built_in">UITextField</span> *)textField;</div><div class="line"><span class="comment">// 结束编辑</span></div><div class="line">- (<span class="keyword">void</span>)textFieldDidEndEditing:(<span class="built_in">UITextField</span> *)textField;</div><div class="line"><span class="comment">//  替换textFieldDidEndEditing:</span></div><div class="line">- (<span class="keyword">void</span>)textFieldDidEndEditing:(<span class="built_in">UITextField</span> *)textField reason:(<span class="built_in">UITextFieldDidEndEditingReason</span>)reason <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div><div class="line"><span class="comment">// 指定文本是否可以发生改变</span></div><div class="line">- (<span class="built_in">BOOL</span>)textField:(<span class="built_in">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="built_in">NSRange</span>)range replacementString:(<span class="built_in">NSString</span> *)string;</div><div class="line"></div><div class="line"><span class="comment">// 是否可以清除指定内容</span></div><div class="line">- (<span class="built_in">BOOL</span>)textFieldShouldClear:(<span class="built_in">UITextField</span> *)textField;</div><div class="line"><span class="comment">// 按下返回按钮按下是否</span></div><div class="line">- (<span class="built_in">BOOL</span>)textFieldShouldReturn:(<span class="built_in">UITextField</span> *)textField;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 边界风格</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITextBorderStyle</span>) &#123;</div><div class="line">    <span class="built_in">UITextBorderStyleNone</span>,        <span class="comment">//  无</span></div><div class="line">    <span class="built_in">UITextBorderStyleLine</span>,        <span class="comment">// 矩形外观</span></div><div class="line">    <span class="built_in">UITextBorderStyleBezel</span>,       <span class="comment">// 阴影矩形外观</span></div><div class="line">    <span class="built_in">UITextBorderStyleRoundedRect</span>  <span class="comment">// 圆角矩形</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 右侧清空按钮</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITextFieldViewMode</span>) &#123;</div><div class="line">    <span class="built_in">UITextFieldViewModeNever</span>,         <span class="comment">// 从不出现</span></div><div class="line">    <span class="built_in">UITextFieldViewModeWhileEditing</span>,  <span class="comment">// 编辑时出现</span></div><div class="line">    <span class="built_in">UITextFieldViewModeUnlessEditing</span>, <span class="comment">// 除了编辑外出现</span></div><div class="line">    <span class="built_in">UITextFieldViewModeAlways</span>         <span class="comment">// 一直出现</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 将要编辑完成的状态</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITextFieldDidEndEditingReason</span>) &#123;</div><div class="line">    <span class="built_in">UITextFieldDidEndEditingReasonCommitted</span>, <span class="comment">// 提交编辑</span></div><div class="line">    <span class="built_in">UITextFieldDidEndEditingReasonCancelled</span>  <span class="comment">// 取消编辑</span></div><div class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 开始编辑时发送通知</span></div><div class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSNotificationName</span> <span class="keyword">const</span> <span class="built_in">UITextFieldTextDidBeginEditingNotification</span>;</div><div class="line"><span class="comment">// 编辑结束时发送通知</span></div><div class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSNotificationName</span> <span class="keyword">const</span> <span class="built_in">UITextFieldTextDidEndEditingNotification</span>;</div><div class="line"><span class="comment">// 内容变化时发送通知</span></div><div class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSNotificationName</span> <span class="keyword">const</span> <span class="built_in">UITextFieldTextDidChangeNotification</span>;</div><div class="line"></div><div class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UITextFieldDidEndEditingReasonKey</span> <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div></pre></td></tr></table></figure><p>e.g.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITextField</span> *TF = [[<span class="built_in">UITextField</span> alloc] init];</div><div class="line">TF.placeholder = <span class="string">@"请输入用户名"</span>;</div><div class="line">TF.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</div><div class="line">TF.delegate = <span class="keyword">self</span>;</div><div class="line">TF.clearButtonMode = <span class="built_in">UITextFieldViewModeWhileEditing</span>;</div><div class="line">TF.secureTextEntry = <span class="literal">YES</span>;</div><div class="line">TF.font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15.0</span>];</div><div class="line">TF.textColor = <span class="built_in">UIColorFromRGB</span>(<span class="number">0x1a2220</span>);</div><div class="line">TF.tintColor = <span class="built_in">UIColorFromRGB</span>(<span class="number">0x25cfa6</span>); <span class="comment">// 光标颜色</span></div><div class="line">TF.keyboardType = <span class="built_in">UIKeyboardTypeNumberPad</span>;</div><div class="line">TF.returnKeyType = <span class="built_in">UIReturnKeyNext</span>;</div><div class="line">TF.text = <span class="string">@"18888888888"</span>;</div><div class="line">[<span class="keyword">self</span>.view addSubview:TF];</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UITextField对象是一个显示可编辑的文字和动作消息发送到目标对象，当用户按下返回按钮控制。通常可以使用这个类从用户收集少量的文字，并执行一些立即采取行动，如搜索操作，根据该文本。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="API" scheme="https://wynter.wang/tags/API/"/>
    
      <category term="iOS" scheme="https://wynter.wang/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-UIKit框架学习—UISegmentedControl</title>
    <link href="https://wynter.wang/2017/04/14/iOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UISegmentedControl/"/>
    <id>https://wynter.wang/2017/04/14/iOS-UIKit框架学习—UISegmentedControl/</id>
    <published>2017-04-14T09:10:14.000Z</published>
    <updated>2017-04-14T09:17:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个UISegmentedControl对象是横向控制多个段，每个段作为一个独立的按钮运作。分段控制提供一个紧凑的手段，组合到一起的控制。<br><a id="more"></a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NS_CLASS_AVAILABLE_IOS</span>(<span class="number">2</span>_0) <span class="class"><span class="keyword">@interface</span> <span class="title">UISegmentedControl</span> : <span class="title">UIControl</span> &lt;<span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 初始化方法：传入的数组可以是字符串也可以是UIImage对象的图片数组</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithItems:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span> *)items;</div><div class="line"><span class="comment">// 设置是否保持选中状态</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">getter</span>=isMomentary) <span class="built_in">BOOL</span> momentary;</div><div class="line"><span class="comment">// 获取标签个数</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> numberOfSegments;</div><div class="line"><span class="comment">// 设置标签宽度是否随内容自适应 默认是 NO.</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> apportionsSegmentWidthsByContent <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div><div class="line"><span class="comment">// 插入文字标签在index位置</span></div><div class="line">- (<span class="keyword">void</span>)insertSegmentWithTitle:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)title atIndex:(<span class="built_in">NSUInteger</span>)segment animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">// 插入图片标签在index位置</span></div><div class="line">- (<span class="keyword">void</span>)insertSegmentWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image  atIndex:(<span class="built_in">NSUInteger</span>)segment animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">// 根据索引删除标签</span></div><div class="line">- (<span class="keyword">void</span>)removeSegmentAtIndex:(<span class="built_in">NSUInteger</span>)segment animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">// 删除所有标签</span></div><div class="line">- (<span class="keyword">void</span>)removeAllSegments;</div><div class="line"><span class="comment">// 重设标签标题</span></div><div class="line">- (<span class="keyword">void</span>)setTitle:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)title forSegmentAtIndex:(<span class="built_in">NSUInteger</span>)segment;</div><div class="line"><span class="comment">// 获取标签标题</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)titleForSegmentAtIndex:(<span class="built_in">NSUInteger</span>)segment;</div><div class="line"><span class="comment">// 设置标签图片</span></div><div class="line">- (<span class="keyword">void</span>)setImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image forSegmentAtIndex:(<span class="built_in">NSUInteger</span>)segment;</div><div class="line"><span class="comment">// 获取标签图片</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageForSegmentAtIndex:(<span class="built_in">NSUInteger</span>)segment;</div><div class="line"><span class="comment">// 根据索引设置相应标签宽度 设置为0则自动获取，默认值0</span></div><div class="line">- (<span class="keyword">void</span>)setWidth:(<span class="built_in">CGFloat</span>)width forSegmentAtIndex:(<span class="built_in">NSUInteger</span>)segment;</div><div class="line"><span class="comment">// 根据索引获取标签宽度</span></div><div class="line">- (<span class="built_in">CGFloat</span>)widthForSegmentAtIndex:(<span class="built_in">NSUInteger</span>)segment;</div><div class="line"><span class="comment">// 设置标签内容的偏移量 默认值0</span></div><div class="line">- (<span class="keyword">void</span>)setContentOffset:(<span class="built_in">CGSize</span>)offset forSegmentAtIndex:(<span class="built_in">NSUInteger</span>)segment;</div><div class="line"><span class="comment">// 根据索引获取变标签内容的偏移量</span></div><div class="line">- (<span class="built_in">CGSize</span>)contentOffsetForSegmentAtIndex:(<span class="built_in">NSUInteger</span>)segment;</div><div class="line"><span class="comment">// 根据所以设置标签是否有效(默认有效)</span></div><div class="line">- (<span class="keyword">void</span>)setEnabled:(<span class="built_in">BOOL</span>)enabled forSegmentAtIndex:(<span class="built_in">NSUInteger</span>)segment;</div><div class="line"><span class="comment">// 根据索引获取当前标签是否有效</span></div><div class="line">- (<span class="built_in">BOOL</span>)isEnabledForSegmentAtIndex:(<span class="built_in">NSUInteger</span>)segment;</div><div class="line"><span class="comment">// 设置和获取当前选中的标签索引</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> selectedSegmentIndex;</div><div class="line"><span class="comment">// 设置标签风格颜色</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">null_resettable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span> *tintColor;</div><div class="line"><span class="comment">// 置特定状态下segment的背景图案</span></div><div class="line">- (<span class="keyword">void</span>)setBackgroundImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)backgroundImage forState:(<span class="built_in">UIControlState</span>)state barMetrics:(<span class="built_in">UIBarMetrics</span>)barMetrics <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 获取背景图案</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)backgroundImageForState:(<span class="built_in">UIControlState</span>)state barMetrics:(<span class="built_in">UIBarMetrics</span>)barMetrics <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 设置标签之间分割线的图案</span></div><div class="line">- (<span class="keyword">void</span>)setDividerImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)dividerImage forLeftSegmentState:(<span class="built_in">UIControlState</span>)leftState rightSegmentState:(<span class="built_in">UIControlState</span>)rightState barMetrics:(<span class="built_in">UIBarMetrics</span>)barMetrics <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 获取标签之间分割线的图案</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)dividerImageForLeftSegmentState:(<span class="built_in">UIControlState</span>)leftState rightSegmentState:(<span class="built_in">UIControlState</span>)rightState barMetrics:(<span class="built_in">UIBarMetrics</span>)barMetrics  <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 通过Attribute字符串属性字典设置标签标题</span></div><div class="line">- (<span class="keyword">void</span>)setTitleTextAttributes:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)attributes forState:(<span class="built_in">UIControlState</span>)state <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)titleTextAttributesForState:(<span class="built_in">UIControlState</span>)state <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 获取Attribute字符串属性字典</span></div><div class="line">- (<span class="keyword">void</span>)setContentPositionAdjustment:(<span class="built_in">UIOffset</span>)adjustment forSegmentType:(<span class="built_in">UISegmentedControlSegment</span>)leftCenterRightOrAlone barMetrics:(<span class="built_in">UIBarMetrics</span>)barMetrics <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 自行设置标签内容的偏移量</span></div><div class="line">- (<span class="built_in">UIOffset</span>)contentPositionAdjustmentForSegmentType:(<span class="built_in">UISegmentedControlSegment</span>)leftCenterRightOrAlone barMetrics:(<span class="built_in">UIBarMetrics</span>)barMetrics <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    <span class="built_in">UISegmentedControlNoSegment</span> = <span class="number">-1</span>   <span class="comment">// 没有选定分段的下标</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 分段类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UISegmentedControlSegment</span>) &#123;</div><div class="line">    <span class="built_in">UISegmentedControlSegmentAny</span> = <span class="number">0</span>,<span class="comment">// 所有标签都受影响</span></div><div class="line">    <span class="built_in">UISegmentedControlSegmentLeft</span> = <span class="number">1</span>,  <span class="comment">// 只有左边部分受到影响</span></div><div class="line">    <span class="built_in">UISegmentedControlSegmentCenter</span> = <span class="number">2</span>, <span class="comment">// 只有中间部分受到影响</span></div><div class="line">    <span class="built_in">UISegmentedControlSegmentRight</span> = <span class="number">3</span>,  <span class="comment">// 只有右边部分受到影响</span></div><div class="line">    <span class="built_in">UISegmentedControlSegmentAlone</span> = <span class="number">4</span>,  <span class="comment">// 在只有一个标签的时候生效</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>e.g.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UISegmentedControl</span> *segmentedControl = [[<span class="built_in">UISegmentedControl</span> alloc]initWithItems:@[<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>]];</div><div class="line">segmentedControl.frame =  <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">44</span>);</div><div class="line">segmentedControl.tintColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">segmentedControl.apportionsSegmentWidthsByContent = <span class="literal">YES</span>;</div><div class="line">segmentedControl.selectedSegmentIndex = <span class="number">2</span>;</div><div class="line">[segmentedControl addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(clickItem:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line"><span class="keyword">self</span>.navigationItem.titleView = segmentedControl;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个UISegmentedControl对象是横向控制多个段，每个段作为一个独立的按钮运作。分段控制提供一个紧凑的手段，组合到一起的控制。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="API" scheme="https://wynter.wang/tags/API/"/>
    
      <category term="iOS" scheme="https://wynter.wang/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS-UIKit框架学习—UIPageControl</title>
    <link href="https://wynter.wang/2017/03/08/iOS-UIKit%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E2%80%94UIPageControl/"/>
    <id>https://wynter.wang/2017/03/08/iOS-UIKit框架学习—UIPageControl/</id>
    <published>2017-03-08T08:22:19.000Z</published>
    <updated>2017-03-08T08:38:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>您可以使用UIPageControl类来创建和管理页面控制。一个页面控制是在控制中心的点继承。每个点对应一个应用程序的文档（或其他实体的数据模型）页面，白色圆点表示当前浏览的网页。<br><a id="more"></a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NS_CLASS_AVAILABLE_IOS</span>(<span class="number">2</span>_0) <span class="class"><span class="keyword">@interface</span> <span class="title">UIPageControl</span> : <span class="title">UIControl</span></span></div><div class="line"></div><div class="line"><span class="comment">// 页面总数 默认值0</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> numberOfPages;</div><div class="line"><span class="comment">// 当前第几页 默认值0</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> currentPage;</div><div class="line"><span class="comment">// 如果只有一页是否隐藏指示器 默认值NO</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> hidesForSinglePage;</div><div class="line"><span class="comment">// 点击到新的一页不会更新当前的值，直到调用 -updateCurrentPageDisplay ，默认值NO</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> defersCurrentPageDisplay;</div><div class="line"><span class="comment">// 更新当前控件显示的值</span></div><div class="line">- (<span class="keyword">void</span>)updateCurrentPageDisplay;</div><div class="line"><span class="comment">// 返回显示为点所需的最小大小给出页计数</span></div><div class="line">- (<span class="built_in">CGSize</span>)sizeForNumberOfPages:(<span class="built_in">NSInteger</span>)pageCount;</div><div class="line"></div><div class="line"><span class="comment">// 底层指示器颜色</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span> *pageIndicatorTintColor <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"><span class="comment">// 当前指示器颜色</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIColor</span> *currentPageIndicatorTintColor <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;您可以使用UIPageControl类来创建和管理页面控制。一个页面控制是在控制中心的点继承。每个点对应一个应用程序的文档（或其他实体的数据模型）页面，白色圆点表示当前浏览的网页。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://wynter.wang/categories/iOS/"/>
    
    
      <category term="API" scheme="https://wynter.wang/tags/API/"/>
    
      <category term="iOS" scheme="https://wynter.wang/tags/iOS/"/>
    
  </entry>
  
</feed>
